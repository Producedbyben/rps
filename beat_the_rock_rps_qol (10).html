<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beat The Rock: Challenge Dwayne Johnson at Rock Paper Scissors</title>
  <style>
    :root {
      --bg-ink: #120d19;
      --bg-purple: #2b143f;
      --bg-emerald: #123226;
      --panel: rgba(34, 20, 47, 0.86);
      --panel-soft: rgba(58, 32, 73, 0.8);
      --line: rgba(247, 205, 118, 0.45);
      --line-strong: rgba(247, 205, 118, 0.78);
      --text: #f8efd8;
      --text-soft: #d8c8a1;
      --accent-gold: #f7cd76;
      --accent-red: #ef5a6f;
      --accent-green: #7be0a4;
      --accent-blue: #6ec7ff;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
      --radius: 16px;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      color: var(--text);
      font-family: "Trebuchet MS", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      padding: 14px;
      background:
        radial-gradient(circle at 14% 10%, rgba(247,205,118,0.18), transparent 35%),
        radial-gradient(circle at 82% 16%, rgba(110,199,255,0.17), transparent 32%),
        radial-gradient(circle at 50% 100%, rgba(123,224,164,0.15), transparent 46%),
        linear-gradient(165deg, #120d19 0%, #261437 46%, #132f23 100%);
      background-attachment: fixed;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image:
        repeating-linear-gradient(45deg, rgba(255,255,255,0.025) 0 2px, transparent 2px 9px),
        radial-gradient(circle at center, transparent 0 55%, rgba(0,0,0,0.45) 100%);
      mix-blend-mode: soft-light;
      z-index: -1;
    }

    .app {
      width: min(1040px, 100%);
      margin: 0 auto 20px;
      padding: 22px;
      border: 2px solid var(--line);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(34,20,47,0.94), rgba(20,12,30,0.95));
      box-shadow: var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    h1 {
      margin: 0;
      text-align: center;
      font-size: clamp(2rem, 4.2vw, 3rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #fff3cf;
      text-shadow: 0 0 0 #000, 0 2px 0 rgba(0,0,0,0.5), 0 0 24px rgba(247,205,118,0.32);
    }
    .subtitle {
      margin: 8px auto 14px;
      text-align: center;
      max-width: 76ch;
      color: var(--text-soft);
      font-size: 0.95rem;
    }

    .title-shell,
    .map-panel,
    .event-card,
    .relic-strip,
    .relic-choice-panel,
    .summary-card,
    .profile-card,
    .drawer-panel,
    .post-match-card,
    .menu-panel,
    .round-board,
    .codex-card,
    .achievement-card,
    .shop-panel,
    .tutorial-panel,
    .help-box,
    .adaptive-stats,
    .pre-round-hint,
    #battleLog,
    #narrativeFeed,
    #momentumPanel {
      background: linear-gradient(180deg, var(--panel-soft), rgba(21, 13, 31, 0.94));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 10px 24px rgba(0,0,0,0.34);
    }

    .hud-chip,
    .run-summary-pill,
    .run-mode-badge,
    .mood-display,
    .curse-hud,
    .settings-control,
    .settings-row label,
    .seed-row button,
    .challenge-mode-row button,
    .menu-btn,
    .menu-close-btn,
    .round-result-overlay-card,
    .relic-pill,
    .map-node-btn,
    .event-choice-btn,
    .relic-choice-btn,
    .shop-item-btn,
    .btn-achievements-reset,
    .tutorial-skip-btn,
    .btn,
    button {
      border-radius: 999px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(79,45,88,0.95), rgba(47,27,63,0.95));
      color: var(--text);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 4px 9px rgba(0,0,0,0.34);
    }

    button,
    .map-node-btn,
    .event-choice-btn,
    .relic-choice-btn,
    .shop-item-btn,
    .menu-btn,
    .btn,
    .challenge-mode-row button,
    .seed-row button { cursor: pointer; transition: transform 0.12s ease, filter 0.12s ease, box-shadow 0.12s ease; }
    button:hover,
    .map-node-btn:hover,
    .event-choice-btn:hover,
    .relic-choice-btn:hover,
    .shop-item-btn:hover,
    .menu-btn:hover,
    .btn:hover,
    .challenge-mode-row button:hover,
    .seed-row button:hover {
      transform: translateY(-1px);
      filter: brightness(1.09);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.11), 0 7px 14px rgba(0,0,0,0.38);
    }

    .btn-primary { background: linear-gradient(180deg, #e6b85d, #c1842e); color: #1a0f07; border-color: #ffd688; font-weight: 700; }
    .btn-secondary { background: linear-gradient(180deg, #6ec7ff, #3f82c7); color: #f2fbff; border-color: #9dd9ff; }
    .btn-tertiary { background: linear-gradient(180deg, #7be0a4, #3d9a68); color: #062313; border-color: #a3f0c2; }
    .btn-rock { background: linear-gradient(180deg, #f1bc62, #ac6f2d); color: #221203; }
    .btn-paper { background: linear-gradient(180deg, #f29ac0, #b24b7f); color: #2f081d; }
    .btn-scissors { background: linear-gradient(180deg, #90d7ff, #3c78b4); color: #04172a; }
    .btn-reset { background: linear-gradient(180deg, #ff8c8c, #bb3232); color: #2b0707; }

    .title-shell { text-align: center; padding: 18px; margin-bottom: 12px; }
    .match-setup { margin-top: 14px; padding: 12px; border-radius: 12px; border: 1px dashed var(--line); background: rgba(22, 13, 31, 0.85); }
    .match-setup h3, .relic-strip-title, .map-header, .round-board-header, .help-box summary { text-transform: uppercase; letter-spacing: 0.08em; color: #ffe5aa; }

    .seed-row, .settings-row, .challenge-mode-row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: center; }
    .seed-row input {
      background: rgba(12, 7, 18, 0.95);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
    }

    .hud-row { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 10px 0 12px; }
    .hud-chip, .run-summary-pill, .mood-display, .curse-hud { padding: 8px 12px; font-size: 0.8rem; }

    .arena {
      position: relative;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      padding: 22px 16px;
      border-radius: 18px;
      border: 2px solid var(--line-strong);
      background:
        radial-gradient(circle at 50% -10%, rgba(247,205,118,0.28), transparent 45%),
        linear-gradient(180deg, rgba(21,13,31,0.95), rgba(30,17,42,0.96));
      box-shadow: var(--shadow), inset 0 0 34px rgba(247,205,118,0.12);
      overflow: hidden;
    }
    .arena::before {
      content: "";
      position: absolute;
      inset: 10px;
      border-radius: 12px;
      border: 1px dashed rgba(247,205,118,0.24);
      pointer-events: none;
    }
    .side h2 { margin: 0 0 6px; font-size: 0.92rem; color: var(--text-soft); text-transform: uppercase; letter-spacing: 0.08em; }
    .side .name-rock { color: #ffc168; }
    .side .name-you { color: #95edba; }
    .hand { font-size: clamp(2.8rem, 7vw, 4.3rem); text-shadow: 0 3px 0 rgba(0,0,0,0.4), 0 0 14px rgba(247,205,118,0.35); }
    .vs { padding: 8px 12px; border-radius: 999px; border: 2px solid var(--line); color: #fff3cf; background: rgba(0,0,0,0.4); font-weight: 700; }

    .progress-bar { height: 8px; border-radius: 999px; border: 1px solid var(--line); background: rgba(0,0,0,0.45); overflow: hidden; }
    .progress-fill { background: linear-gradient(90deg, #7be0a4, #6ec7ff, #f7cd76); }

    .round-board-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(20px, 1fr)); gap: 5px; }
    .round-box { min-height: 48px; border-radius: 10px; border: 1px solid rgba(247,205,118,0.3); background: rgba(24,15,35,0.95); color: var(--text-soft); }
    .round-box.played.win { background: rgba(24, 72, 48, 0.85); border-color: rgba(123,224,164,0.9); }
    .round-box.played.lose { background: rgba(104, 34, 41, 0.85); border-color: rgba(239,90,111,0.9); }
    .round-box.played.draw { background: rgba(95, 69, 28, 0.85); border-color: rgba(247,205,118,0.9); }

    .map-panel, .relic-strip, .event-card, .relic-choice-panel { padding: 12px; margin-bottom: 10px; }
    .map-node-btn.current { border-color: var(--accent-green); box-shadow: 0 0 0 1px rgba(123,224,164,0.42) inset; }

    .scene { margin-top: 10px; }
    .is-hidden { display: none !important; }

    .result-line { text-align: center; margin-top: 12px; font-size: 1.03rem; }
    .result-win { color: var(--accent-green); }
    .result-lose { color: var(--accent-red); }
    .result-draw { color: var(--accent-gold); }

    .post-match-overlay,
    .menu-modal,
    .cinematic-card-overlay { backdrop-filter: blur(4px); background: rgba(8, 4, 14, 0.66); }
    .post-match-card,
    .menu-panel,
    .cinematic-card { max-width: min(880px, 94vw); }

    .achievement-toast { border-color: var(--line-strong); background: linear-gradient(180deg, rgba(73,40,24,0.95), rgba(47,25,17,0.95)); }

    @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} }
    @keyframes lockPulse { 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.15)} }
    @keyframes microShake { 0%,100%{transform:translate(0,0)} 25%{transform:translate(-2px,1px)} 50%{transform:translate(2px,-1px)} 75%{transform:translate(-1px,-1px)} }
    @keyframes anticipationGlow { 0%,100%{box-shadow:var(--shadow)} 50%{box-shadow:var(--shadow),0 0 32px rgba(247,205,118,0.28)} }
    @keyframes revealDrop { from { transform: translateY(-8px) scale(0.95); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }
    @keyframes cameraSwayWin { 0%,100%{transform:translateX(0)} 50%{transform:translateX(5px)} }
    @keyframes cameraSwayLose { 0%,100%{transform:translateX(0)} 50%{transform:translateX(-5px)} }
    @keyframes cameraSwayDraw { 0%,100%{transform:translateY(0)} 50%{transform:translateY(2px)} }
    @keyframes cinematicFlash { from { opacity: 0.6; } to { opacity: 0; } }

    @media (max-width: 860px) {
      .app { padding: 16px; }
      .arena { grid-template-columns: 1fr; text-align: center; }
      .vs { justify-self: center; }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after { animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; }
    }
  </style>
</head>
<body>
  <div id="achievementToasts" class="achievement-toast-stack" aria-live="polite" aria-atomic="false"></div>
  <div class="app">
    <h1>Beat The Rock</h1>
    <div class="subtitle">A seeded branching run against a modeled Dwayne "The Rock" Johnson. Read his tendencies, outplay the script, and win the showdown.</div>

    <section id="sceneMetaPanels" class="scene">
      <div class="app-toolbar">
        <button id="gameMenuBtn" class="menu-btn" type="button" aria-controls="gameMenuModal" aria-expanded="false">Fight Menu</button>
      </div>
    </section>

    <div class="hud-row" aria-label="Match HUD">
      <div class="run-summary">
        <div id="runSummaryPill" class="run-summary-pill is-hidden">
          <span><strong>Run</strong> live</span>
          <span id="runSummarySeed" class="run-mode-badge">Seed pending</span>
          <span id="runSummaryMode" class="run-mode-badge">Mode pending</span>
        </div>
      </div>
      <div id="roundLabel" class="hud-chip">Act 1 Node 1</div>
      <div id="scoreLabel" class="hud-chip">The Rock 0  |  You 0  |  Draws 0</div>
      <div id="resolveLabel" class="hud-chip">Resolve 12/12</div>
      <div id="cashLabel" class="hud-chip">Cash $0</div>
      <div id="moodDisplay" class="mood-display severity-low">üßä The Rock is calm ¬∑ Read risk 30%</div>
      <div id="curseHud" class="curse-hud" aria-live="polite">
        <div class="curse-hud-title">Active curses</div>
        <div id="curseHudList" class="curse-hud-list">
          <span class="curse-empty">No curses active.</span>
        </div>
      </div>
    </div>

    <div id="relicStrip" class="relic-strip" aria-live="polite">
      <div class="relic-strip-title">Active relics</div>
      <div id="relicStripList" class="relic-strip-list">
        <span class="relic-empty">No relics yet. Win encounters to draft perks.</span>
      </div>
    </div>

    <section id="sceneLobby" class="scene">
      <div class="title-shell">
        <h2>Welcome to Beat The Rock</h2>
        <p>He has the script. Follow the branching run map and break it before the bell.</p>
        <button id="startMatchBtn" class="btn-primary" type="button">Start Match</button>

        <div class="match-setup">
          <h3>Match Setup</h3>
          <div class="seed-row">
            <label>Next run seed <input id="seedInput" type="text" placeholder="blank = random" /></label>
            <button id="randomSeedBtn" type="button">Generate random seed</button>
            <button id="resetProfileBtn" type="button">Reset profile</button>
            <div id="seedFeedback" class="seed-feedback" aria-live="polite"></div>
          </div>

          <div class="challenge-mode-row" role="group" aria-label="Challenge run modes">
            <button id="casualModeBtn" class="active" type="button">Casual setup</button>
            <button id="dailyModeBtn" type="button">Start Daily run</button>
            <button id="weeklyModeBtn" type="button">Start Weekly run</button>
          </div>
          <div id="challengeRules" class="challenge-rules" aria-live="polite">Casual mode: seed and adaptive settings are fully editable.</div>

          <div class="mode-toggle">
            <label><input type="checkbox" id="adaptiveToggle" /> Adaptive Rock mode, he reads your status, trends, and last move after round 1.</label>
          </div>

          <div class="settings-row">
            <label><input type="checkbox" id="sfxToggle" checked /> Sound effects on</label>
            <label class="settings-control">Ambience <input id="ambientVol" type="range" min="0" max="100" step="1" value="35" /></label>
            <label class="settings-control">Hit confirm <input id="confirmVol" type="range" min="0" max="100" step="1" value="55" /></label>
            <label class="settings-control">UI pips <input id="uiVol" type="range" min="0" max="100" step="1" value="45" /></label>
          </div>
        </div>
      </div>
      <div id="adaptiveStats" class="adaptive-stats"><strong>Adaptive Rock</strong> is off. Flip the switch to let him try and read you.</div>
      <div id="preRoundHint" class="pre-round-hint">Pre-round scout, he's waiting for your opener.</div>
      <div id="eventLobbyCard" class="event-card">
        <h3>Run events</h3>
        <p>Branching event nodes can grant risky relic deals, tactical shields, or hidden boss variants.</p>
      </div>
      <div class="summary-card">
        <h2>Lobby</h2>
        <p>Use Match panels for Stats, Achievements, Replay/Seed, and Debug. Set seed, adaptive mode, and SFX in Match Setup, then hit Start Match to enter the arena.</p>
      </div>
      <div class="profile-card">
        <h3 id="profileLevelLabel">Profile level 1</h3>
        <p id="profileXpLabel">0 / 100 XP</p>
        <div class="profile-progress"><div id="profileProgressFill" class="profile-progress-fill"></div></div>
      </div>
    </section>

    <section id="sceneGame" class="scene">

      <div id="mapPanel" class="map-panel">
        <div class="map-header">
          <span id="mapCurrentLabel">Current node: pending</span>
          <span id="mapProgressLabel">Path 0/0</span>
        </div>
        <div id="mapPath" class="map-path">Completed path: none yet.</div>
        <div id="mapChoices" class="map-choices" role="group" aria-label="Choose next map node"></div>
      </div>

      <div id="eventPanel" class="event-card is-hidden" aria-live="polite">
        <h3 id="eventTitle">Event</h3>
        <p id="eventBody">A side scene unfolds between clashes.</p>
        <div id="eventChoiceGrid" class="event-choice-grid"></div>
      </div>

      <div id="relicChoicePanel" class="relic-choice-panel is-hidden" aria-live="polite">
        <h3>Pick one relic</h3>
        <p>Choose your perk before moving to the next node.</p>
        <div id="relicChoiceGrid" class="relic-choice-grid"></div>
      </div>

      <div class="arena-wrap">
        <div id="arena" class="arena">
          <div id="arenaWash" class="arena-wash" aria-hidden="true"></div>
          <div class="side">
            <h2><span id="enemyArenaName" class="name-rock">Dwayne</span> (<span id="enemyArenaTitle">The Rock</span>)</h2>
            <div id="enemyArenaGimmick" class="settings-hint">Arena feed: waiting on opponent intel.</div>
            <div id="rockHand" class="hand">‚ùî</div>
            <div id="rockMoveLabel" class="label-move">Awaiting the opening bell.</div>
          </div>
          <div class="vs">R P S</div>
          <div class="side">
            <h2><span class="name-you">You</span></h2>
            <div id="yourHand" class="hand">‚ùî</div>
            <div id="yourMoveLabel" class="label-move">Pick your opening throw.</div>
          </div>
        </div>
      </div>


      <div class="progress-wrap">
        <div class="progress-labels">
          <span>Node progress</span>
          <span id="progressText">0 of 0 completed</span>
        </div>
        <div class="progress-bar"><div id="progressFill" class="progress-fill"></div></div>
      </div>

      <div id="moveButtonsAnchor" class="controls">
        <button class="btn-rock" data-move="R" aria-label="Play Rock hand"><span class="hand-icon">‚úä</span> Rock</button>
        <button class="btn-paper" data-move="P" aria-label="Play Paper hand"><span class="hand-icon">‚úã</span> Paper</button>
        <button class="btn-scissors" data-move="S" aria-label="Play Scissors hand"><span class="hand-icon">‚úåÔ∏è</span> Scissors</button>
        <button id="resetBtn" class="btn-reset" style="display:none;">Start new showdown</button>
      </div>
      <div id="resultLine" class="result-line" role="status" aria-live="polite" aria-atomic="true"></div>
      <div class="commentary-wrap">
        <div class="commentary-title">Commentary desk</div>
        <div id="commentary" class="commentary" role="status" aria-live="polite" aria-atomic="true"></div>
      </div>

      <div id="seedShareAnchor" class="challenge-row">
        <button id="copyLinkBtn" class="btn-share" type="button">Copy challenge link</button>
        <button id="copyResultBtn" class="btn-share" type="button">Copy challenge result</button>
        <div id="copyStatus" class="copy-status" aria-live="polite"></div>
      </div>

      <section class="analysis-drawer" aria-label="Match intelligence panels">
        <h2 class="analysis-drawer-title">Match panels</h2>
        <details id="statsPanel" class="drawer-panel" open>
          <summary>Stats</summary>
          <div class="drawer-panel-body">
            <div class="round-board">
              <div class="round-board-header">
                <span>Run node fight card (result + hands + order)</span>
                <span>Outcomes use W/L/D</span>
                <span id="roundBoardStatus">Round 1 is underway</span>
              </div>
              <div id="roundBoard" class="round-board-grid"></div>
              <div id="roundBoardPreview" class="round-board-preview">Hover, focus, or tap a played round to preview exact hands, outcome, and mood.</div>
            </div>
          </div>
        </details>

        <details id="achievementsPanel" class="drawer-panel">
          <summary>Achievements</summary>
          <div class="drawer-panel-body">
            <div class="achievements">
              <div class="achievements-header">
                <span>Run achievements</span>
                <button id="resetAchievementsBtn" class="btn-achievements-reset" type="button">Reset achievements</button>
              </div>
              <div id="achievementsList" class="achievements-list"></div>
            </div>
          </div>
        </details>

        <details id="replaySeedPanel" class="drawer-panel">
          <summary>Replay & Seed</summary>
          <div class="drawer-panel-body">
            <p class="settings-hint">Seed and mode controls now live in Match Setup before you start a run.</p>
          </div>
        </details>

        <details id="codexPanel" class="drawer-panel">
          <summary>Codex</summary>
          <div class="drawer-panel-body">
            <div class="codex-grid">
              <div class="codex-card"><h4>Relics</h4><ul id="codexRelics" class="codex-list"></ul></div>
              <div class="codex-card"><h4>Events</h4><ul id="codexEvents" class="codex-list"></ul></div>
              <div class="codex-card"><h4>Enemies</h4><ul id="codexEnemies" class="codex-list"></ul></div>
            </div>
          </div>
        </details>

        <details id="debugPanel" class="drawer-panel debug-panel">
          <summary><span>Debug</span></summary>
          <div class="drawer-panel-body">
            <div id="debugLog" class="debug-log"></div>
          </div>
        </details>
      </section>
    </section>

    <section id="sceneSummary" class="post-match-overlay is-hidden" aria-live="polite" aria-atomic="true">
      <div class="post-match-card">
        <div id="summaryWinnerBanner" class="post-match-banner">Match complete</div>
        <h2 id="summaryTitle" class="post-match-title">Run complete</h2>
        <p id="summaryFlavor" class="post-match-flavor">Review your post-match stats and jump right back into another run.</p>

        <div class="post-match-stats">
          <div class="post-match-stat">
            <div class="post-match-stat-label">Best streak</div>
            <div id="summaryBestStreak" class="post-match-stat-value">0 rounds</div>
          </div>
          <div class="post-match-stat">
            <div class="post-match-stat-label">Beat-Rock hit rate</div>
            <div id="summaryBeatRockRate" class="post-match-stat-value">0%</div>
          </div>
          <div class="post-match-stat">
            <div class="post-match-stat-label">Mood pressure moments</div>
            <div id="summaryMoodPressure" class="post-match-stat-value">0 rounds</div>
          </div>
        </div>

        <div id="summaryEventCard" class="event-card">
          <h3>Run events</h3>
          <p id="summaryEventFlavor">No event decisions logged this run.</p>
          <ul id="summaryEventList" class="event-log-list"></ul>
        </div>

        <div id="summaryUnlocks" class="summary-unlocks is-hidden"><h3>New profile unlocks</h3><ul id="summaryUnlockList"></ul></div>

        <div class="post-match-achievements">
          <h3>Achievements unlocked this run</h3>
          <ul id="summaryAchievementsList"></ul>
          <p id="summaryAchievementsEmpty">No achievements this run. Try a new seed or strategy and run it back.</p>
        </div>

        <div class="post-match-actions">
          <button id="summaryPlayAgainBtn" class="btn-primary" type="button">Play Again</button>
          <button id="summaryCopyLinkBtn" class="btn-secondary" type="button">Copy Challenge Link</button>
          <button id="summaryCopyResultBtn" class="btn-secondary" type="button">Copy Challenge Result</button>
          <button id="summaryViewBoardBtn" class="btn-tertiary" type="button">View Full Round Board</button>
        </div>
      </div>
    </section>

    <div id="roundResultOverlay" class="round-result-overlay is-hidden" aria-live="polite" aria-atomic="true">
      <div id="roundResultOverlayText" class="round-result-overlay-card"></div>
    </div>

    <div id="cinematicCardOverlay" class="cinematic-card-overlay is-hidden" aria-live="polite" aria-atomic="true">
      <div id="cinematicCard" class="cinematic-card">
        <div id="cinematicCardTag" class="cinematic-card-tag">Main event</div>
        <h2 id="cinematicCardTitle" class="cinematic-card-title">Fight card</h2>
        <p id="cinematicCardBody" class="cinematic-card-body">The next clash is stepping through the ropes.</p>
      </div>
    </div>

    <div id="gameMenuModal" class="menu-modal" role="dialog" aria-modal="true" aria-labelledby="gameMenuTitle">
      <div class="menu-panel">
        <div class="menu-header">
          <h2 id="gameMenuTitle">Fight Menu</h2>
          <button id="closeMenuBtn" class="menu-close-btn" type="button">Close</button>
        </div>

        <div class="settings-row">
          <button id="replayTutorialBtn" class="menu-btn" type="button">Replay Tutorial</button>
          <span class="settings-hint">Keyboard, R P S to play moves.</span>
        </div>

        <details class="help-box">
          <summary>How the showdown works</summary>
          <div class="help-box-content">
            <ul>
              <li>Every showdown follows a seeded node path, and each node is logged on the fight card with hands and W/L/D.</li>
              <li>Dwayne "The Rock" Johnson starts on a seeded script. In Adaptive mode, after round 1 he uses score state, mood, and your recent trends to choose his next hand.</li>
              <li>His mood shifts from Calm to Suspicious to Paranoid based on recent losses, and each mood changes his read chance.</li>
              <li>Use the round board hover/focus preview to inspect exact hands, state, and whether the adaptive path was used.</li>
              <li>Set a seed in Replay & Seed to replay exact showdowns, or leave it blank to randomize the next reset.</li>
              <li>Achievements cover clutch, chaos, mood, sequence, and consolation badges. Unlocks are instant and increase their multiplier for this browser profile.</li>
            </ul>
            <div class="help-legend">
              <span><strong>Calm</strong> 30% adapt chance</span>
              <span><strong>Suspicious</strong> 60% adapt chance</span>
              <span><strong>Paranoid</strong> 90% adapt chance</span>
            </div>
          </div>
        </details>

      </div>
    </div>



    <div id="tutorialTooltip" class="tutorial-tooltip is-hidden" role="status" aria-live="polite">
      <div id="tutorialTooltipTitle" class="tutorial-tooltip-title"></div>
      <p id="tutorialTooltipText" class="tutorial-tooltip-text"></p>
      <div class="tutorial-tooltip-actions">
        <button id="tutorialSkipBtn" class="tutorial-skip-btn" type="button">Skip walkthrough</button>
      </div>
    </div>

    <div class="footer">
      With Adaptive Rock off, Dwayne follows a seeded script. With it on, he weighs score state and trends to make adaptive reads.<br />
      Each seed builds a different script, so players can share a seed and replay the same baseline showdown.
    </div>
  </div>

  <script>
    const ROCK_MOVES = ["R", "P", "S"];
    const SCRIPT_SEQUENCE_REGEX = /^[RPS]{20}$/i;
    const beats = { R: "P", P: "S", S: "R" };
    const names = { R: "Rock", P: "Paper", S: "Scissors" };
    const glyph = { R: "‚úä", P: "‚úã", S: "‚úåÔ∏è" };

    const rockLosingQuips = [
      "The Rock arches an eyebrow. This is not how it went in the script.",
      "He pauses, looks at his hand, then at you. That is not very family friendly language.",
      "The Great One is now The Mildly Confused One.",
      "He mutters something about the writer's room and probability.",
      "The Rock is starting to realise this franchise might be yours."
    ];
    const rockWinningQuips = [
      "The Rock grins. Finally, the universe remembers who the headline act is.",
      "He does the tiny air guitar thing. You walked right into that.",
      "He whispers, 'Know your role,' which is frankly unnecessary.",
      "The arena pops. You promise yourself you will focus next round.",
      "He smells what he is cooking. It is your defeat."
    ];
    const drawQuips = [
      "You both stare at identical hands. Awkward.",
      "The Rock nods in approval. 'Respect,' he says.",
      "Stalemate. Somewhere, a statistician sighs.",
      "Nobody wins, nobody loses, but you both sell it like a main event.",
      "Evenly matched. The crowd loves a slow burn."
    ];
    const beatRockQuips = [
      "That was the exact hand to beat The Rock this round. Somewhere, a game theorist applauds.",
      "You hit the exact hand to beat The Rock. He absolutely hates that.",
      "Perfect read. If this were pay per view, they would replay that one.",
      "Peak efficiency. Your hand might need its own entrance music soon.",
      "That was so clinical the ref checks on The Rock."
    ];
    const missedBeatRockQuips = [
      "There was a better move there, but hey, style points still count.",
      "Not the ideal beat-The-Rock choice, but the crowd appreciates the chaos.",
      "You zigged where the model zagged. Daring.",
      "You ignore optimal play and follow your heart. Bold strategy.",
      "Somewhere, the beat-The-Rock timeline branches off without you."
    ];

    const gameTitleEl = document.querySelector("h1");
    const rockHandEl = document.getElementById("rockHand");
    const yourHandEl = document.getElementById("yourHand");
    const rockMoveLabelEl = document.getElementById("rockMoveLabel");
    const yourMoveLabelEl = document.getElementById("yourMoveLabel");
    const roundLabelEl = document.getElementById("roundLabel");
    const scoreLabelEl = document.getElementById("scoreLabel");
    const resolveLabelEl = document.getElementById("resolveLabel");
    const cashLabelEl = document.getElementById("cashLabel");
    const curseHudEl = document.getElementById("curseHud");
    const curseHudListEl = document.getElementById("curseHudList");
    const resultLineEl = document.getElementById("resultLine");
    const commentaryEl = document.getElementById("commentary");
    const resetBtn = document.getElementById("resetBtn");
    const moveButtons = Array.from(document.querySelectorAll("button[data-move]"));
    const moveButtonsAnchorEl = document.getElementById("moveButtonsAnchor");
    const adaptiveToggle = document.getElementById("adaptiveToggle");
    const arenaEl = document.getElementById("arena");
    const progressFillEl = document.getElementById("progressFill");
    const progressTextEl = document.getElementById("progressText");
    const adaptiveStatsEl = document.getElementById("adaptiveStats");
    const moodDisplayEl = document.getElementById("moodDisplay");
    const seedInputEl = document.getElementById("seedInput");
    const randomSeedBtn = document.getElementById("randomSeedBtn");
    const debugLogEl = document.getElementById("debugLog");
    const achievementsListEl = document.getElementById("achievementsList");
    const statsPanelEl = document.getElementById("statsPanel");
    const achievementsPanelEl = document.getElementById("achievementsPanel");
    const replaySeedPanelEl = document.getElementById("replaySeedPanel");
    const debugPanelEl = document.getElementById("debugPanel");
    const runSummaryPillEl = document.getElementById("runSummaryPill");
    const runSummarySeedEl = document.getElementById("runSummarySeed");
    const runSummaryModeEl = document.getElementById("runSummaryMode");
    const startMatchBtn = document.getElementById("startMatchBtn");
    const sfxToggle = document.getElementById("sfxToggle");
    const ambientVolEl = document.getElementById("ambientVol");
    const confirmVolEl = document.getElementById("confirmVol");
    const uiVolEl = document.getElementById("uiVol");
    const seedFeedbackEl = document.getElementById("seedFeedback");
    const preRoundHintEl = document.getElementById("preRoundHint");
    const roundBoardEl = document.getElementById("roundBoard");
    const roundBoardStatusEl = document.getElementById("roundBoardStatus");
    const roundBoardPreviewEl = document.getElementById("roundBoardPreview");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const copyResultBtn = document.getElementById("copyResultBtn");
    const seedShareAnchorEl = document.getElementById("seedShareAnchor");
    const copyStatusEl = document.getElementById("copyStatus");
    const achievementToastsEl = document.getElementById("achievementToasts");
    const resetAchievementsBtn = document.getElementById("resetAchievementsBtn");
    const sceneLobbyEl = document.getElementById("sceneLobby");
    const sceneGameEl = document.getElementById("sceneGame");
    const sceneSummaryEl = document.getElementById("sceneSummary");
    const summaryWinnerBannerEl = document.getElementById("summaryWinnerBanner");
    const summaryTitleEl = document.getElementById("summaryTitle");
    const summaryFlavorEl = document.getElementById("summaryFlavor");
    const summaryBestStreakEl = document.getElementById("summaryBestStreak");
    const summaryBeatRockRateEl = document.getElementById("summaryBeatRockRate");
    const summaryMoodPressureEl = document.getElementById("summaryMoodPressure");
    const summaryAchievementsListEl = document.getElementById("summaryAchievementsList");
    const summaryAchievementsEmptyEl = document.getElementById("summaryAchievementsEmpty");
    const summaryPlayAgainBtn = document.getElementById("summaryPlayAgainBtn");
    const summaryCopyLinkBtn = document.getElementById("summaryCopyLinkBtn");
    const summaryCopyResultBtn = document.getElementById("summaryCopyResultBtn");
    const summaryViewBoardBtn = document.getElementById("summaryViewBoardBtn");
    const gameMenuBtn = document.getElementById("gameMenuBtn");
    const gameMenuModal = document.getElementById("gameMenuModal");
    const closeMenuBtn = document.getElementById("closeMenuBtn");
    const replayTutorialBtn = document.getElementById("replayTutorialBtn");
    const tutorialTooltipEl = document.getElementById("tutorialTooltip");
    const tutorialTooltipTitleEl = document.getElementById("tutorialTooltipTitle");
    const tutorialTooltipTextEl = document.getElementById("tutorialTooltipText");
    const tutorialSkipBtn = document.getElementById("tutorialSkipBtn");
    const roundResultOverlayEl = document.getElementById("roundResultOverlay");
    const roundResultOverlayTextEl = document.getElementById("roundResultOverlayText");
    const cinematicCardOverlayEl = document.getElementById("cinematicCardOverlay");
    const cinematicCardEl = document.getElementById("cinematicCard");
    const cinematicCardTagEl = document.getElementById("cinematicCardTag");
    const cinematicCardTitleEl = document.getElementById("cinematicCardTitle");
    const cinematicCardBodyEl = document.getElementById("cinematicCardBody");
    const arenaWashEl = document.getElementById("arenaWash");
    const mapPanelEl = document.getElementById("mapPanel");
    const mapCurrentLabelEl = document.getElementById("mapCurrentLabel");
    const mapProgressLabelEl = document.getElementById("mapProgressLabel");
    const mapPathEl = document.getElementById("mapPath");
    const mapChoicesEl = document.getElementById("mapChoices");
    const relicStripListEl = document.getElementById("relicStripList");
    const relicChoicePanelEl = document.getElementById("relicChoicePanel");
    const relicChoiceGridEl = document.getElementById("relicChoiceGrid");
    const eventPanelEl = document.getElementById("eventPanel");
    const eventTitleEl = document.getElementById("eventTitle");
    const eventBodyEl = document.getElementById("eventBody");
    const eventChoiceGridEl = document.getElementById("eventChoiceGrid");
    const summaryEventFlavorEl = document.getElementById("summaryEventFlavor");
    const summaryEventListEl = document.getElementById("summaryEventList");
    const enemyArenaNameEl = document.getElementById("enemyArenaName");
    const enemyArenaTitleEl = document.getElementById("enemyArenaTitle");
    const enemyArenaGimmickEl = document.getElementById("enemyArenaGimmick");
    const casualModeBtn = document.getElementById("casualModeBtn");
    const dailyModeBtn = document.getElementById("dailyModeBtn");
    const weeklyModeBtn = document.getElementById("weeklyModeBtn");
    const challengeRulesEl = document.getElementById("challengeRules");
    const codexPanelEl = document.getElementById("codexPanel");
    const codexRelicsEl = document.getElementById("codexRelics");
    const codexEventsEl = document.getElementById("codexEvents");
    const codexEnemiesEl = document.getElementById("codexEnemies");
    const profileLevelLabelEl = document.getElementById("profileLevelLabel");
    const profileXpLabelEl = document.getElementById("profileXpLabel");
    const profileProgressFillEl = document.getElementById("profileProgressFill");
    const summaryUnlocksEl = document.getElementById("summaryUnlocks");
    const summaryUnlockListEl = document.getElementById("summaryUnlockList");
    const resetProfileBtn = document.getElementById("resetProfileBtn");

    const U32_MIN = 0;
    const U32_MAX = 0xFFFFFFFF;
    const U32_MAX_BIGINT = BigInt(U32_MAX);
    const DEFAULT_SEED = 1;
    const TERNARY_SPACE = 3486784401;
    const DIGITS_ONLY_REGEX = /^\d+$/;
    const ACHIEVEMENTS_STORAGE_KEY = "beatTheRockAchievementCounts.v2";
    const TUTORIAL_STORAGE_KEY = "beatTheRockTutorialState.v1";
    const CHALLENGE_STATS_KEY_PREFIX = "beatTheRockModeStats.v1";
    const PROFILE_STORAGE_KEY = "beatTheRockProfile.v1";
    const PROFILE_SCHEMA_VERSION = 1;
    const PROFILE_MILESTONES = [
      { id: "finish-1", xp: 40, text: "First completed run" },
      { id: "finish-5", xp: 65, text: "Complete 5 total runs" },
      { id: "finish-15", xp: 90, text: "Complete 15 total runs" },
      { id: "wins-1", xp: 35, text: "First run victory" },
      { id: "wins-5", xp: 70, text: "Win 5 total runs" },
      { id: "wins-15", xp: 110, text: "Win 15 total runs" },
      { id: "nodes-60", xp: 80, text: "Play 60 total nodes" }
    ];
    const PROFILE_LEVEL_REWARDS = [
      { level: 2, id: "enemy-pool-mirror", text: "Enemy pool unlock: Mirrorlag can appear in normal nodes.", type: "enemyPool" },
      { level: 3, id: "relic-pool-strategic", text: "Relic pool unlock: strategic relics added to draft pool.", type: "relicPool" },
      { level: 4, id: "event-chain-producer", text: "Event chain unlock: Producer's Gambit can appear.", type: "eventChain" },
      { level: 5, id: "cosmetic-banner-obsidian", text: "Cosmetic unlock: Obsidian banner title treatment.", type: "cosmetic" },
      { level: 6, id: "enemy-pool-boss-variant", text: "Enemy unlock option: Obsidian boss can appear via event chain.", type: "enemyVariant" }
    ];
    const ORIGINAL_SEED_ONE_SEQUENCE = "RPSSRPPSPRRSPSPRPPRP";
    const ENCOUNTER_TYPES = ["normal", "elite", "event", "shop", "campfire", "boss"];
    const CHALLENGE_MUTATOR_POOL = [
      { id: "tight-budget", name: "Tight Budget", text: "Start with $3 cash instead of $6." },
      { id: "iron-resolve", name: "Iron Resolve", text: "Start with +2 max resolve." },
      { id: "glass-jaw", name: "Glass Jaw", text: "Start with -2 resolve." },
      { id: "adaptive-onslaught", name: "Adaptive Onslaught", text: "Adaptive Rock is forced on for the full run." }
    ];
    const AI_PROFILES = {
      random: "random",
      antiRepeat: "anti-repeat",
      antiStreak: "anti-streak",
      delayedCounter: "delayed-counter",
      fakeOut: "fake-out"
    };
    const ENEMY_DEFINITIONS = {
      graniteRookie: {
        id: "granite-rookie",
        name: "Gio Granite",
        portrait: "ü™®",
        title: "Rookie",
        aiProfile: AI_PROFILES.random,
        passives: ["Unscripted swings"],
        phaseRules: []
      },
      tapeWatcher: {
        id: "tape-watcher",
        name: "Mina Tapewatch",
        portrait: "üìº",
        title: "Scout",
        aiProfile: AI_PROFILES.antiRepeat,
        passives: ["Punishes repeated hands"],
        phaseRules: []
      },
      streakWarden: {
        id: "streak-warden",
        name: "Vox Streakwarden",
        portrait: "üìà",
        title: "Analyst",
        aiProfile: AI_PROFILES.antiStreak,
        passives: ["Targets your streaks"],
        phaseRules: []
      },
      mirrorLag: {
        id: "mirror-lag",
        name: "Echo Mirrorlag",
        portrait: "ü™û",
        title: "Counterfeiter",
        aiProfile: AI_PROFILES.delayedCounter,
        passives: ["Counters with a one-round delay"],
        phaseRules: []
      },
      showboat: {
        id: "showboat",
        name: "Rico Showboat",
        portrait: "üé≠",
        title: "Bluffer",
        aiProfile: AI_PROFILES.fakeOut,
        passives: ["Baits counters with fake-outs"],
        phaseRules: []
      },
      rockBoss: {
        id: "the-rock",
        name: "Dwayne",
        portrait: "üóø",
        title: "The Rock",
        aiProfile: AI_PROFILES.antiRepeat,
        passives: ["Mood-based adaptive reads"],
        phaseRules: [
          { id: "press-conference", name: "Press Conference", trigger: { scoreLeadAtMost: -2 }, aiProfile: AI_PROFILES.fakeOut, passive: "Switches to fake-outs while behind" },
          { id: "headliner-lock", name: "Headliner Lock-in", trigger: { resolveAtMost: 5 }, aiProfile: AI_PROFILES.antiStreak, passive: "Targets your streaks when resolve is low" }
        ]
      },
      obsidianBoss: {
        id: "obsidian-headliner",
        name: "Obsidian Dwayne",
        portrait: "üåë",
        title: "Headliner",
        aiProfile: AI_PROFILES.delayedCounter,
        passives: ["Bonus pressure on player losses"],
        phaseRules: [
          { id: "echo-read", name: "Echo Read", trigger: { scoreLeadAtLeast: 2 }, aiProfile: AI_PROFILES.antiRepeat, passive: "Reads your repeats while ahead" },
          { id: "finisher-script", name: "Finisher Script", trigger: { resolveAtMost: 4 }, aiProfile: AI_PROFILES.fakeOut, passive: "Late-fight fake-out finisher" }
        ]
      }
    };
    const NODE_ENEMY_POOLS = {
      normal: ["graniteRookie", "tapeWatcher"],
      elite: ["streakWarden", "mirrorLag", "showboat"],
      boss: ["rockBoss"]
    };
    const RUN_BALANCE = {
      startingResolve: 12,
      startingCash: 5,
      rewardCashOnWin: { normal: 3, elite: 6, boss: 9 },
      loseResolvePenalty: { normal: 2, elite: 4, boss: 5 },
      campfireHeal: 4,
      shopPrices: { heal: 4, relic: 7, consumable: 5, cleanseCurse: 5 },
      shopHealAmount: 3
    };

    const runState = {
      mapNodes: [],
      selectedPath: [],
      availableNodeIds: [],
      activeNodeId: null,
      completedNodeIds: [],
      activeRelics: [],
      eventLog: [],
      pendingEvent: null,
      skipNextLossPenalty: false,
      revealNextNodeReward: false,
      revealedNodeRewards: {},
      activeCurses: [],
      curseState: {
        firstDrawLossUsedNodes: {},
        lockoutMove: null,
        lockoutRoundsRemaining: 0,
        normalRewardPenaltyUsedNodes: {}
      },
      rareChainStage: 0,
      unlockedBossVariant: null,
      resolve: RUN_BALANCE.startingResolve,
      maxResolve: RUN_BALANCE.startingResolve,
      cash: RUN_BALANCE.startingCash,
      consumableShieldCharges: 0,
      relicUpgradeLevel: 0,
      runFailed: false,
      nodeEnemyAssignments: {},
      activeEnemyId: null,
      currentEnemyPhase: null,
      currentEnemyProfile: null,
      phaseAnnouncement: ""
    };

    const curseCatalog = [
      { id: "first-draw-loss", name: "Rigged Opener", text: "First draw in each node is treated as a loss." },
      { id: "repeated-hand-lock", name: "Hand Lock", text: "Repeating your previous hand forces a lockout for your next round's move." },
      { id: "normal-reward-drain", name: "Thin Purse", text: "Normal node win cash rewards are reduced by $1." }
    ];

    const relicCatalog = [
      { id: "streak-crown", name: "Streak Crown", text: "+1 score on wins when current win streak is 2+.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.preWinStreak >= 2) { scoreContext.youDelta += 1; feedback.push("Streak Crown +1"); } } },
      { id: "drawbreaker", name: "Drawbreaker", text: "Once per run, convert a draw into a win.", oneUse: true, apply: ({ scoreContext, relicState, feedback }) => { if (!relicState.used && scoreContext.baseOutcome === "draw") { scoreContext.baseOutcome = "win"; scoreContext.outcome = "win"; feedback.push("Drawbreaker converted draw ‚Üí win"); relicState.used = true; } } },
      { id: "anti-read-shield", name: "Anti-Adaptive Shield", text: "If adaptive read was correct, cancel it to a draw.", oneUse: false, apply: ({ scoreContext, feedback }) => { if (scoreContext.lastDecisionAdaptive && scoreContext.adaptiveReadCorrect && scoreContext.baseOutcome === "lose") { scoreContext.outcome = "draw"; feedback.push("Anti-Adaptive Shield forced draw"); } } },
      { id: "switchblade-rhythm", name: "Switchblade Rhythm", text: "+1 score when you alternate hands from last round.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.alternatedHand) { scoreContext.youDelta += 1; feedback.push("Switchblade Rhythm +1"); } } },
      { id: "campfire-focus", name: "Campfire Focus", text: "+1 score on win after elite/boss fights.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.prevNodeWasHighTier) { scoreContext.youDelta += 1; feedback.push("Campfire Focus +1"); } } },
      { id: "momentum-punch", name: "Momentum Punch", text: "First win after a loss gives +1 score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.previousOutcome === "lose") { scoreContext.youDelta += 1; feedback.push("Momentum Punch +1"); } } },
      { id: "parry-gloves", name: "Parry Gloves", text: "On losses, gain +1 pity score once every 2 rounds.", apply: ({ scoreContext, relicState, feedback }) => { if (scoreContext.baseOutcome === "lose" && (scoreContext.round % 2 === 0 || relicState.lastRoundApplied === scoreContext.round - 1)) { scoreContext.youDelta += 1; feedback.push("Parry Gloves pity +1"); relicState.lastRoundApplied = scoreContext.round; } } },
      { id: "clean-finishers", name: "Clean Finishers", unlockId: "relic-pool-strategic", text: "+1 score on wins while The Rock is Calm.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.moodBefore === "Calm") { scoreContext.youDelta += 1; feedback.push("Clean Finishers +1"); } } },
      { id: "crowd-noise", name: "Crowd Noise", text: "If you and Rock repeat same moves as last round, gain +1 draw point.", apply: ({ scoreContext, feedback }) => { if (scoreContext.repeatedPairFromLastRound) { scoreContext.drawDelta += 1; feedback.push("Crowd Noise +1 draw"); } } },
      { id: "paper-trainer", name: "Paper Trainer", text: "Paper wins grant +1 extra score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.yourMove === "P") { scoreContext.youDelta += 1; feedback.push("Paper Trainer +1"); } } },
      { id: "scissor-kick", name: "Scissor Kick", text: "Scissors wins grant +1 extra score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.yourMove === "S") { scoreContext.youDelta += 1; feedback.push("Scissor Kick +1"); } } },
      { id: "rock-stance", name: "Rock Stance", text: "Rock wins grant +1 extra score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.yourMove === "R") { scoreContext.youDelta += 1; feedback.push("Rock Stance +1"); } } },
      { id: "equalizer", name: "Equalizer", unlockId: "relic-pool-strategic", text: "When trailing by 2+, wins grant +1 score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.preScoreDiff <= -2) { scoreContext.youDelta += 1; feedback.push("Equalizer +1"); } } },
      { id: "front-runner", name: "Front Runner", unlockId: "relic-pool-strategic", text: "When leading by 2+, wins grant +1 score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.preScoreDiff >= 2) { scoreContext.youDelta += 1; feedback.push("Front Runner +1"); } } },
      { id: "icewater", name: "Icewater", text: "First draw each encounter grants +1 draw.", apply: ({ scoreContext, relicState, feedback }) => { if (scoreContext.baseOutcome === "draw" && relicState.lastEncounter !== scoreContext.nodeIndex) { scoreContext.drawDelta += 1; relicState.lastEncounter = scoreContext.nodeIndex; feedback.push("Icewater +1 draw"); } } },
      { id: "boss-hunter", name: "Boss Hunter", text: "Boss node win grants +2 score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.nodeType === "boss") { scoreContext.youDelta += 2; feedback.push("Boss Hunter +2"); } } },
      { id: "elite-bounty", name: "Elite Bounty", text: "Elite node win grants +1 score.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.nodeType === "elite") { scoreContext.youDelta += 1; feedback.push("Elite Bounty +1"); } } },
      { id: "stonewall", name: "Stonewall", text: "On draw, The Rock loses 1 point if he leads.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "draw" && scoreContext.preScoreDiff < 0) { scoreContext.rockDelta -= 1; feedback.push("Stonewall -1 Rock"); } } },
      { id: "last-breath", name: "Last Breath", text: "If final node is a loss, turn it into draw once.", oneUse: true, apply: ({ scoreContext, relicState, feedback }) => { if (!relicState.used && scoreContext.isFinalNode && scoreContext.baseOutcome === "lose") { scoreContext.outcome = "draw"; relicState.used = true; feedback.push("Last Breath saved final node"); } } },
      { id: "pattern-seer", name: "Pattern Seer", unlockId: "relic-pool-strategic", text: "+1 score if your move beats your own previous move.", apply: ({ scoreContext, feedback }) => { if (scoreContext.baseOutcome === "win" && scoreContext.beatsOwnLastMove) { scoreContext.youDelta += 1; feedback.push("Pattern Seer +1"); } } }
    ];

    const eventCatalog = [
      {
        id: "promoter-backroom",
        title: "Backroom Promoter",
        text: "A suit offers you a scripted edge, but every deal has weight.",
        choices: [
          { id: "sign-ink", title: "Sign the ink", text: "Gain a random relic and a random persistent curse.", effect: "gainRelicAndCurse" },
          { id: "walk-away", title: "Walk away", text: "No change. Keep your hands clean.", effect: "noop" }
        ]
      },
      {
        id: "ringside-medic",
        title: "Ringside Medic",
        text: "The medic tapes your wrist and whispers a survival trick.",
        choices: [
          { id: "brace", title: "Take the brace", text: "Skip the next loss penalty.", effect: "skipNextLossPenalty" },
          { id: "peek", title: "Ask for route intel", text: "Reveal the next node reward preview.", effect: "revealNextNodeReward" },
          { id: "decline", title: "Decline help", text: "No immediate bonus.", effect: "noop" }
        ]
      },
      {
        id: "oracle-shard",
        title: "Oracle Shard",
        text: "A shard hums with replay-static from future finals.",
        choices: [
          { id: "attune", title: "Attune to it", text: "Begin a rare chain toward a hidden boss variant.", effect: "rareChainStart" },
          { id: "stow", title: "Pocket and move", text: "Gain +1 draw score instantly.", effect: "instantDraw" }
        ]
      },
      {
        id: "forge-echo",
        title: "Forge Echo",
        text: "The shard resonates with the arena bell. The chain can be completed here.",
        choices: [
          { id: "temper", title: "Temper the shard", text: "Unlock the Obsidian Headliner boss variant.", effect: "unlockBossVariant" },
          { id: "break", title: "Break it", text: "Gain skip-next-loss but end the chain.", effect: "skipNextLossPenaltyAndEndChain" }
        ]
      },
      {
        id: "producer-gambit",
        title: "Producer's Gambit",
        unlockId: "event-chain-producer",
        text: "A producer offers glitz. You can style the run without raw stat buffs.",
        choices: [
          { id: "spotlight", title: "Take spotlight", text: "Unlock cosmetic title for this profile.", effect: "unlockCosmeticSpotlight" },
          { id: "draft-reshuffle", title: "Reshuffle draft", text: "Reveal next node reward preview.", effect: "revealNextNodeReward" }
        ]
      }
    ];

    const achievementCatalog = [
      { id: "opening-pop", name: "Opening Pop", text: "You won round 1.", rank: "bronze", unlocked: s => s.historyLog[0]?.outcome === "win" },
      { id: "paperless-opener", name: "Paperless Opener", text: "Round 1, you opened with anything except Paper.", rank: "bronze", unlocked: s => s.openedNonPaper },
      { id: "triple-mixup", name: "Triple Mixup", text: "Your first 3 moves were all different.", rank: "silver", unlocked: s => s.firstThreeUnique },
      { id: "unshaken-opener", name: "Unshaken Opener", text: "No losses in the first 5 rounds.", rank: "bronze", unlocked: s => s.historyLog.length >= 5 && s.noLossesFirstFive },
      { id: "hot-streak", name: "Hot Streak", text: "You reached a win streak of 4+.", rank: "silver", unlocked: s => s.maxWinStreak >= 4 },
      { id: "cold-shower", name: "Cold Shower", text: "The Rock reached a win streak of 3+.", rank: "bronze", unlocked: s => s.maxRockStreak >= 3 },
      { id: "slippery-slope", name: "Slippery Slope", text: "Consolation badge, you hit a 5+ loss streak.", rank: "bronze", unlocked: s => s.maxLoseStreak >= 5 },
      { id: "draw-artist", name: "Draw Artist", text: "You reached 8+ draws in one run.", rank: "silver", unlocked: s => s.draws >= 8 },
      { id: "draw-buffet", name: "Draw Buffet", text: "You stacked 12+ draws. Nobody ate, everyone watched.", rank: "gold", unlocked: s => s.draws >= 12 },
      { id: "truce-train", name: "Truce Train", text: "You chained 4+ draws in a row.", rank: "silver", unlocked: s => s.maxDrawStreak >= 4 },
      { id: "paranoid-era", name: "Paranoid Era", text: "You kept The Rock in Paranoid state for a long stretch.", rank: "silver", unlocked: s => s.paranoidCount >= 5 },
      { id: "status-slayer", name: "Status Slayer", text: "You won 4+ rounds while he was Paranoid.", rank: "gold", unlocked: s => s.paranoidWins >= 4 },
      { id: "beat-the-rock-enjoyer", name: "Beat The Rock Enjoyer", text: "You beat The Rock in 10+ rounds.", rank: "silver", unlocked: s => s.beatRockHits >= 10 },
      { id: "boulder-puncher", name: "Boulder Puncher", text: "You beat The Rock in 14+ rounds.", rank: "gold", unlocked: s => s.beatRockHits >= 14 },
      { id: "mood-breaker", name: "Mood Breaker", text: "You forced Calm, Suspicious, and Paranoid in one run.", rank: "gold", unlocked: s => s.seenMoods.size === 3 },
      { id: "edge-of-your-seat", name: "Edge Of Your Seat", text: "You won a very close run.", rank: "bronze", unlocked: s => s.matchFinished && Math.abs(s.youScore - s.rockScore) === 1 && s.youScore > s.rockScore },
      { id: "seeded-legend", name: "Seeded Legend", text: "You chose the seed and still beat The Rock.", rank: "gold", unlocked: s => s.matchFinished && s.seedWasManual && s.youScore > s.rockScore },
      { id: "adaptive-bully", name: "Adaptive Bully", text: "You beat him even though his adaptive reads were strong.", rank: "gold", unlocked: s => s.matchFinished && s.adaptiveEverOnThisRun && s.adaptiveAttempts >= 5 && (s.adaptiveCorrectReads / s.adaptiveAttempts) >= 0.6 && s.youScore > s.rockScore },
      { id: "comeback-kid", name: "Comeback Kid", text: "You won after trailing by 3+ at some point.", rank: "gold", unlocked: s => s.matchFinished && s.maxRockLead >= 3 && s.youScore > s.rockScore },
      { id: "clean-finish", name: "Clean Finish", text: "You won the final 3 rounds and took the run.", rank: "gold", unlocked: s => s.matchFinished && s.youScore > s.rockScore && s.lastThreeAreWins },
      { id: "mirror-maestro", name: "Mirror Maestro", text: "Complex palindrome run, your 20 moves mirror perfectly.", rank: "platinum", unlocked: s => s.matchFinished && s.complexPalindromeMoves },
      { id: "rock-marathon", name: "Rock Marathon", text: "You threw Rock all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyRock },
      { id: "paper-marathon", name: "Paper Marathon", text: "You threw Paper all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyPaper },
      { id: "scissors-marathon", name: "Scissors Marathon", text: "You threw Scissors all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyScissors },
      { id: "balanced-arsenal", name: "Balanced Arsenal", text: "At least 5 of each hand across the run.", rank: "gold", unlocked: s => s.matchFinished && s.minMoveCount >= 5 },
      { id: "no-repeat-discipline", name: "No Repeat Discipline", text: "20 rounds without repeating your last hand.", rank: "gold", unlocked: s => s.matchFinished && s.noConsecutiveSameMove },
      { id: "theoretical-maximum", name: "Theoretical Maximum", text: "You beat The Rock in every single round.", rank: "platinum", unlocked: s => s.matchFinished && s.beatRockHits === s.historyLog.length },
      { id: "reverse-sweep", name: "Reverse Sweep", text: "You lost the first 3 rounds but still won the run.", rank: "platinum", unlocked: s => s.matchFinished && s.youScore > s.rockScore && s.lostFirstThree },
      { id: "archetype-hunter", name: "Archetype Hunter", text: "Beat four distinct opponent archetypes in one run.", rank: "gold", unlocked: s => s.defeatedProfiles.size >= 4 },
      { id: "boss-phase-breaker", name: "Boss Phase Breaker", text: "Defeat a boss after a phase transition activates.", rank: "gold", unlocked: s => s.bossPhaseWin },
      { id: "obsidian-topple", name: "Obsidian Topple", text: "Defeat the Obsidian Headliner boss variant.", rank: "platinum", unlocked: s => s.obsidianBossWin },
      { id: "tough-crowd", name: "Tough Crowd", text: "Consolation badge, you lost by 8+ but still finished the run.", rank: "bronze", unlocked: s => s.matchFinished && s.lossMargin >= 8 },
      { id: "main-event-survivor", name: "Main Event Survivor", text: "Consolation badge, you lost but stayed for all 20 rounds.", rank: "bronze", unlocked: s => s.matchFinished && s.rockScore > s.youScore },
      { id: "pacifist-match", name: "Pacifist Match", text: "You somehow avoided winning or losing any round.", rank: "platinum", unlocked: s => s.matchFinished && s.youScore === 0 && s.rockScore === 0 && s.draws === 20 }
    ];
    function normalizeSeed(value) {
      const trimmed = String(value ?? "").trim();
      if (!DIGITS_ONLY_REGEX.test(trimmed)) return { valid: false, seed: null, clamped: false };

      const parsed = BigInt(trimmed);
      if (parsed < BigInt(U32_MIN)) return { valid: false, seed: null, clamped: false };

      const normalized = parsed > U32_MAX_BIGINT ? U32_MAX_BIGINT : parsed;
      return { valid: true, seed: Number(normalized), clamped: parsed !== normalized };
    }

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function generateSeededScriptSequence(seed) {
      if ((seed >>> 0) === DEFAULT_SEED) {
        const defaultSequence = ORIGINAL_SEED_ONE_SEQUENCE.split("");
        defaultSequence[0] = "R";
        return defaultSequence;
      }

      const normalizedSeed = seed >>> 0;
      const sequence = [];
      let value = normalizedSeed % TERNARY_SPACE;
      const overflow = Math.floor(normalizedSeed / TERNARY_SPACE);

      for (let i = 0; i < 20; i += 1) {
        let digit = value % 3;
        value = Math.floor(value / 3);
        if (overflow > 0) {
          const mix = (Math.imul(overflow, 0x9E3779B1) + Math.imul(i + 1, 0x85EBCA6B)) >>> 0;
          digit = (digit + (mix % 3)) % 3;
        }
        const move = ROCK_MOVES[digit];
        sequence.push(move);
      }

      sequence[0] = "R";
      return sequence;
    }

    function sequenceToReplaySeed(sequence) {
      if (!Array.isArray(sequence) || sequence.length !== 20) return null;
      const digitMap = { R: 0, P: 1, S: 2 };
      let value = 0;
      let factor = 1;

      for (let i = 0; i < sequence.length; i += 1) {
        const digit = digitMap[sequence[i]];
        if (digit === undefined) return null;
        value += digit * factor;
        factor *= 3;
      }

      const candidate = value >>> 0;
      const candidateSequence = generateSeededScriptSequence(candidate).join("");
      const target = sequence.join("");
      if (candidate !== DEFAULT_SEED && candidateSequence === target) return candidate;

      if (target === ORIGINAL_SEED_ONE_SEQUENCE) return DEFAULT_SEED;
      return null;
    }

    let rngGame = null;
    let rngFlavor = null;
    let runSeed = 0;
    let seedWasManual = false;
    let scriptedSequenceOverride = null;
    let seededScriptSequence = [];
    let challengeMode = "casual";
    let challengeRunHash = "";
    let activeWeeklyMutatorSet = [];
    let challengeContext = {};
    let profileState = null;
    let latestProfileUnlocks = [];

    let currentRound = 0;
    let youScore = 0;
    let rockScore = 0;
    let draws = 0;
    let beatRockHits = 0;
    let beatRockAbbrevs = [];
    let lastYourMove = null;

    let rockMood = "Calm";
    let rockLossStreak = 0;

    let adaptiveAttempts = 0;
    let adaptiveCorrectReads = 0;
    let adaptiveEverOnThisRun = false;
    let lastDecisionAdaptive = false;

    let audioCtx = null;
    let sfxEnabled = true;
    let ambientVolume = 0.35;
    let confirmVolume = 0.55;
    let uiVolume = 0.45;
    let masterGainNode = null;
    let ambientGainNode = null;
    let confirmGainNode = null;
    let uiGainNode = null;
    let ambientOscillators = [];

    let historyLog = [];
    let roundBoardCells = [];
    let activeRoundBoardIndex = null;
    let announcedAchievements = new Set();
    let achievementUnlockCounts = {};
    let sceneState = "lobby";
    let tutorialActive = false;
    let tutorialStepIndex = 0;
    let tutorialCompleted = false;
    let tutorialCurrentTarget = null;
    let roundResultTimer = null;
    let roundPhase = "idle";
    let roundAnimationToken = 0;
    let cinematicCardTimer = null;
    const announcedNodeCards = new Set();

    const ROUND_PHASE_DELAYS = {
      lockIn: 280,
      anticipation: 220,
      revealRock: 260,
      revealYou: 240,
      resolved: 380
    };
    const reducedMotionQuery = window.matchMedia ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
    const tutorialSteps = [
      {
        id: "moveButtons",
        title: "Step 1 ¬∑ Throw your first hand",
        text: "Start here. Throw Rock, Paper, or Scissors to open your challenge against The Rock.",
        anchor: () => moveButtonsAnchorEl
      },
      {
        id: "moodDisplay",
        title: "Step 2 ¬∑ Read The Rock's mood",
        text: "Watch his state here. Calm, Suspicious, and Paranoid each change his chance to read your next throw.",
        anchor: () => moodDisplayEl
      },
      {
        id: "adaptiveToggle",
        title: "Step 3 ¬∑ Toggle Adaptive Rock",
        text: "Flip Adaptive Rock mode once so you know where to enable his trend reads.",
        anchor: () => adaptiveToggle
      },
      {
        id: "roundBoard",
        title: "Step 4 ¬∑ Inspect the board",
        text: "Hover or focus a round tile to preview exact hands, outcomes, and pathing.",
        anchor: () => roundBoardPreviewEl
      },
      {
        id: "seedShare",
        title: "Step 5 ¬∑ Share and rematch",
        text: "Use Copy Challenge Link or set a seed to share exact showdowns. Walkthrough ends after this step.",
        anchor: () => seedShareAnchorEl
      }
    ];


    function getUtcDateKey(date = new Date()) {
      const y = date.getUTCFullYear();
      const m = String(date.getUTCMonth() + 1).padStart(2, "0");
      const d = String(date.getUTCDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function getISOWeekInfoUTC(date = new Date()) {
      const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
      const day = utcDate.getUTCDay() || 7;
      utcDate.setUTCDate(utcDate.getUTCDate() + 4 - day);
      const yearStart = new Date(Date.UTC(utcDate.getUTCFullYear(), 0, 1));
      const week = Math.ceil((((utcDate - yearStart) / 86400000) + 1) / 7);
      return { isoYear: utcDate.getUTCFullYear(), isoWeek: week };
    }

    function hashStringFNV1a(str) {
      let hash = 0x811C9DC5;
      for (let i = 0; i < str.length; i += 1) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, 0x01000193) >>> 0;
      }
      return hash >>> 0;
    }

    function deriveDailySeed(date = new Date()) {
      return hashStringFNV1a(`daily:${getUtcDateKey(date)}`) >>> 0;
    }

    function deriveWeeklyMutatorSet(date = new Date()) {
      const info = getISOWeekInfoUTC(date);
      const root = hashStringFNV1a(`weekly:${info.isoYear}-W${String(info.isoWeek).padStart(2, "0")}`);
      const count = Math.min(2, CHALLENGE_MUTATOR_POOL.length);
      const picks = [];
      const used = new Set();
      let cursor = root;
      while (picks.length < count) {
        const idx = cursor % CHALLENGE_MUTATOR_POOL.length;
        if (!used.has(idx)) {
          picks.push(CHALLENGE_MUTATOR_POOL[idx]);
          used.add(idx);
        }
        cursor = Math.imul((cursor ^ 0x9E3779B9) >>> 0, 0x85EBCA6B) >>> 0;
      }
      return { info, mutators: picks };
    }

    function getActiveModeStatsKey() {
      return `${CHALLENGE_STATS_KEY_PREFIX}.${challengeMode}`;
    }

    function loadModeStats(mode) {
      try {
        const raw = localStorage.getItem(`${CHALLENGE_STATS_KEY_PREFIX}.${mode}`);
        const parsed = raw ? JSON.parse(raw) : null;
        if (!parsed || typeof parsed !== "object") return { runs: 0, wins: 0, losses: 0, draws: 0, lastHash: "" };
        return {
          runs: Number.isInteger(parsed.runs) ? parsed.runs : 0,
          wins: Number.isInteger(parsed.wins) ? parsed.wins : 0,
          losses: Number.isInteger(parsed.losses) ? parsed.losses : 0,
          draws: Number.isInteger(parsed.draws) ? parsed.draws : 0,
          lastHash: typeof parsed.lastHash === "string" ? parsed.lastHash : ""
        };
      } catch (err) {
        return { runs: 0, wins: 0, losses: 0, draws: 0, lastHash: "" };
      }
    }

    function saveRunToModeStats() {
      const key = getActiveModeStatsKey();
      const stats = loadModeStats(challengeMode);
      stats.runs += 1;
      if (youScore > rockScore) stats.wins += 1;
      else if (rockScore > youScore) stats.losses += 1;
      else stats.draws += 1;
      stats.lastHash = challengeRunHash;
      try { localStorage.setItem(key, JSON.stringify(stats)); } catch (err) {}
    }

    function applyChallengeModeLocks() {
      const locked = challengeMode !== "casual";
      seedInputEl.disabled = locked;
      randomSeedBtn.disabled = locked;
      if (locked) {
        adaptiveToggle.disabled = true;
      } else if (!scriptedSequenceOverride) {
        adaptiveToggle.disabled = false;
      }
    }

    function renderChallengeModeButtons() {
      casualModeBtn.classList.toggle("active", challengeMode === "casual");
      dailyModeBtn.classList.toggle("active", challengeMode === "daily");
      weeklyModeBtn.classList.toggle("active", challengeMode === "weekly");
    }

    function getChallengeRulesText() {
      if (challengeMode === "daily") {
        return `Daily run locked to UTC date ${challengeContext.utcDateKey || getUtcDateKey()}. Seed ${runSeed}. Manual seed edits and adaptive toggle are locked.`;
      }
      if (challengeMode === "weekly") {
        const label = challengeContext.weekLabel || "current ISO week";
        const mutators = activeWeeklyMutatorSet.length ? activeWeeklyMutatorSet.map(m => `${m.name}: ${m.text}`).join(" ¬∑ ") : "No mutators.";
        return `Weekly run locked to ${label}. Seed ${runSeed}. ${mutators} Manual seed edits and adaptive toggle are locked.`;
      }
      return "Casual mode: seed and adaptive settings are fully editable.";
    }

    function updateChallengeRulesUI() {
      renderChallengeModeButtons();
      applyChallengeModeLocks();
      challengeRulesEl.textContent = getChallengeRulesText();
    }

    function applyWeeklyMutators() {
      activeWeeklyMutatorSet.forEach(mutator => {
        if (mutator.id === "tight-budget") runState.cash = Math.min(runState.cash, 3);
        else if (mutator.id === "iron-resolve") {
          runState.maxResolve += 2;
          runState.resolve += 2;
        } else if (mutator.id === "glass-jaw") {
          runState.maxResolve = Math.max(4, runState.maxResolve - 2);
          runState.resolve = Math.min(runState.resolve, runState.maxResolve);
        } else if (mutator.id === "adaptive-onslaught") {
          adaptiveToggle.checked = true;
        }
      });
    }

    function computeChallengeRunHash() {
      const outcomeTrace = historyLog.map(entry => `${entry.nodeId}:${entry.outcome[0]}:${entry.rockMove}${entry.yourMove}`).join("|");
      const relicTrace = runState.activeRelics.map(relic => relic.id).sort().join(",") || "none";
      const pathTrace = runState.selectedPath.join("-") || "none";
      const payload = [
        `mode=${challengeMode}`,
        `seed=${runSeed}`,
        `score=${youScore}-${rockScore}-${draws}`,
        `path=${pathTrace}`,
        `relics=${relicTrace}`,
        `outcomes=${outcomeTrace}`
      ].join(";");
      return hashStringFNV1a(payload).toString(36).toUpperCase().padStart(7, "0");
    }

    function buildChallengeResultText() {
      const modeLabel = challengeMode.charAt(0).toUpperCase() + challengeMode.slice(1);
      const weeklyLabel = challengeMode === "weekly" ? ` | ${challengeContext.weekLabel || "weekly"}` : "";
      const dailyLabel = challengeMode === "daily" ? ` | ${challengeContext.utcDateKey || getUtcDateKey()}` : "";
      const relics = runState.activeRelics.map(relic => relic.id).join(",") || "none";
      const path = runState.selectedPath.join("-") || "none";
      return `[BeatTheRock ${modeLabel}${dailyLabel}${weeklyLabel}] Seed ${runSeed} | Score You ${youScore} Rock ${rockScore} Draw ${draws} | Path ${path} | Relics ${relics} | Hash ${challengeRunHash}`;
    }

    async function copyChallengeResult() {
      const resultText = buildChallengeResultText();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(resultText);
          showCopyStatus("Challenge result copied to clipboard.", false);
          return;
        }
      } catch (err) {}
      const copied = fallbackCopyText(resultText);
      if (copied) showCopyStatus("Challenge result copied to clipboard.", false);
      else showCopyStatus("Could not copy challenge result. Please copy manually.", true);
    }


    function nodeTypeLabel(type) {
      return type.charAt(0).toUpperCase() + type.slice(1);
    }

    function generateRunMap(seed) {
      const rng = mulberry32((seed ^ 0xA5A5A5A5) >>> 0);
      const totalNodes = 8 + Math.floor(rng() * 5);
      const nodes = [];
      for (let i = 0; i < totalNodes; i += 1) {
        let type = "normal";
        if (i === totalNodes - 1) type = "boss";
        else if (i === 0) type = "normal";
        else if (i === totalNodes - 2) type = "elite";
        else {
          const roll = rng();
          if (roll < 0.16) type = ENCOUNTER_TYPES[2];
          else if (roll < 0.29) type = ENCOUNTER_TYPES[3];
          else if (roll < 0.42) type = ENCOUNTER_TYPES[4];
          else if (roll < 0.58) type = ENCOUNTER_TYPES[1];
          else type = ENCOUNTER_TYPES[0];
        }
        nodes.push({ id: i, act: 1, index: i + 1, type, next: [] });
      }
      for (let i = 0; i < totalNodes - 1; i += 1) {
        const node = nodes[i];
        const remain = totalNodes - i - 1;
        const options = remain <= 1 ? 1 : (rng() < 0.5 ? 1 : 2);
        const set = new Set([i + 1]);
        if (options === 2) set.add(Math.min(totalNodes - 1, i + 2));
        node.next = Array.from(set).sort((a, b) => a - b);
      }
      return nodes;
    }

    function assignEnemiesToNodes(nodes, selectedSeed) {
      const assignments = {};
      nodes.forEach(node => {
        if (!["normal", "elite", "boss"].includes(node.type)) return;
        if (node.type === "boss") {
          assignments[node.id] = runState.unlockedBossVariant === "obsidian-headliner" ? ENEMY_DEFINITIONS.obsidianBoss.id : ENEMY_DEFINITIONS.rockBoss.id;
          return;
        }
        const pool = getEnemyPoolForNodeType(node.type);
        const pickKey = pickDeterministic(pool, "enemy-node", selectedSeed, node.id, node.index);
        const enemy = ENEMY_DEFINITIONS[pickKey] || ENEMY_DEFINITIONS.graniteRookie;
        assignments[node.id] = enemy.id;
      });
      return assignments;
    }

    function getEnemyById(enemyId) {
      return Object.values(ENEMY_DEFINITIONS).find(enemy => enemy.id === enemyId) || ENEMY_DEFINITIONS.graniteRookie;
    }

    function getActiveEnemy() {
      return getEnemyById(runState.activeEnemyId);
    }

    function evaluateEnemyPhase(enemy) {
      if (!enemy || !Array.isArray(enemy.phaseRules)) return null;
      const scoreDiff = youScore - rockScore;
      for (const phaseRule of enemy.phaseRules) {
        const trigger = phaseRule.trigger || {};
        const leadAtMostOk = trigger.scoreLeadAtMost === undefined || scoreDiff <= trigger.scoreLeadAtMost;
        const leadAtLeastOk = trigger.scoreLeadAtLeast === undefined || scoreDiff >= trigger.scoreLeadAtLeast;
        const resolveOk = trigger.resolveAtMost === undefined || runState.resolve <= trigger.resolveAtMost;
        if (leadAtMostOk && leadAtLeastOk && resolveOk) return phaseRule;
      }
      return null;
    }

    function getEnemyProfileForRound(enemy) {
      if (!enemy) return AI_PROFILES.random;
      const phase = evaluateEnemyPhase(enemy);
      runState.currentEnemyPhase = phase ? phase.id : null;
      if (phase && runState.phaseAnnouncement !== phase.id) {
        runState.phaseAnnouncement = phase.id;
        commentaryEl.textContent = `${enemy.portrait} ${enemy.name} enters phase: ${phase.name} ‚Äî ${phase.passive}.`;
      }
      return phase?.aiProfile || enemy.aiProfile || AI_PROFILES.random;
    }

    function renderEnemyArenaIntel() {
      const enemy = getActiveEnemy();
      if (!enemyArenaNameEl || !enemyArenaTitleEl || !enemyArenaGimmickEl) return;
      enemyArenaNameEl.textContent = `${enemy.portrait} ${enemy.name}`;
      enemyArenaTitleEl.textContent = enemy.title;
      const phase = evaluateEnemyPhase(enemy);
      const phaseText = phase ? `Phase: ${phase.name}` : "Base phase";
      const passiveText = phase?.passive || enemy.passives.join(" ¬∑ ");
      enemyArenaGimmickEl.textContent = `Arena feed: ${phaseText} ¬∑ ${passiveText}`;
    }

    function getTotalNodes() { return runState.mapNodes.length || 1; }
    function getActiveNode() { return runState.mapNodes[runState.activeNodeId] || null; }
    function isRunComplete() { return runState.runFailed || currentRound >= getTotalNodes(); }

    function clampResolve(value) {
      return Math.max(0, Math.min(runState.maxResolve, value));
    }

    function applyShopChoice(choice, node) {
      if (choice === "heal") {
        if (runState.cash < RUN_BALANCE.shopPrices.heal) return "Not enough cash for patches.";
        runState.cash -= RUN_BALANCE.shopPrices.heal;
        runState.resolve = clampResolve(runState.resolve + RUN_BALANCE.shopHealAmount);
        return `Bought ringside patches: +${RUN_BALANCE.shopHealAmount} resolve.`;
      }
      if (choice === "relic") {
        if (runState.cash < RUN_BALANCE.shopPrices.relic) return "Not enough cash for a relic crate.";
        const relic = rollDeterministicRelic(node.id, "shop-relic");
        if (!relic) return "No relics left in stock.";
        runState.cash -= RUN_BALANCE.shopPrices.relic;
        runState.activeRelics.push({ id: relic.id, used: false });
        return `Bought relic ${relic.name}.`;
      }
      if (choice === "consumable") {
        if (runState.cash < RUN_BALANCE.shopPrices.consumable) return "Not enough cash for a tonic.";
        runState.cash -= RUN_BALANCE.shopPrices.consumable;
        runState.consumableShieldCharges += 1;
        return "Bought Smoke Tonic: next resolve loss is prevented once.";
      }
      if (choice === "cleanse") {
        if (!runState.activeCurses.length) return "No curses to remove.";
        if (runState.cash < RUN_BALANCE.shopPrices.cleanseCurse) return "Not enough cash for curse removal.";
        runState.cash -= RUN_BALANCE.shopPrices.cleanseCurse;
        const removedCurse = removeRandomCurse(node ? node.id : -1);
        return removedCurse ? `Paid the shrine keeper: removed curse ${removedCurse.name}.` : "No curses to remove.";
      }
      return "Saved your cash for later.";
    }

    function getSpecialNodeChoices(node) {
      if (!node) return null;
      if (node.type === "shop") {
        return {
          title: "Backstage Shop",
          text: "Spend cash before the next throw. Small buys, big momentum.",
          choices: [
            { id: "heal", title: `Buy Patches ($${RUN_BALANCE.shopPrices.heal})`, text: `Heal ${RUN_BALANCE.shopHealAmount} resolve.` },
            { id: "relic", title: `Buy Relic Crate ($${RUN_BALANCE.shopPrices.relic})`, text: "Add one random relic you do not own." },
            { id: "consumable", title: `Buy Smoke Tonic ($${RUN_BALANCE.shopPrices.consumable})`, text: "One-time consumable: negates the next resolve loss." },
            { id: "cleanse", title: `Cleanse Curse ($${RUN_BALANCE.shopPrices.cleanseCurse})`, text: "Remove one random active curse." },
            { id: "leave", title: "Leave", text: "Save your cash for a later node." }
          ],
          resolveChoice: (choice) => applyShopChoice(choice.id, node)
        };
      }
      if (node.type === "campfire") {
        return {
          title: "Campfire",
          text: "Take a breather before the next clash.",
          choices: [
            { id: "heal", title: "Recover", text: `Heal ${RUN_BALANCE.campfireHeal} resolve.` },
            { id: "upgrade", title: "Upgrade Relic Aura", text: "Relics gain +1 bonus score when they trigger on a win." },
            { id: "leave", title: "Leave", text: "Keep your current edge." }
          ],
          resolveChoice: (choice) => {
            if (choice.id === "heal") {
              runState.resolve = clampResolve(runState.resolve + RUN_BALANCE.campfireHeal);
              return `Recovered ${RUN_BALANCE.campfireHeal} resolve.`;
            }
            if (choice.id === "upgrade") {
              runState.relicUpgradeLevel += 1;
              return `Relic aura upgraded to +${runState.relicUpgradeLevel}.`;
            }
            return "You kept watch and moved on.";
          }
        };
      }
      return null;
    }

    async function selectNextNode(nodeId) {
      if (!relicChoicePanelEl.classList.contains("is-hidden")) return;
      if (runState.pendingEvent) return;
      if (!runState.availableNodeIds.includes(nodeId)) return;
      runState.activeNodeId = nodeId;
      runState.selectedPath.push(nodeId);
      runState.availableNodeIds = [];
      runState.activeEnemyId = runState.nodeEnemyAssignments[nodeId] || ENEMY_DEFINITIONS.graniteRookie.id;
      noteDiscovery("enemy", runState.activeEnemyId);
      runState.phaseAnnouncement = "";
      playUiPip("confirm");
      const node = getActiveNode();
      renderEnemyArenaIntel();
      if (node && node.type === "event") {
        const event = getEventForNode(node);
        if (event) {
          runState.pendingEvent = { node, event };
          renderEventPanel();
          renderMapPanel();
          setScene("map");
          setButtonsEnabled(false);
          return;
        }
      }
      const specialNode = getSpecialNodeChoices(node);
      if (specialNode) {
        runState.pendingEvent = { node, event: specialNode };
        renderEventPanel();
        renderMapPanel();
        setScene("map");
        setButtonsEnabled(false);
        return;
      }
      renderEventPanel();
      renderMapPanel();
      const introKey = `${node.id}-${node.type}`;
      if (!announcedNodeCards.has(introKey) && (node.type === "elite" || node.type === "boss")) {
        announcedNodeCards.add(introKey);
        const enemy = getActiveEnemy();
        await showCinematicCard({
          tier: node.type,
          tag: node.type === "boss" ? "Boss encounter" : "Elite encounter",
          title: `${enemy.portrait} ${enemy.name}`,
          body: node.type === "boss" ? "Main event. KO this final wall to complete the run." : "High-pressure bout. Expect tighter reads and bigger swings."
        });
      }
      setScene("inRound");
      setButtonsEnabled(true);
      moveButtons[0].focus();
    }

    async function maybeAutoEnterSoloNode() {
      if (!relicChoicePanelEl.classList.contains("is-hidden")) return false;
      if (runState.pendingEvent) return false;
      if (runState.activeNodeId !== null) return false;
      if (!Array.isArray(runState.availableNodeIds) || runState.availableNodeIds.length !== 1) return false;
      await selectNextNode(runState.availableNodeIds[0]);
      return runState.activeNodeId !== null;
    }

    function renderMapPanel() {
      const total = getTotalNodes();
      const activeNode = getActiveNode();
      const completedPath = runState.completedNodeIds.map(id => `N${(id || 0) + 1}`).join(" ‚Üí ");
      const activeEnemy = activeNode ? getEnemyById(runState.nodeEnemyAssignments[activeNode.id]) : null;
      mapCurrentLabelEl.textContent = activeNode ? `Current node: Act ${activeNode.act} Node ${activeNode.index} ¬∑ ${nodeTypeLabel(activeNode.type)} ¬∑ ${activeEnemy ? activeEnemy.name : "Unknown"}` : "Current node: choose next";
      mapProgressLabelEl.textContent = `Path ${currentRound}/${total}`;
      mapPathEl.textContent = `Completed path: ${completedPath || "none yet"}`;
      mapChoicesEl.innerHTML = "";
      const upcoming = runState.availableNodeIds.length > 0 ? runState.availableNodeIds : (activeNode?.next || []);
      if (upcoming.length === 0) {
        const span = document.createElement("span");
        span.className = "settings-hint";
        span.textContent = isRunComplete() ? "Run complete." : "No branches available.";
        mapChoicesEl.appendChild(span);
        return;
      }
      upcoming.forEach((id) => {
        const node = runState.mapNodes[id];
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "map-node-btn";
        const preview = runState.revealedNodeRewards[id];
        const enemy = getEnemyById(runState.nodeEnemyAssignments[id]);
        btn.textContent = `Act ${node.act} Node ${node.index} ¬∑ ${nodeTypeLabel(node.type)} ¬∑ ${enemy.name}${preview ? ` ¬∑ ${preview}` : ""}`;
        if (runState.completedNodeIds.includes(id)) btn.classList.add("completed");
        if (runState.activeNodeId === id) btn.classList.add("current");
        const selectable = runState.availableNodeIds.includes(id);
        btn.disabled = !selectable;
        if (selectable) btn.addEventListener("click", () => selectNextNode(id));
        mapChoicesEl.appendChild(btn);
      });
    }

    function renderRelicStrip() {
      relicStripListEl.innerHTML = "";
      if (!runState.activeRelics.length) {
        const empty = document.createElement("span");
        empty.className = "relic-empty";
        empty.textContent = "No relics yet. Win encounters to draft perks.";
        relicStripListEl.appendChild(empty);
        return;
      }
      runState.activeRelics.forEach(relicState => {
        const relic = relicCatalog.find(entry => entry.id === relicState.id);
        if (!relic) return;
        const pill = document.createElement("span");
        const usedTag = relicState.used ? " (used)" : "";
        pill.className = "relic-pill";
        pill.textContent = `${relic.name}${usedTag}`;
        pill.title = relic.text;
        relicStripListEl.appendChild(pill);
      });
    }

    function rollRelicChoices() {
      const ownedIds = new Set(runState.activeRelics.map(relic => relic.id));
      const pool = relicCatalog.filter(relic => !ownedIds.has(relic.id) && canUseRelic(relic));
      if (pool.length <= 3) return pool.slice();
      const picks = [];
      while (picks.length < 3 && pool.length > 0) {
        const roll = Math.floor((rngGame ? rngGame() : Math.random()) * pool.length);
        picks.push(pool.splice(roll, 1)[0]);
      }
      return picks;
    }

    function maybeShowRelicChoice(nodeType, didWin) {
      if (!didWin) return false;
      const rewardsByType = { normal: 0.4, elite: 1, boss: 1 };
      const chance = rewardsByType[nodeType] || 0;
      if (chance <= 0) return false;
      const roll = rngGame ? rngGame() : Math.random();
      if (roll > chance) return false;
      const relicChoices = rollRelicChoices();
      if (!relicChoices.length) return false;

      relicChoiceGridEl.innerHTML = "";
      relicChoices.forEach(relic => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "relic-choice-btn";
        btn.innerHTML = `<strong>${relic.name}</strong>${relic.text}`;
        btn.addEventListener("click", () => {
          runState.activeRelics.push({ id: relic.id, used: false });
          noteDiscovery("relic", relic.id);
          relicChoicePanelEl.classList.add("is-hidden");
          renderRelicStrip();
          commentaryEl.textContent = `${commentaryEl.textContent} Relic drafted: ${relic.name}.`;
          if (!isRunComplete() && runState.availableNodeIds.length > 0) {
            setScene("map");
            maybeAutoEnterSoloNode();
          }
        });
        relicChoiceGridEl.appendChild(btn);
      });
      relicChoicePanelEl.classList.remove("is-hidden");
      setScene("map");
      return true;
    }

    function applyRelicEffects(scoreContext) {
      const feedback = [];
      runState.activeRelics.forEach(relicState => {
        const relicDef = relicCatalog.find(entry => entry.id === relicState.id);
        if (!relicDef || typeof relicDef.apply !== "function") return;
        if (relicDef.oneUse && relicState.used) return;
        relicDef.apply({ scoreContext, relicState, feedback });
      });
      return feedback;
    }

    function hasCurse(curseId) {
      return runState.activeCurses.includes(curseId);
    }

    function gainRandomCurse(nodeId, contextLabel) {
      const pool = curseCatalog.filter(curse => !runState.activeCurses.includes(curse.id));
      const curse = pickDeterministic(pool, "curse-gain", nodeId, contextLabel, runState.selectedPath.join("-"));
      if (!curse) return null;
      runState.activeCurses.push(curse.id);
      return curse;
    }

    function removeRandomCurse(nodeId) {
      const available = runState.activeCurses.slice();
      const curseId = pickDeterministic(available, "curse-remove", nodeId, runState.cash, currentRound);
      if (!curseId) return null;
      runState.activeCurses = runState.activeCurses.filter(id => id !== curseId);
      return curseCatalog.find(curse => curse.id === curseId) || { id: curseId, name: curseId, text: "" };
    }

    function renderCurseHud() {
      if (!curseHudEl || !curseHudListEl) return;
      curseHudListEl.innerHTML = "";
      if (!runState.activeCurses.length) {
        const empty = document.createElement("span");
        empty.className = "curse-empty";
        empty.textContent = "No curses active.";
        curseHudListEl.appendChild(empty);
        return;
      }
      runState.activeCurses.forEach(curseId => {
        const curse = curseCatalog.find(entry => entry.id === curseId);
        if (!curse) return;
        const pill = document.createElement("span");
        pill.className = "curse-pill";
        pill.textContent = curse.name;
        pill.title = curse.text;
        curseHudListEl.appendChild(pill);
      });
    }

    function mixSeed(...parts) {
      let value = runSeed >>> 0;
      parts.forEach((part, index) => {
        const n = typeof part === "number" ? part : String(part).split("").reduce((acc, ch) => (Math.imul(acc, 33) + ch.charCodeAt(0)) >>> 0, 5381);
        value = (value ^ (Math.imul((n >>> 0) + index + 1, 0x9E3779B1) >>> 0)) >>> 0;
        value = Math.imul(value ^ (value >>> 16), 0x85EBCA6B) >>> 0;
      });
      return value >>> 0;
    }

    function pickDeterministic(items, ...parts) {
      if (!items.length) return null;
      const idx = mixSeed(...parts) % items.length;
      return items[idx];
    }

    function rollDeterministicRelic(...parts) {
      const ownedIds = new Set(runState.activeRelics.map(relic => relic.id));
      const pool = relicCatalog.filter(relic => !ownedIds.has(relic.id) && canUseRelic(relic));
      return pickDeterministic(pool, "event-relic", ...parts);
    }

    function getNodeRewardPreview(nodeId) {
      const node = runState.mapNodes[nodeId];
      if (!node) return "Unknown node";
      if (node.type === "boss") return "Boss reward: guaranteed relic draft";
      if (node.type === "elite") return "Elite reward: guaranteed relic draft on win";
      if (node.type === "event") return "Event reward: narrative choice modifier";
      return "Normal reward: 40% relic draft on win";
    }

    function maybeRevealUpcomingRewards() {
      if (!runState.revealNextNodeReward || !runState.availableNodeIds.length) return;
      runState.availableNodeIds.forEach(id => {
        runState.revealedNodeRewards[id] = getNodeRewardPreview(id);
      });
      runState.revealNextNodeReward = false;
    }

    function getEventForNode(node) {
      if (!node || node.type !== "event") return null;
      const chainReady = runState.rareChainStage === 1;
      if (chainReady && (mixSeed("forge-gate", node.id, runState.selectedPath.join("-")) % 4 === 0)) {
        return eventCatalog.find(event => event.id === "forge-echo") || null;
      }
      const pool = eventCatalog.filter(event => event.id !== "forge-echo" && canUseEvent(event));
      return pickDeterministic(pool, "node-event", node.id, runState.selectedPath.join("-"));
    }

    function renderEventPanel() {
      const pending = runState.pendingEvent;
      if (!pending) {
        eventPanelEl.classList.add("is-hidden");
        return;
      }
      eventPanelEl.classList.remove("is-hidden");
      eventTitleEl.textContent = pending.event.title;
      eventBodyEl.textContent = pending.event.text;
      eventChoiceGridEl.innerHTML = "";
      pending.event.choices.forEach(choice => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "event-choice-btn";
        btn.innerHTML = `<strong>${choice.title}</strong>${choice.text}`;
        btn.addEventListener("click", () => resolveEventChoice(choice));
        eventChoiceGridEl.appendChild(btn);
      });
    }

    function logEventDecision(event, choice, effectsText, node) {
      noteDiscovery("event", event.id);
      const detail = `${event.title} ¬∑ ${choice.title} (${effectsText})`;
      runState.eventLog.push({ nodeId: node.id, nodeIndex: node.index, detail });
    }

    function resolveEventChoice(choice) {
      const pending = runState.pendingEvent;
      if (!pending) return;
      const { event, node } = pending;
      if (typeof event.resolveChoice === "function") {
        const effectsText = event.resolveChoice(choice);
        logEventDecision(event, choice, effectsText, node);
        commentaryEl.textContent = `${event.title}: ${choice.title}. ${effectsText}.`;
        runState.pendingEvent = null;
        renderEventPanel();
        renderRelicStrip();
        renderCurseHud();
        updateScoreLabel();
        updateResourceLabels();
        setScene("inRound");
        setButtonsEnabled(true);
        moveButtons[0].focus();
        return;
      }
      let effectsText = "No effect";

      if (choice.effect === "gainRelicAndCurse") {
        const relic = rollDeterministicRelic(node.id, choice.id);
        const curse = gainRandomCurse(node.id, choice.id);
        if (relic && curse) {
          runState.activeRelics.push({ id: relic.id, used: false });
          noteDiscovery("relic", relic.id);
          effectsText = `Gained relic ${relic.name} and curse ${curse.name}`;
        } else if (relic) {
          runState.activeRelics.push({ id: relic.id, used: false });
          noteDiscovery("relic", relic.id);
          effectsText = `Gained relic ${relic.name}; no new curses available`;
        } else if (curse) {
          effectsText = `No relic available, gained curse ${curse.name}`;
        } else {
          effectsText = "No relic or new curse available";
        }
      } else if (choice.effect === "skipNextLossPenalty") {
        runState.skipNextLossPenalty = true;
        effectsText = "Next loss will not grant Rock score";
      } else if (choice.effect === "revealNextNodeReward") {
        runState.revealNextNodeReward = true;
        effectsText = "Next branch reward preview revealed";
      } else if (choice.effect === "rareChainStart") {
        runState.rareChainStage = 1;
        effectsText = "Rare chain started";
      } else if (choice.effect === "instantDraw") {
        draws += 1;
        effectsText = "+1 draw score";
      } else if (choice.effect === "unlockBossVariant") {
        runState.rareChainStage = 2;
        runState.unlockedBossVariant = "obsidian-headliner";
        runState.nodeEnemyAssignments = assignEnemiesToNodes(runState.mapNodes, runSeed);
        effectsText = "Unlocked Obsidian Headliner boss variant";
      } else if (choice.effect === "skipNextLossPenaltyAndEndChain") {
        runState.skipNextLossPenalty = true;
        runState.rareChainStage = 0;
        effectsText = "Chain ended, next loss penalty skipped";
      }

      logEventDecision(event, choice, effectsText, node);
      commentaryEl.textContent = `${event.title}: ${choice.title}. ${effectsText}.`;
      runState.pendingEvent = null;
      renderEventPanel();
      renderRelicStrip();
      renderCurseHud();
      updateScoreLabel();
      updateResourceLabels();
      setScene("inRound");
      setButtonsEnabled(true);
      moveButtons[0].focus();
    }

    function getDefaultProfileState() {
      return {
        schemaVersion: PROFILE_SCHEMA_VERSION,
        xp: 0,
        totalRuns: 0,
        totalWins: 0,
        totalNodesPlayed: 0,
        claimedMilestones: {},
        unlockedRewards: ["enemy-pool-boss-variant"],
        discoveredRelics: {},
        discoveredEvents: {},
        discoveredEnemies: {},
        cosmetics: {}
      };
    }

    function migrateProfileState(raw) {
      const base = getDefaultProfileState();
      if (!raw || typeof raw !== "object" || Array.isArray(raw)) return base;
      const migrated = {
        ...base,
        ...raw,
        schemaVersion: PROFILE_SCHEMA_VERSION,
        claimedMilestones: raw.claimedMilestones && typeof raw.claimedMilestones === "object" ? raw.claimedMilestones : {},
        unlockedRewards: Array.isArray(raw.unlockedRewards) ? raw.unlockedRewards.slice() : base.unlockedRewards.slice(),
        discoveredRelics: raw.discoveredRelics && typeof raw.discoveredRelics === "object" ? raw.discoveredRelics : {},
        discoveredEvents: raw.discoveredEvents && typeof raw.discoveredEvents === "object" ? raw.discoveredEvents : {},
        discoveredEnemies: raw.discoveredEnemies && typeof raw.discoveredEnemies === "object" ? raw.discoveredEnemies : {},
        cosmetics: raw.cosmetics && typeof raw.cosmetics === "object" ? raw.cosmetics : {}
      };
      if (!migrated.unlockedRewards.includes("enemy-pool-boss-variant")) migrated.unlockedRewards.push("enemy-pool-boss-variant");
      return migrated;
    }

    function loadProfileState() {
      try {
        const raw = localStorage.getItem(PROFILE_STORAGE_KEY);
        if (!raw) return getDefaultProfileState();
        const parsed = JSON.parse(raw);
        return migrateProfileState(parsed);
      } catch (err) {
        return getDefaultProfileState();
      }
    }

    function saveProfileState() {
      if (!profileState) return;
      try { localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify(profileState)); } catch (err) {}
    }

    function getXpToNextLevel(level) {
      return 80 + ((level - 1) * 35);
    }

    function getProfileLevelAndRemainder(xp) {
      let level = 1;
      let remaining = Math.max(0, Math.floor(Number(xp) || 0));
      let need = getXpToNextLevel(level);
      while (remaining >= need) {
        remaining -= need;
        level += 1;
        need = getXpToNextLevel(level);
      }
      return { level, current: remaining, needed: need };
    }

    function hasProfileUnlock(unlockId) {
      return !!(profileState && profileState.unlockedRewards.includes(unlockId));
    }

    function canUseRelic(relic) {
      return !relic.unlockId || hasProfileUnlock(relic.unlockId);
    }

    function canUseEvent(event) {
      return !event.unlockId || hasProfileUnlock(event.unlockId);
    }

    function getEnemyPoolForNodeType(type) {
      const basePool = (NODE_ENEMY_POOLS[type] || NODE_ENEMY_POOLS.normal || []).slice();
      if (type === "normal" && hasProfileUnlock("enemy-pool-mirror") && !basePool.includes("mirrorLag")) basePool.push("mirrorLag");
      return basePool;
    }

    function noteDiscovery(kind, id) {
      if (!profileState || !id) return;
      const key = kind === "relic" ? "discoveredRelics" : kind === "event" ? "discoveredEvents" : "discoveredEnemies";
      if (profileState[key][id]) return;
      profileState[key][id] = true;
      saveProfileState();
      renderProfileUI();
    }

    function renderCodexList(targetEl, entries, discoveredMap, labelFn, availableFn = () => true) {
      if (!targetEl) return;
      targetEl.innerHTML = "";
      entries.forEach(entry => {
        const li = document.createElement("li");
        const available = availableFn(entry);
        const discovered = !!discoveredMap[entry.id];
        if (!available) {
          li.className = "unknown";
          li.textContent = "üîí Locked by profile level";
        } else if (discovered) {
          li.className = "known";
          li.textContent = labelFn(entry);
        } else {
          li.className = "unknown";
          li.textContent = "??? Undiscovered";
        }
        targetEl.appendChild(li);
      });
    }

    function renderProfileUI() {
      if (!profileState) return;
      const xpState = getProfileLevelAndRemainder(profileState.xp);
      if (profileLevelLabelEl) profileLevelLabelEl.textContent = `Profile level ${xpState.level}`;
      if (profileXpLabelEl) profileXpLabelEl.textContent = `${xpState.current} / ${xpState.needed} XP`;
      if (profileProgressFillEl) profileProgressFillEl.style.width = `${Math.round((xpState.current / xpState.needed) * 100)}%`;
      renderCodexList(codexRelicsEl, relicCatalog, profileState.discoveredRelics, relic => relic.name, canUseRelic);
      renderCodexList(codexEventsEl, eventCatalog, profileState.discoveredEvents, event => event.title, canUseEvent);
      renderCodexList(codexEnemiesEl, Object.values(ENEMY_DEFINITIONS), profileState.discoveredEnemies, enemy => `${enemy.portrait} ${enemy.name}`);
      if (gameTitleEl) gameTitleEl.classList.toggle("title-cosmetic-obsidian", !!profileState.cosmetics.obsidianBanner);
    }

    function applyProfileProgressFromRun() {
      if (!profileState) return [];
      const before = getProfileLevelAndRemainder(profileState.xp).level;
      profileState.totalRuns += 1;
      profileState.totalNodesPlayed += historyLog.length;
      if (youScore > rockScore && !runState.runFailed) profileState.totalWins += 1;

      PROFILE_MILESTONES.forEach(milestone => {
        if (profileState.claimedMilestones[milestone.id]) return;
        let met = false;
        if (milestone.id.startsWith("finish-")) met = profileState.totalRuns >= Number(milestone.id.split("-")[1]);
        else if (milestone.id.startsWith("wins-")) met = profileState.totalWins >= Number(milestone.id.split("-")[1]);
        else if (milestone.id === "nodes-60") met = profileState.totalNodesPlayed >= 60;
        if (met) {
          profileState.claimedMilestones[milestone.id] = true;
          profileState.xp += milestone.xp;
        }
      });

      const after = getProfileLevelAndRemainder(profileState.xp).level;
      const newUnlocks = [];
      PROFILE_LEVEL_REWARDS.forEach(reward => {
        if (after < reward.level) return;
        if (profileState.unlockedRewards.includes(reward.id)) return;
        profileState.unlockedRewards.push(reward.id);
        if (reward.id === "cosmetic-banner-obsidian") profileState.cosmetics.obsidianBanner = true;
        newUnlocks.push(reward.text);
      });

      saveProfileState();
      renderProfileUI();
      return after > before || newUnlocks.length ? newUnlocks : [];
    }

    function loadPersistentAchievements() {
      try {
        const raw = localStorage.getItem(ACHIEVEMENTS_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return {};
        const counts = {};
        achievementCatalog.forEach(a => {
          const val = parsed[a.id];
          counts[a.id] = Number.isInteger(val) && val > 0 ? val : 0;
        });
        return counts;
      } catch (err) {
        return {};
      }
    }

    function savePersistentAchievements() {
      try {
        localStorage.setItem(ACHIEVEMENTS_STORAGE_KEY, JSON.stringify(achievementUnlockCounts));
      } catch (err) {}
    }

    function resetPersistentAchievements() {
      achievementUnlockCounts = {};
      achievementCatalog.forEach(a => { achievementUnlockCounts[a.id] = 0; });
      savePersistentAchievements();
      renderAchievements();
    }

    function generateRandomSeed() {
      return Math.floor(Math.random() * (U32_MAX + 1));
    }

    function loadTutorialState() {
      try {
        return localStorage.getItem(TUTORIAL_STORAGE_KEY) === "done";
      } catch (err) {
        return false;
      }
    }

    function persistTutorialComplete() {
      tutorialCompleted = true;
      try {
        localStorage.setItem(TUTORIAL_STORAGE_KEY, "done");
      } catch (err) {}
    }

    function clearTutorialTarget() {
      if (!tutorialCurrentTarget) return;
      tutorialCurrentTarget.classList.remove("tutorial-target");
      tutorialCurrentTarget = null;
    }

    function hideTutorialTooltip() {
      tutorialTooltipEl.classList.add("is-hidden");
      clearTutorialTarget();
    }

    function positionTutorialTooltip(targetEl) {
      if (!targetEl) return;
      const rect = targetEl.getBoundingClientRect();
      const maxLeft = window.innerWidth - tutorialTooltipEl.offsetWidth - 10;
      let left = Math.max(10, Math.min(rect.left, maxLeft));
      let top = rect.bottom + 12;
      const maxTop = window.innerHeight - tutorialTooltipEl.offsetHeight - 10;
      if (top > maxTop) top = Math.max(10, rect.top - tutorialTooltipEl.offsetHeight - 12);
      tutorialTooltipEl.style.left = `${left}px`;
      tutorialTooltipEl.style.top = `${top}px`;
    }

    function renderTutorialStep() {
      if (!tutorialActive || tutorialStepIndex >= tutorialSteps.length) {
        hideTutorialTooltip();
        return;
      }

      const step = tutorialSteps[tutorialStepIndex];
      const targetEl = step.anchor && step.anchor();
      if (!targetEl) {
        completeTutorial();
        return;
      }

      tutorialTooltipTitleEl.textContent = step.title;
      tutorialTooltipTextEl.textContent = step.text;
      tutorialTooltipEl.classList.remove("is-hidden");
      clearTutorialTarget();
      tutorialCurrentTarget = targetEl;
      tutorialCurrentTarget.classList.add("tutorial-target");
      positionTutorialTooltip(targetEl);
    }

    function completeTutorial() {
      tutorialActive = false;
      hideTutorialTooltip();
      persistTutorialComplete();
    }

    function advanceTutorialOnAction(actionId) {
      if (!tutorialActive) return;
      const step = tutorialSteps[tutorialStepIndex];
      if (!step || step.id !== actionId) return;
      tutorialStepIndex += 1;
      if (tutorialStepIndex >= tutorialSteps.length) completeTutorial();
      else renderTutorialStep();
    }

    function startTutorial({ replay = false } = {}) {
      tutorialActive = true;
      tutorialStepIndex = 0;
      if (replay) tutorialCompleted = false;
      renderTutorialStep();
    }

    function maybeStartTutorial() {
      tutorialCompleted = loadTutorialState();
      if (!tutorialCompleted) startTutorial();
      else hideTutorialTooltip();
    }

    function buildAchievementState() {
      let maxWinStreak = 0, curW = 0;
      let maxRockStreak = 0, curL = 0;
      let maxDrawStreak = 0, curD = 0;
      let paranoidCount = 0;
      let paranoidWins = 0;
      let rollingYou = 0;
      let rollingRock = 0;
      let maxRockLead = 0;
      const seenMoods = new Set();
      const yourMoves = historyLog.map(entry => entry.yourMove);
      const moveCounts = { R: 0, P: 0, S: 0 };
      const defeatedEnemyIds = new Set();
      const defeatedProfiles = new Set();
      let bossPhaseWin = false;
      let obsidianBossWin = false;

      historyLog.forEach(entry => {
        if (entry.outcome === "win") { curW += 1; curL = 0; curD = 0; rollingYou += 1; }
        else if (entry.outcome === "lose") { curL += 1; curW = 0; curD = 0; rollingRock += 1; }
        else { curD += 1; curW = 0; curL = 0; }

        maxWinStreak = Math.max(maxWinStreak, curW);
        maxRockStreak = Math.max(maxRockStreak, curL);
        maxDrawStreak = Math.max(maxDrawStreak, curD);
        if (entry.mood === "Paranoid") {
          paranoidCount += 1;
          if (entry.outcome === "win") paranoidWins += 1;
        }
        seenMoods.add(entry.mood);
        if (moveCounts[entry.yourMove] !== undefined) moveCounts[entry.yourMove] += 1;

        maxRockLead = Math.max(maxRockLead, rollingRock - rollingYou);
        if (entry.outcome === "win" && entry.enemyId) {
          defeatedEnemyIds.add(entry.enemyId);
          if (entry.enemyProfile) defeatedProfiles.add(entry.enemyProfile);
          if (entry.nodeType === "boss" && entry.enemyPhase) bossPhaseWin = true;
          if (entry.enemyId === "obsidian-headliner") obsidianBossWin = true;
        }
      });

      const noLossesFirstFive = historyLog.slice(0, 5).every(entry => entry.outcome !== "lose");
      const lastThreeAreWins = historyLog.length >= 3 && historyLog.slice(-3).every(entry => entry.outcome === "win");
      const lostFirstThree = historyLog.length >= 3 && historyLog.slice(0, 3).every(entry => entry.outcome === "lose");
      const firstThreeUnique = historyLog.length >= 3 && new Set(historyLog.slice(0, 3).map(entry => entry.yourMove)).size === 3;
      const openedNonPaper = historyLog.length >= 1 && historyLog[0].yourMove !== "P";
      const lossMargin = Math.max(0, rockScore - youScore);
      const onlyRock = historyLog.length === getTotalNodes() && yourMoves.every(move => move === "R");
      const onlyPaper = historyLog.length === getTotalNodes() && yourMoves.every(move => move === "P");
      const onlyScissors = historyLog.length === getTotalNodes() && yourMoves.every(move => move === "S");
      const noConsecutiveSameMove = historyLog.length === getTotalNodes() && yourMoves.every((move, idx) => idx === 0 || move !== yourMoves[idx - 1]);
      const minMoveCount = Math.min(moveCounts.R, moveCounts.P, moveCounts.S);
      const palindromeShape = historyLog.length === getTotalNodes() && yourMoves.every((move, idx) => move === yourMoves[yourMoves.length - 1 - idx]);
      const firstHalfTransitions = historyLog.length >= 10 ? yourMoves.slice(0, 10).reduce((count, move, idx, arr) => idx === 0 ? 0 : count + (move !== arr[idx - 1] ? 1 : 0), 0) : 0;
      const complexPalindromeMoves = palindromeShape && firstHalfTransitions >= 4;

      return {
        historyLog,
        maxWinStreak,
        maxRockStreak,
        maxLoseStreak: maxRockStreak,
        maxDrawStreak,
        paranoidCount,
        paranoidWins,
        noLossesFirstFive,
        lastThreeAreWins,
        lostFirstThree,
        firstThreeUnique,
        openedNonPaper,
        lossMargin,
        onlyRock,
        onlyPaper,
        onlyScissors,
        noConsecutiveSameMove,
        minMoveCount,
        complexPalindromeMoves,
        maxRockLead,
        seenMoods,
        youScore,
        rockScore,
        draws,
        beatRockHits,
        seedWasManual,
        adaptiveEverOnThisRun,
        adaptiveAttempts,
        adaptiveCorrectReads,
        defeatedEnemyIds,
        defeatedProfiles,
        bossPhaseWin,
        obsidianBossWin,
        matchFinished: historyLog.length === getTotalNodes()
      };
    }

    function getUnlockedAchievementDefs() {
      const state = buildAchievementState();
      return achievementCatalog.filter(achievement => achievement.unlocked(state));
    }

    function ensureAudioContext() {
      if (audioCtx) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) return;
      audioCtx = new AudioContext();
      masterGainNode = audioCtx.createGain();
      ambientGainNode = audioCtx.createGain();
      confirmGainNode = audioCtx.createGain();
      uiGainNode = audioCtx.createGain();

      masterGainNode.gain.value = 1;
      ambientGainNode.gain.value = 0;
      confirmGainNode.gain.value = 0;
      uiGainNode.gain.value = 0;

      ambientGainNode.connect(masterGainNode);
      confirmGainNode.connect(masterGainNode);
      uiGainNode.connect(masterGainNode);
      masterGainNode.connect(audioCtx.destination);
      syncAudioMix();
      ensureAmbientLoop();
    }

    function isReducedEffectsMode() {
      return prefersReducedMotion();
    }

    function syncAudioMix() {
      if (!audioCtx || !ambientGainNode || !confirmGainNode || !uiGainNode) return;
      const active = sfxEnabled ? 1 : 0;
      const now = audioCtx.currentTime;
      ambientGainNode.gain.setTargetAtTime(active * ambientVolume * 0.35, now, 0.08);
      confirmGainNode.gain.setTargetAtTime(active * confirmVolume * 0.5, now, 0.05);
      uiGainNode.gain.setTargetAtTime(active * uiVolume * 0.45, now, 0.04);
    }

    function ensureAmbientLoop() {
      if (!audioCtx || ambientOscillators.length > 0) return;
      const tones = [82, 123];
      ambientOscillators = tones.map((freq, idx) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = idx === 0 ? "sine" : "triangle";
        osc.frequency.value = freq;
        gain.gain.value = idx === 0 ? 0.55 : 0.35;
        osc.connect(gain);
        gain.connect(ambientGainNode);
        osc.start();
        return osc;
      });
    }

    function playLayeredTone({ freq = 440, duration = 0.18, layer = "ui", type = "sine", peak = 0.2 }) {
      if (!sfxEnabled) return;
      try {
        ensureAudioContext();
        if (!audioCtx) return;
        if (audioCtx.state === "suspended") audioCtx.resume && audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        const target = layer === "confirm" ? confirmGainNode : uiGainNode;
        gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(peak, audioCtx.currentTime + Math.min(0.03, duration * 0.3));
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(target || audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration + 0.02);
      } catch (e) {}
    }

    function playUiPip(type = "hover") {
      if (type === "anticipation") {
        playLayeredTone({ freq: 560, duration: 0.09, layer: "ui", type: "triangle", peak: 0.1 });
        setTimeout(() => playLayeredTone({ freq: 680, duration: 0.1, layer: "ui", type: "triangle", peak: 0.12 }), isReducedEffectsMode() ? 40 : 80);
        return;
      }
      playLayeredTone({ freq: type === "hover" ? 420 : 510, duration: 0.08, layer: "ui", type: "square", peak: 0.08 });
    }

    function playHitConfirm(outcome) {
      if (outcome === "win") {
        playLayeredTone({ freq: 760, duration: 0.16, layer: "confirm", type: "sawtooth", peak: 0.2 });
        setTimeout(() => playLayeredTone({ freq: 920, duration: 0.14, layer: "confirm", type: "triangle", peak: 0.16 }), isReducedEffectsMode() ? 30 : 70);
        return;
      }
      if (outcome === "lose") {
        playLayeredTone({ freq: 220, duration: 0.2, layer: "confirm", type: "sawtooth", peak: 0.22 });
        return;
      }
      playLayeredTone({ freq: 360, duration: 0.14, layer: "confirm", type: "triangle", peak: 0.16 });
    }

    function playBeep(type) {
      playHitConfirm(type);
    }

    function randomFromFlavor(arr) {
      const r = rngFlavor ? rngFlavor() : Math.random();
      return arr[Math.floor(r * arr.length)];
    }

    function describeRound(outcome, beatRockThisRound) {
      const enemy = getActiveEnemy();
      let base;
      if (outcome === "win") base = randomFromFlavor(rockLosingQuips);
      else if (outcome === "lose") base = randomFromFlavor(rockWinningQuips);
      else base = randomFromFlavor(drawQuips);

      base = base.replaceAll("The Rock", enemy.title).replaceAll("Dwayne", enemy.name);

      let extra = "";
      if (beatRockThisRound && outcome === "win") extra = " " + randomFromFlavor(beatRockQuips);
      else if (!beatRockThisRound && outcome === "win") extra = " " + randomFromFlavor(missedBeatRockQuips);

      const gimmick = runState.currentEnemyPhase ? ` ${enemy.title} gimmick active: ${runState.currentEnemyPhase}.` : "";
      return base + extra + gimmick;
    }

    function moveRoundBoardFocus(index) {
      if (index < 0 || index >= roundBoardCells.length) return;
      roundBoardCells[index].focus();
    }

    function createRoundBoardCells() {
      roundBoardEl.innerHTML = "";
      roundBoardCells = [];
      for (let i = 0; i < getTotalNodes(); i++) {
        const cell = document.createElement("div");
        cell.className = "round-box";
        cell.tabIndex = 0;
        cell.setAttribute("role", "button");
        cell.setAttribute("aria-label", `Round ${i + 1}, not played yet.`);
        cell.addEventListener("mouseenter", () => handleRoundBoardHover(i));
        cell.addEventListener("mouseleave", () => clearRoundBoardHover(i));
        cell.addEventListener("focus", () => handleRoundBoardHover(i));
        cell.addEventListener("blur", () => clearRoundBoardHover(i));
        cell.addEventListener("click", () => handleRoundBoardHover(i));
        cell.addEventListener("keydown", (event) => {
          if (event.key === "ArrowRight" || event.key === "ArrowDown") {
            event.preventDefault();
            moveRoundBoardFocus(i + 1);
          } else if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
            event.preventDefault();
            moveRoundBoardFocus(i - 1);
          } else if (event.key === "Home") {
            event.preventDefault();
            moveRoundBoardFocus(0);
          } else if (event.key === "End") {
            event.preventDefault();
            moveRoundBoardFocus(roundBoardCells.length - 1);
          } else if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            handleRoundBoardHover(i);
          }
        });
        roundBoardEl.appendChild(cell);
        roundBoardCells.push(cell);
      }
    }

    function renderRoundBoard() {
      roundBoardCells.forEach((cell, i) => {
        const entry = historyLog[i];
        cell.className = "round-box";
        if (i === currentRound && !isRunComplete()) cell.classList.add("current");

        if (!entry) {
          cell.innerHTML = `<span class="round-num">R${i + 1}</span><span class="round-hands">¬∑</span><span class="round-outcome">¬∑</span>`;
          cell.setAttribute("aria-label", `Round ${i + 1}, not played yet.`);
          return;
        }

        const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
        const resultMark = entry.outcome === "win" ? "W" : entry.outcome === "lose" ? "L" : "D";

        cell.classList.add("played", entry.outcome);
        cell.innerHTML =
          `<span class="round-num">R${entry.round}</span>` +
          `<span class="round-hands">${glyph[entry.rockMove]}${glyph[entry.yourMove]}</span>` +
          `<span class="round-outcome">${resultMark}</span>`;
        cell.setAttribute("aria-label", `Round ${entry.round}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${outcomeText}.`);
      });

      if (isRunComplete()) roundBoardStatusEl.textContent = "All run nodes complete";
      else roundBoardStatusEl.textContent = `Node ${currentRound + 1} is live`;

      if (activeRoundBoardIndex !== null && roundBoardCells[activeRoundBoardIndex]) {
        roundBoardCells[activeRoundBoardIndex].classList.add("current");
      }
    }

    function handleRoundBoardHover(index) {
      advanceTutorialOnAction("roundBoard");
      if (index >= historyLog.length) {
        roundBoardPreviewEl.innerHTML = `<strong>Node ${index + 1}</strong> not played yet in this run.`;
        return;
      }
      const entry = historyLog[index];
      activeRoundBoardIndex = index;
      const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
      const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
      roundBoardPreviewEl.innerHTML =
        `<strong>Round ${entry.round}</strong>, Dwayne ${names[entry.rockMove]} (${glyph[entry.rockMove]}) vs you ` +
        `${names[entry.yourMove]} (${glyph[entry.yourMove]}), outcome ${outcomeText}, state ${entry.mood}, ${pathText}.`;
    }

    function clearRoundBoardHover(index) {
      if (activeRoundBoardIndex === index) activeRoundBoardIndex = null;
      if (historyLog.length === 0) {
        roundBoardPreviewEl.textContent = "Hover, focus, or tap a played node to preview exact hands, outcome, and mood.";
      } else {
        const last = historyLog[historyLog.length - 1];
        const outcomeText = last.outcome === "win" ? "you win" : last.outcome === "lose" ? "The Rock wins" : "draw";
        roundBoardPreviewEl.innerHTML = `<strong>Last round</strong> was ${last.round}, outcome ${outcomeText}. Hover any played round for detail.`;
      }
    }

    function openDrawerPanel(panelEl, { highlight = false } = {}) {
      if (!panelEl) return;
      panelEl.open = true;
      if (!highlight) return;
      panelEl.classList.add("highlighted");
      setTimeout(() => panelEl.classList.remove("highlighted"), 1500);
    }

    function setScene(nextScene) {
      sceneState = nextScene;
      sceneLobbyEl.classList.toggle("is-hidden", nextScene !== "lobby");
      sceneGameEl.classList.toggle("is-hidden", nextScene === "lobby");
      sceneSummaryEl.classList.toggle("is-hidden", nextScene !== "matchSummary");
      mapPanelEl.classList.toggle("is-hidden", nextScene === "lobby" || nextScene === "matchSummary");
      eventPanelEl.classList.toggle("is-hidden", !(sceneState === "map" && !!runState.pendingEvent));
      document.body.classList.toggle("gameplay-active", nextScene === "inRound" || nextScene === "roundResult");
      if (tutorialActive) renderTutorialStep();
    }

    function showRoundResultOverlay(text) {
      if (roundResultTimer) {
        clearTimeout(roundResultTimer);
        roundResultTimer = null;
      }
      roundResultOverlayTextEl.textContent = text;
      roundResultOverlayEl.classList.remove("is-hidden");
      setScene("roundResult");
      roundResultTimer = setTimeout(() => {
        roundResultOverlayEl.classList.add("is-hidden");
      cinematicCardOverlayEl.classList.add("is-hidden");
        if (isRunComplete()) setScene("matchSummary");
        else if (runState.availableNodeIds.length > 0) setScene("map");
        else setScene("inRound");
      }, 700);
    }

    function openGameMenu() {
      gameMenuModal.classList.add("is-active");
      gameMenuBtn.setAttribute("aria-expanded", "true");
    }

    function closeGameMenu() {
      gameMenuModal.classList.remove("is-active");
      gameMenuBtn.setAttribute("aria-expanded", "false");
    }

    function isModalInputFocused(target) {
      if (!target || !(target instanceof Element)) return false;
      if (!gameMenuModal.contains(target)) return false;
      const tag = target.tagName;
      return tag === "INPUT" || tag === "TEXTAREA" || target.isContentEditable;
    }

    function setButtonsEnabled(enabled) { moveButtons.forEach(btn => btn.disabled = !enabled); }
    function setRoundPhase(phase) { roundPhase = phase; }
    function prefersReducedMotion() { return !!(reducedMotionQuery && reducedMotionQuery.matches); }
    function getPhaseDelay(ms) { return prefersReducedMotion() ? 0 : ms; }
    function waitForPhase(ms) {
      const duration = getPhaseDelay(ms);
      if (!duration) return Promise.resolve();
      return new Promise(resolve => setTimeout(resolve, duration));
    }


    function triggerArenaWash(outcome) {
      if (!arenaWashEl) return;
      arenaWashEl.className = `arena-wash outcome-${outcome}`;
      if (isReducedEffectsMode()) {
        arenaWashEl.classList.add("flash");
        setTimeout(() => { arenaWashEl.className = "arena-wash"; }, 120);
        return;
      }
      arenaWashEl.classList.remove("flash");
      void arenaWashEl.offsetWidth;
      arenaWashEl.classList.add("flash");
      setTimeout(() => { arenaWashEl.className = "arena-wash"; }, 420);
    }

    function applyOutcomeCamera(outcome) {
      arenaEl.classList.remove("phase-outcome-win", "phase-outcome-lose", "phase-outcome-draw");
      arenaEl.classList.add(`phase-outcome-${outcome}`);
      setTimeout(() => arenaEl.classList.remove(`phase-outcome-${outcome}`), isReducedEffectsMode() ? 110 : 380);
    }

    function getComboCallouts(outcome, relicFeedback) {
      if (outcome !== "win") return [];
      let streak = 0;
      for (let i = historyLog.length - 1; i >= 0; i -= 1) {
        if (historyLog[i].outcome !== "win") break;
        streak += 1;
      }
      streak += 1;
      const callouts = [];
      if (streak === 3) callouts.push("Combo online ¬∑ Triple streak");
      if (streak === 5) callouts.push("Combo surge ¬∑ Five straight");
      if (streak >= 7 && streak % 2 === 1) callouts.push(`Combo inferno ¬∑ ${streak} streak`);
      if (Array.isArray(relicFeedback) && relicFeedback.length >= 2) callouts.push("Relic synergy proc");
      return callouts;
    }

    async function showCinematicCard({ tier = "elite", tag, title, body }) {
      if (!cinematicCardOverlayEl || !cinematicCardEl) return;
      if (cinematicCardTimer) {
        clearTimeout(cinematicCardTimer);
        cinematicCardTimer = null;
      }
      cinematicCardEl.className = `cinematic-card ${tier}`;
      cinematicCardTagEl.textContent = tag;
      cinematicCardTitleEl.textContent = title;
      cinematicCardBodyEl.textContent = body;
      cinematicCardOverlayEl.classList.remove("is-hidden");
      const duration = isReducedEffectsMode() ? 280 : 980;
      await new Promise(resolve => {
        cinematicCardTimer = setTimeout(() => {
          cinematicCardOverlayEl.classList.add("is-hidden");
          cinematicCardTimer = null;
          resolve();
        }, duration);
      });
    }

    function resetArenaPhaseClasses() {
      arenaEl.classList.remove("phase-lock-in", "phase-reveal", "phase-anticipation", "phase-outcome-win", "phase-outcome-lose", "phase-outcome-draw");
      rockHandEl.classList.remove("reveal-pop");
      yourHandEl.classList.remove("reveal-pop");
    }

    function updateRoundLabel() {
      const activeNode = getActiveNode();
      roundLabelEl.textContent = activeNode ? `Act ${activeNode.act} Node ${activeNode.index}` : `Act 1 Node ${Math.min(currentRound + 1, getTotalNodes())}`;
    }
    function updateScoreLabel() {
      const extras = [];
      if (runState.skipNextLossPenalty) extras.push("ward ready");
      if (runState.activeCurses.length > 0) extras.push(`curses ${runState.activeCurses.length}`);
      if (runState.consumableShieldCharges > 0) extras.push(`tonics ${runState.consumableShieldCharges}`);
      const enemy = getActiveEnemy();
      scoreLabelEl.textContent = `${enemy.title} ${rockScore}  |  You ${youScore}  |  Draws ${draws}${extras.length ? `  |  ${extras.join(" ¬∑ ")}` : ""}`;
    }
    function updateResourceLabels() {
      resolveLabelEl.textContent = `Resolve ${runState.resolve}/${runState.maxResolve}`;
      cashLabelEl.textContent = `Cash $${runState.cash}`;
    }
    function updateProgressBar() {
      const pct = (currentRound / getTotalNodes()) * 100;
      progressFillEl.style.width = `${pct}%`;
      progressTextEl.textContent = `${currentRound} of ${getTotalNodes()} completed`;
    }
    function updateRunSummary() {
      runSummarySeedEl.textContent = `Seed ${runSeed}`;
      const modeLabel = challengeMode === "casual" ? (adaptiveToggle.checked ? "Adaptive on" : "Scripted") : `${challengeMode.toUpperCase()} challenge`;
      runSummaryModeEl.textContent = modeLabel;
      const runStarted = currentRound > 0 || runState.selectedPath.length > 0 || sceneState === "inRound" || sceneState === "roundResult" || sceneState === "matchSummary" || sceneState === "map";
      runSummaryPillEl.classList.toggle("is-hidden", !runStarted);
    }

    function showCopyStatus(message, isError) {
      copyStatusEl.textContent = message;
      copyStatusEl.classList.toggle("error", !!isError);
      if (showCopyStatus.timer) clearTimeout(showCopyStatus.timer);
      showCopyStatus.timer = setTimeout(() => {
        copyStatusEl.textContent = "";
        copyStatusEl.classList.remove("error");
      }, 2400);
    }

    function buildChallengeLink() {
      const url = new URL(window.location.href);
      const adaptiveRunSequence = historyLog.length === getTotalNodes() && historyLog.some(entry => entry.adaptiveUsed)
        ? historyLog.map(entry => entry.rockMove).join("")
        : null;
      const relicRunSequence = runState.activeRelics.map(relic => relic.id).join(",");
      const curseRunSequence = runState.activeCurses.join(",");

      url.searchParams.set("seed", String(runSeed));
      url.searchParams.set("mode", challengeMode);
      if (challengeMode === "daily" && challengeContext.utcDateKey) url.searchParams.set("date", challengeContext.utcDateKey);
      else url.searchParams.delete("date");
      if (challengeMode === "weekly" && challengeContext.weekLabel) url.searchParams.set("week", challengeContext.weekLabel);
      else url.searchParams.delete("week");
      if (adaptiveRunSequence) {
        url.searchParams.set("script", adaptiveRunSequence);
        url.searchParams.set("adaptive", "0");
      } else {
        url.searchParams.delete("script");
        url.searchParams.set("adaptive", adaptiveToggle.checked ? "1" : "0");
      }
      if (relicRunSequence) url.searchParams.set("relics", relicRunSequence);
      else url.searchParams.delete("relics");
      if (curseRunSequence) url.searchParams.set("curses", curseRunSequence);
      else url.searchParams.delete("curses");
      url.searchParams.set("sfx", sfxToggle.checked ? "1" : "0");
      url.searchParams.set("av", String(Math.round(ambientVolume * 100)));
      url.searchParams.set("cv", String(Math.round(confirmVolume * 100)));
      url.searchParams.set("uv", String(Math.round(uiVolume * 100)));
      return url.toString();
    }

    function fallbackCopyText(text) {
      const tempInput = document.createElement("input");
      tempInput.type = "text";
      tempInput.value = text;
      tempInput.setAttribute("readonly", "readonly");
      tempInput.style.position = "fixed";
      tempInput.style.opacity = "0";
      document.body.appendChild(tempInput);
      tempInput.focus();
      tempInput.select();
      tempInput.setSelectionRange(0, tempInput.value.length);
      const copied = document.execCommand("copy");
      document.body.removeChild(tempInput);
      return copied;
    }

    async function copyChallengeLink() {
      const challengeLink = buildChallengeLink();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(challengeLink);
          showCopyStatus("Challenge link copied to clipboard.", false);
          return;
        }
      } catch (err) {}

      const copied = fallbackCopyText(challengeLink);
      if (copied) showCopyStatus("Challenge link copied to clipboard.", false);
      else showCopyStatus("Could not copy. Please copy manually.", true);
    }

    function readInitialSettingsFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const seedParam = params.get("seed");
      const scriptParam = params.get("script");
      const adaptiveParam = params.get("adaptive");
      const sfxParam = params.get("sfx");
      const relicsParam = params.get("relics");
      const cursesParam = params.get("curses");
      const modeParam = params.get("mode");
      const ambientParam = params.get("av");
      const confirmParam = params.get("cv");
      const uiParam = params.get("uv");

      let scriptOverride = null;
      if (scriptParam && SCRIPT_SEQUENCE_REGEX.test(scriptParam)) {
        scriptOverride = scriptParam.toUpperCase().split("");
        scriptOverride[0] = "R";
      }

      if (scriptOverride) {
        adaptiveToggle.checked = false;
      } else if (adaptiveParam === "1" || adaptiveParam === "0") {
        adaptiveToggle.checked = adaptiveParam === "1";
      }
      if (sfxParam === "1" || sfxParam === "0") {
        sfxToggle.checked = sfxParam === "1";
      }
      const parseVol = (value, fallback) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return fallback;
        return Math.max(0, Math.min(100, n));
      };
      ambientVolEl.value = String(parseVol(ambientParam, Number(ambientVolEl.value)));
      confirmVolEl.value = String(parseVol(confirmParam, Number(confirmVolEl.value)));
      uiVolEl.value = String(parseVol(uiParam, Number(uiVolEl.value)));
      ambientVolume = Number(ambientVolEl.value) / 100;
      confirmVolume = Number(confirmVolEl.value) / 100;
      uiVolume = Number(uiVolEl.value) / 100;
      sfxEnabled = sfxToggle.checked;
      syncAudioMix();

      const initialRelics = relicsParam
        ? relicsParam.split(",").map(id => id.trim()).filter(id => relicCatalog.some(relic => relic.id === id))
        : [];
      const initialCurses = cursesParam
        ? cursesParam.split(",").map(id => id.trim()).filter(id => curseCatalog.some(curse => curse.id === id))
        : [];

      const initialMode = ["casual", "daily", "weekly"].includes(modeParam) ? modeParam : "casual";
      if (seedParam === null) return { seed: null, manual: false, scriptOverride, initialRelics, initialCurses, initialMode };
      const normalizedSeed = normalizeSeed(seedParam);
      if (!normalizedSeed.valid) return { seed: null, manual: false, scriptOverride, initialRelics, initialCurses, initialMode };
      return { seed: normalizedSeed.seed, manual: true, scriptOverride, initialRelics, initialCurses, initialMode };
    }

    function shakeArena() {
      if (prefersReducedMotion()) return;
      arenaEl.classList.remove("shake");
      void arenaEl.offsetWidth;
      arenaEl.classList.add("shake");
      setTimeout(() => arenaEl.classList.remove("shake"), 350);
    }

    function updateAdaptiveStats() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (!adaptiveToggle.checked) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> is off. If enabled, The Rock in ${rockMood} mood would have a ${adaptPct}% read chance.`;
        return;
      }
      if (adaptiveAttempts === 0) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> mood projects a ${adaptPct}% read chance this round. Attempts will appear once he starts adapting.`;
        return;
      }
      const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
      adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> this round: ${adaptPct}% read chance ¬∑ attempts ${adaptiveAttempts} ¬∑ correct reads ${adaptiveCorrectReads} ¬∑ accuracy ${acc}%.`;
    }

    function updateMoodDisplay() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      const moodMeta = {
        Calm: { emoji: "üòå", severity: "severity-low", label: "CALM" },
        Suspicious: { emoji: "ü§®", severity: "severity-mid", label: "SUSPICIOUS" },
        Paranoid: { emoji: "üò§", severity: "severity-high", label: "PARANOID" }
      };
      const activeMeta = moodMeta[rockMood] || moodMeta.Calm;
      moodDisplayEl.classList.remove("severity-low", "severity-mid", "severity-high");
      moodDisplayEl.classList.add(activeMeta.severity);
      const riskText = adaptiveToggle.checked ? `Read risk ${adaptPct}%` : "Adaptive off";
      moodDisplayEl.innerHTML = `
        <span class="mood-emoji" aria-hidden="true">${activeMeta.emoji}</span>
        <span class="mood-text">
          <span class="mood-label">The Rock's state</span>
          <span class="mood-state">${activeMeta.label}</span>
          <span class="mood-risk">${riskText}</span>
        </span>
      `;
    }

    function updatePreRoundHint() {
      if (isRunComplete()) {
        preRoundHintEl.textContent = "Run complete. Check the node board for every throw and read.";
        return;
      }
      const enemy = getActiveEnemy();
      const profile = runState.currentEnemyProfile || enemy.aiProfile;
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (hasCurse("repeated-hand-lock") && runState.curseState.lockoutRoundsRemaining > 0 && runState.curseState.lockoutMove) {
        preRoundHintEl.textContent = `Curse warning: Hand Lock blocks ${names[runState.curseState.lockoutMove]} this round.`;
        return;
      }
      const phase = evaluateEnemyPhase(enemy);
      if (!adaptiveToggle.checked || currentRound === 0 || !lastYourMove) {
        preRoundHintEl.textContent = `Scout report: ${enemy.name} (${profile}) in ${rockMood.toLowerCase()} mode. ${phase ? `Active gimmick: ${phase.name}.` : "Base gimmick online."}`;
        return;
      }
      if (rockMood === "Calm") preRoundHintEl.textContent = `Scout report: ${enemy.name} calm but alert, ${adaptPct}% read chance. Profile ${profile}.`;
      else if (rockMood === "Suspicious") preRoundHintEl.textContent = `Scout report: ${enemy.name} suspicious and aggressive, ${adaptPct}% read chance. Profile ${profile}.`;
      else preRoundHintEl.textContent = `Scout report: ${enemy.name} in full paranoid mode, ${adaptPct}% read chance. Profile ${profile}.`;
    }

    function renderDebugLog() {
      debugLogEl.innerHTML = "";
      historyLog.forEach(entry => {
        const div = document.createElement("div");
        div.className = "debug-log-entry";
        const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
        div.textContent =
          `Round ${entry.round}, state ${entry.mood}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${entry.outcome}, beat The Rock move ${names[entry.beatRockMove]}, ${pathText}.`;
        debugLogEl.appendChild(div);
      });
    }

    function updateRockMood(outcome) {
      if (outcome === "win") rockLossStreak += 1;
      else if (outcome === "draw") rockLossStreak = Math.max(0, rockLossStreak - 1);
      else rockLossStreak = 0;

      if (rockLossStreak >= 3) rockMood = "Paranoid";
      else if (rockLossStreak >= 1) rockMood = "Suspicious";
      else rockMood = "Calm";
    }

    function moodAdaptChance() { return rockMood === "Calm" ? 0.3 : rockMood === "Suspicious" ? 0.6 : 0.9; }

    function weightedRandomMove(weightMap) {
      const entries = ROCK_MOVES.map(move => [move, Math.max(0, Number(weightMap[move] || 0))]);
      const total = entries.reduce((sum, [, weight]) => sum + weight, 0);
      if (total <= 0) return ROCK_MOVES[Math.floor((rngGame ? rngGame() : Math.random()) * ROCK_MOVES.length)] || "R";

      const roll = (rngGame ? rngGame() : Math.random()) * total;
      let running = 0;
      for (const [move, weight] of entries) {
        running += weight;
        if (roll <= running) return move;
      }
      return entries[entries.length - 1][0];
    }

    function getRecentPlayerMoveBias() {
      const counts = { R: 0, P: 0, S: 0 };
      const recent = historyLog.slice(-5);
      recent.forEach(entry => { counts[entry.yourMove] += 1; });

      if (lastYourMove) counts[lastYourMove] += 1;

      const topMove = ROCK_MOVES.reduce((best, move) => counts[move] > counts[best] ? move : best, "R");
      return { counts, topMove, topCount: counts[topMove] };
    }

    function getMoveFromProfile(profileName, scriptMove) {
      const fallback = scriptMove || "R";
      const recent = historyLog.slice(-3);
      if (profileName === AI_PROFILES.random) {
        return ROCK_MOVES[Math.floor((rngGame ? rngGame() : Math.random()) * ROCK_MOVES.length)] || fallback;
      }
      if (profileName === AI_PROFILES.antiRepeat) {
        const antiRepeatWeights = { R: 1, P: 1, S: 1 };
        if (lastYourMove) antiRepeatWeights[beats[lastYourMove]] += 2.4;
        return weightedRandomMove(antiRepeatWeights);
      }
      if (profileName === AI_PROFILES.antiStreak) {
        const streakWeights = { R: 1, P: 1, S: 1, [fallback]: 1.2 };
        const chain = historyLog.slice(-2);
        const sameMoveChain = chain.length === 2 && chain.every(entry => entry.yourMove === chain[0].yourMove);
        if (sameMoveChain) streakWeights[beats[chain[0].yourMove]] += 2.8;
        const winChain = recent.length >= 2 && recent.every(entry => entry.outcome === "win");
        if (winChain && lastYourMove) streakWeights[beats[lastYourMove]] += 1.4;
        return weightedRandomMove(streakWeights);
      }
      if (profileName === AI_PROFILES.delayedCounter) {
        const delayedWeights = { R: 1, P: 1, S: 1, [fallback]: 0.9 };
        const lagMove = historyLog.length >= 2 ? historyLog[historyLog.length - 2].yourMove : lastYourMove;
        if (lagMove) delayedWeights[beats[lagMove]] += 2.5;
        return weightedRandomMove(delayedWeights);
      }
      if (profileName === AI_PROFILES.fakeOut) {
        const { topMove } = getRecentPlayerMoveBias();
        const counterTrend = beats[topMove];
        const fakeCounter = beats[counterTrend];
        const fakeWeights = { R: 1, P: 1, S: 1, [fallback]: 1.1 };
        fakeWeights[fakeCounter] += 2.2;
        if (lastYourMove) fakeWeights[beats[lastYourMove]] += 0.8;
        return weightedRandomMove(fakeWeights);
      }
      return fallback;
    }

    function getRockMoveForRound() {
      const scriptMove = scriptedSequenceOverride ? scriptedSequenceOverride[currentRound] : seededScriptSequence[currentRound];

      if (currentRound === 0) {
        lastDecisionAdaptive = false;
        return "R";
      }

      const enemy = getActiveEnemy();
      const activeProfile = getEnemyProfileForRound(enemy);
      runState.currentEnemyProfile = activeProfile;

      const adaptive = adaptiveToggle.checked;
      if (!adaptive || !lastYourMove) {
        lastDecisionAdaptive = false;
        return getMoveFromProfile(activeProfile, scriptMove);
      }

      const r = rngGame ? rngGame() : Math.random();
      if (r < moodAdaptChance()) {
        lastDecisionAdaptive = true;
        adaptiveAttempts += 1;
        return getMoveFromProfile(activeProfile, scriptMove);
      }

      lastDecisionAdaptive = false;
      return scriptMove;
    }

    function isGameActive() { return !isRunComplete() && !moveButtons[0].disabled; }

    async function playRound(yourMove) {
      if (isRunComplete()) return;
      if (roundPhase !== "idle") return;
      if (hasCurse("repeated-hand-lock") && runState.curseState.lockoutRoundsRemaining > 0 && runState.curseState.lockoutMove === yourMove) {
        const lockedName = names[yourMove] || yourMove;
        commentaryEl.textContent = `Curse trigger: Hand Lock prevents ${lockedName} this round. Choose a different hand.`;
        resultLineEl.textContent = `Hand Lock blocked ${lockedName}.`;
        resultLineEl.className = "result-line result-lose";
        showRoundResultOverlay(`Curse trigger: Hand Lock blocked ${lockedName}.`);
        return;
      }
      setScene("inRound");
      if (adaptiveToggle.checked) adaptiveEverOnThisRun = true;
      roundAnimationToken += 1;
      const phaseToken = roundAnimationToken;

      setRoundPhase("lockIn");
      setButtonsEnabled(false);
      const roundEnemy = getActiveEnemy();
      resultLineEl.textContent = `${roundEnemy.title} is choosing...`;
      resultLineEl.className = "result-line";
      commentaryEl.textContent = `${roundEnemy.name} is choosing...`;

      resetArenaPhaseClasses();
      arenaEl.classList.add("phase-lock-in");
      await waitForPhase(ROUND_PHASE_DELAYS.lockIn);
      if (phaseToken !== roundAnimationToken) return;
      arenaEl.classList.remove("phase-lock-in");

      setRoundPhase("anticipation");
      arenaEl.classList.add("phase-anticipation");
      playUiPip("anticipation");
      await waitForPhase(ROUND_PHASE_DELAYS.anticipation);
      if (phaseToken !== roundAnimationToken) return;
      arenaEl.classList.remove("phase-anticipation");

      const moodBefore = rockMood;
      const rockMove = getRockMoveForRound();
      lastYourMove = yourMove;

      setRoundPhase("reveal");
      arenaEl.classList.add("phase-reveal");

      rockHandEl.textContent = glyph[rockMove];
      rockMoveLabelEl.textContent = names[rockMove];
      rockHandEl.classList.remove("reveal-pop");
      void rockHandEl.offsetWidth;
      rockHandEl.classList.add("reveal-pop");
      await waitForPhase(ROUND_PHASE_DELAYS.revealRock);
      if (phaseToken !== roundAnimationToken) return;

      yourHandEl.textContent = glyph[yourMove];
      yourMoveLabelEl.textContent = names[yourMove];
      yourHandEl.classList.remove("reveal-pop");
      void yourHandEl.offsetWidth;
      yourHandEl.classList.add("reveal-pop");
      await waitForPhase(ROUND_PHASE_DELAYS.revealYou);
      if (phaseToken !== roundAnimationToken) return;

      setRoundPhase("resolved");

      const beatRockMove = beats[rockMove];
      beatRockAbbrevs.push(names[beatRockMove][0]);

      let outcome;
      if (yourMove === rockMove) outcome = "draw";
      else if (beats[rockMove] === yourMove) outcome = "win";
      else outcome = "lose";

      const activeNode = getActiveNode();
      const curseTriggers = [];
      if (hasCurse("first-draw-loss") && outcome === "draw") {
        const nodeKey = activeNode ? activeNode.id : currentRound;
        if (!runState.curseState.firstDrawLossUsedNodes[nodeKey]) {
          runState.curseState.firstDrawLossUsedNodes[nodeKey] = true;
          outcome = "lose";
          curseTriggers.push("Rigged Opener triggered: first draw became a loss");
        }
      }
      if (hasCurse("repeated-hand-lock") && historyLog.length > 0 && historyLog[historyLog.length - 1].yourMove === yourMove) {
        runState.curseState.lockoutMove = yourMove;
        runState.curseState.lockoutRoundsRemaining = 2;
        curseTriggers.push(`Hand Lock triggered: ${names[yourMove]} is locked next round`);
      }
      const previousEntry = historyLog[historyLog.length - 1] || null;
      const preWinStreak = (() => {
        let streak = 0;
        for (let i = historyLog.length - 1; i >= 0; i -= 1) {
          if (historyLog[i].outcome !== "win") break;
          streak += 1;
        }
        return streak;
      })();
      const scoreContext = {
        round: currentRound + 1,
        nodeIndex: activeNode ? activeNode.index : currentRound + 1,
        nodeType: activeNode ? activeNode.type : "normal",
        isFinalNode: currentRound + 1 >= getTotalNodes(),
        moodBefore,
        yourMove,
        rockMove,
        outcome,
        baseOutcome: outcome,
        previousOutcome: previousEntry ? previousEntry.outcome : null,
        preWinStreak,
        preScoreDiff: youScore - rockScore,
        prevNodeWasHighTier: previousEntry ? (previousEntry.nodeType === "elite" || previousEntry.nodeType === "boss") : false,
        alternatedHand: !!(previousEntry && previousEntry.yourMove !== yourMove),
        beatsOwnLastMove: !!(previousEntry && beats[previousEntry.yourMove] === yourMove),
        repeatedPairFromLastRound: !!(previousEntry && previousEntry.yourMove === yourMove && previousEntry.rockMove === rockMove),
        lastDecisionAdaptive,
        adaptiveReadCorrect: lastDecisionAdaptive && (beats[yourMove] === rockMove),
        youDelta: outcome === "win" ? 1 : 0,
        rockDelta: outcome === "lose" ? 1 : 0,
        drawDelta: outcome === "draw" ? 1 : 0
      };

      const relicFeedback = applyRelicEffects(scoreContext);
      if (scoreContext.nodeType === "boss" && runState.unlockedBossVariant === "obsidian-headliner" && scoreContext.baseOutcome === "lose") {
        scoreContext.rockDelta += 1;
        relicFeedback.push("Obsidian Headliner pressure +1");
      }
      if (scoreContext.baseOutcome === "lose" && runState.skipNextLossPenalty) {
        scoreContext.rockDelta = 0;
        runState.skipNextLossPenalty = false;
        relicFeedback.push("Event ward negated loss penalty");
      }
      if (scoreContext.baseOutcome === "win" && hasCurse("first-draw-loss") && scoreContext.youDelta > 0) {
        // no direct score penalty; this curse only alters first draw outcomes
      }
      if (scoreContext.baseOutcome === "win" && runState.relicUpgradeLevel > 0 && relicFeedback.length > 0) {
        scoreContext.youDelta += runState.relicUpgradeLevel;
        relicFeedback.push(`Relic aura +${runState.relicUpgradeLevel}`);
      }

      let rewardCash = scoreContext.baseOutcome === "win" ? (RUN_BALANCE.rewardCashOnWin[scoreContext.nodeType] || 0) : 0;
      if (rewardCash > 0 && hasCurse("normal-reward-drain") && scoreContext.nodeType === "normal") {
        rewardCash = Math.max(0, rewardCash - 1);
        curseTriggers.push("Thin Purse triggered: normal reward reduced by $1");
      }
      if (rewardCash > 0) {
        runState.cash += rewardCash;
        relicFeedback.push(`Cash +$${rewardCash}`);
      }

      let resolvePenalty = scoreContext.baseOutcome === "lose" ? (RUN_BALANCE.loseResolvePenalty[scoreContext.nodeType] || 0) : 0;
      if (resolvePenalty > 0 && runState.consumableShieldCharges > 0) {
        runState.consumableShieldCharges -= 1;
        resolvePenalty = 0;
        relicFeedback.push("Smoke Tonic blocked resolve loss");
      }
      if (resolvePenalty > 0) {
        runState.resolve = clampResolve(runState.resolve - resolvePenalty);
        relicFeedback.push(`Resolve -${resolvePenalty}`);
      }

      outcome = scoreContext.outcome;
      youScore += scoreContext.youDelta;
      rockScore += scoreContext.rockDelta;
      draws += scoreContext.drawDelta;

      if (outcome === "draw") {
        resultLineEl.textContent = "Round result: draw.";
        resultLineEl.className = "result-line result-draw";
        playBeep("draw");
      } else if (outcome === "win") {
        resultLineEl.textContent = "Round result: you win.";
        resultLineEl.className = "result-line result-win";
        playBeep("win");
        shakeArena();
      } else {
        resultLineEl.textContent = `Round result: ${getActiveEnemy().title} wins.`;
        resultLineEl.className = "result-line result-lose";
        playBeep("lose");
      }
      applyOutcomeCamera(outcome);
      triggerArenaWash(outcome);

      if (lastDecisionAdaptive && beats[yourMove] === rockMove) adaptiveCorrectReads += 1;

      const beatRockThisRound = yourMove === beatRockMove;
      if (beatRockThisRound) beatRockHits += 1;

      updateRockMood(outcome);
      renderEnemyArenaIntel();
      updateMoodDisplay();
      advanceTutorialOnAction("moodDisplay");

      const comboCallouts = getComboCallouts(outcome, relicFeedback);
      const triggerLine = relicFeedback.length > 0 ? ` Relic trigger: ${relicFeedback.join(" ¬∑ ")}.` : "";
      const curseLine = curseTriggers.length > 0 ? ` Curse trigger: ${curseTriggers.join(" ¬∑ ")}.` : "";
      const comboLine = comboCallouts.length > 0 ? ` Combo callout: ${comboCallouts.join(" ¬∑ ")}.` : "";
      commentaryEl.textContent = describeRound(outcome, beatRockThisRound) + triggerLine + curseLine + comboLine;

      historyLog.push({
        round: currentRound + 1,
        nodeIndex: activeNode ? activeNode.index : currentRound + 1,
        nodeType: activeNode ? activeNode.type : "normal",
        rockMove, yourMove, beatRockMove,
        outcome,
        baseOutcome: scoreContext.baseOutcome,
        scoreDelta: { you: scoreContext.youDelta, rock: scoreContext.rockDelta, draws: scoreContext.drawDelta },
        relicFeedback,
        curseTriggers,
        adaptiveUsed: lastDecisionAdaptive,
        adaptiveCorrect: lastDecisionAdaptive && (beats[yourMove] === rockMove),
        mood: moodBefore,
        enemyId: runState.activeEnemyId,
        enemyProfile: runState.currentEnemyProfile,
        enemyPhase: runState.currentEnemyPhase,
        beatRockThisRound,
        eventDecision: runState.eventLog.find(log => log.nodeId === (activeNode ? activeNode.id : -1)) || null
      });

      renderDebugLog();

      const completedNode = getActiveNode();
      if (completedNode) {
        runState.completedNodeIds.push(completedNode.id);
        runState.availableNodeIds = completedNode.next.slice();
      }
      maybeRevealUpcomingRewards();

      currentRound += 1;
      if (runState.curseState.lockoutRoundsRemaining > 0) runState.curseState.lockoutRoundsRemaining -= 1;
      if (runState.resolve <= 0) runState.runFailed = true;
      if (!isRunComplete() && runState.availableNodeIds.length > 0) runState.activeNodeId = null;
      renderMapPanel();
      renderRoundBoard();
      updateScoreLabel();
      updateResourceLabels();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateRunSummary();
      updatePreRoundHint();
      evaluateAchievements();

      const comboCalloutText = comboCallouts.length ? ` Combos: ${comboCallouts.join(", ")}.` : "";
      const overlayText = `${outcome === "win" ? "Round result: you win." : outcome === "lose" ? "Round result: The Rock wins." : "Round result: draw."}${relicFeedback.length ? ` Relics: ${relicFeedback.join(", ")}.` : ""}${curseTriggers.length ? ` Curses: ${curseTriggers.join(", ")}.` : ""}${comboCalloutText}`;
      showRoundResultOverlay(overlayText);

      if (isRunComplete()) {
        setButtonsEnabled(false);
        const koTitle = runState.runFailed || rockScore > youScore ? "KO ¬∑ The Rock stands tall" : youScore > rockScore ? "KO ¬∑ You steal the spotlight" : "Time limit draw ¬∑ No KO";
        await showCinematicCard({ tier: "ko", tag: "End card", title: koTitle, body: `Final score ${youScore}-${rockScore}-${draws}.` });
        showFinalSummary();
        resetArenaPhaseClasses();
        setRoundPhase("idle");
        return;
      }

      await waitForPhase(ROUND_PHASE_DELAYS.resolved);
      if (phaseToken !== roundAnimationToken) return;
      resetArenaPhaseClasses();
      setRoundPhase("idle");
      if (runState.availableNodeIds.length > 0) {
        if (activeNode && activeNode.type === "elite" && outcome === "win") {
          const eliteCurseRoll = mixSeed("elite-curse", activeNode.id, currentRound, youScore, rockScore) % 100;
          if (eliteCurseRoll < 35) {
            const eliteCurse = gainRandomCurse(activeNode.id, "elite-win");
            if (eliteCurse) {
              commentaryEl.textContent = `${commentaryEl.textContent} Elite backlash: gained curse ${eliteCurse.name}.`;
              showRoundResultOverlay(`Curse gained from elite backlash: ${eliteCurse.name}.`);
            }
          }
        }
        const showedRelicChoice = maybeShowRelicChoice(activeNode ? activeNode.type : "normal", outcome === "win");
        if (!showedRelicChoice) {
          setScene("map");
          setButtonsEnabled(false);
          await maybeAutoEnterSoloNode();
        } else {
          setButtonsEnabled(false);
        }
      } else {
        setButtonsEnabled(true);
      }
    }

    function evaluateAchievements() {
      const newlyUnlocked = getUnlockedAchievementDefs();
      newlyUnlocked.forEach(achievement => {
        if (announcedAchievements.has(achievement.id)) return;
        announcedAchievements.add(achievement.id);

        const currentCount = achievementUnlockCounts[achievement.id] || 0;
        const nextCount = currentCount + 1;
        achievementUnlockCounts[achievement.id] = nextCount;
        savePersistentAchievements();
        showAchievementToast(achievement, nextCount);
      });
      if (newlyUnlocked.length > 0) openDrawerPanel(achievementsPanelEl, { highlight: true });
      renderAchievements();
    }

    function showAchievementToast(achievement, count) {
      const toast = document.createElement("div");
      toast.className = "achievement-toast rank-" + achievement.rank;
      toast.innerHTML = `<strong>Achievement unlocked x${count}:</strong> ${achievement.name}<br />${achievement.text}`;
      achievementToastsEl.appendChild(toast);
      setTimeout(() => {
        toast.style.opacity = "0";
        toast.style.transform = "translateX(10px)";
        setTimeout(() => toast.remove(), 260);
      }, 2600);
    }

    function renderAchievements() {
      achievementsListEl.innerHTML = "";
      const earned = achievementCatalog.filter(a => (achievementUnlockCounts[a.id] || 0) > 0);

      if (earned.length === 0) {
        achievementsListEl.textContent = "No achievements earned yet. Start a run and unlock one to reveal it here.";
        return;
      }

      earned.forEach(a => {
        const count = achievementUnlockCounts[a.id] || 0;
        const div = document.createElement("div");
        div.className = "achievement-badge rank-" + a.rank;
        div.innerHTML = `<span class="achievement-multiplier">x${count}</span><strong>${a.name}</strong><br />${a.text}`;
        achievementsListEl.appendChild(div);
      });
    }

    function calculateRunHighlights() {
      const achievementState = buildAchievementState();
      const moodPressureMoments = historyLog.filter(entry => entry.mood === "Suspicious" || entry.mood === "Paranoid").length;
      const beatRockRate = historyLog.length > 0 ? Math.round((beatRockHits / historyLog.length) * 100) : 0;
      return { achievementState, moodPressureMoments, beatRockRate };
    }

    function renderPostMatchSummary() {
      const { achievementState, moodPressureMoments, beatRockRate } = calculateRunHighlights();
      const runAchievements = getUnlockedAchievementDefs();
      const youWon = youScore > rockScore;
      const rockWon = rockScore > youScore;
      const defeated = runState.runFailed;

      summaryWinnerBannerEl.className = "post-match-banner";
      if (defeated) {
        const remainingNodes = Math.max(0, getTotalNodes() - currentRound);
        summaryWinnerBannerEl.classList.add("rock-win");
        summaryWinnerBannerEl.textContent = "Defeat: Resolve broken";
        summaryTitleEl.textContent = "You were worn down before the final bell";
        summaryFlavorEl.textContent = `Resolve hit zero with ${remainingNodes} node${remainingNodes === 1 ? "" : "s"} still ahead. Reload, reroute, and come back richer.`;
      } else if (youWon) {
        summaryWinnerBannerEl.classList.add("you-win");
        summaryWinnerBannerEl.textContent = "Winner: You";
        summaryTitleEl.textContent = "You beat The Rock";
        summaryFlavorEl.textContent = "You out-read The Rock across the full node path. Queue the rematch before he rewrites the script.";
      } else if (rockWon) {
        summaryWinnerBannerEl.classList.add("rock-win");
        summaryWinnerBannerEl.textContent = "Winner: The Rock";
        summaryTitleEl.textContent = "The Rock holds the spotlight";
        summaryFlavorEl.textContent = "He held the line this run. New seed, new plan, same arena when you hit Play Again.";
      } else {
        summaryWinnerBannerEl.classList.add("draw-match");
        summaryWinnerBannerEl.textContent = "Result: Draw";
        summaryTitleEl.textContent = "Even score at the final bell";
        summaryFlavorEl.textContent = "Nobody blinked. One more run decides who owns this timeline.";
      }

      summaryBestStreakEl.textContent = `${achievementState.maxWinStreak} win${achievementState.maxWinStreak === 1 ? "" : "s"}`;
      summaryBeatRockRateEl.textContent = `${beatRockRate}% (${beatRockHits}/${historyLog.length || getTotalNodes()})`;
      summaryMoodPressureEl.textContent = `${moodPressureMoments} rounds`;

      summaryEventListEl.innerHTML = "";
      if (!runState.eventLog.length) {
        summaryEventFlavorEl.textContent = "No event decisions logged this run.";
      } else {
        summaryEventFlavorEl.textContent = runState.unlockedBossVariant ? `Rare chain complete: ${runState.unlockedBossVariant}.` : "Event decisions logged for this seeded path.";
        runState.eventLog.forEach(eventEntry => {
          const li = document.createElement("li");
          li.textContent = `Node ${eventEntry.nodeIndex}: ${eventEntry.detail}`;
          summaryEventListEl.appendChild(li);
        });
      }

      summaryAchievementsListEl.innerHTML = "";
      if (runAchievements.length === 0) {
        summaryAchievementsListEl.classList.add("is-hidden");
        summaryAchievementsEmptyEl.classList.remove("is-hidden");
      } else {
        summaryAchievementsListEl.classList.remove("is-hidden");
        summaryAchievementsEmptyEl.classList.add("is-hidden");
        runAchievements.forEach(achievement => {
          const li = document.createElement("li");
          li.textContent = achievement.name;
          summaryAchievementsListEl.appendChild(li);
        });
      }

      summaryUnlockListEl.innerHTML = "";
      if (!latestProfileUnlocks.length) {
        summaryUnlocksEl.classList.add("is-hidden");
      } else {
        summaryUnlocksEl.classList.remove("is-hidden");
        latestProfileUnlocks.forEach(text => {
          const li = document.createElement("li");
          li.textContent = text;
          summaryUnlockListEl.appendChild(li);
        });
      }
    }

    function jumpToRoundBoardFromSummary() {
      setScene("inRound");
      openDrawerPanel(statsPanelEl, { highlight: true });
      if (historyLog.length > 0) handleRoundBoardHover(historyLog.length - 1);
      roundBoardEl.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "center" });
    }

    function showFinalSummary() {
      const summaryLines = [];
      summaryLines.push(`Final score after ${getTotalNodes()} nodes: The Rock ${rockScore}, You ${youScore}, Draws ${draws}.`);
      summaryLines.push(`Resources: Resolve ${runState.resolve}/${runState.maxResolve}, Cash $${runState.cash}.`);
      summaryLines.push(runState.activeCurses.length ? `Active curses at finish: ${runState.activeCurses.map(id => (curseCatalog.find(c => c.id === id)?.name || id)).join(", ")}.` : "No active curses at finish.");
      if (runState.runFailed) summaryLines.push(`Defeat condition triggered: resolve dropped to zero at node ${currentRound}.`);
      summaryLines.push(`You beat The Rock ${beatRockHits} out of ${getTotalNodes()} nodes.`);
      summaryLines.push(`Beat-The-Rock sequence for this showdown: ${beatRockAbbrevs.join(" ")}.`);
      summaryLines.push(`Legend: R Rock, P Paper, S Scissors.`);

      if (adaptiveEverOnThisRun && adaptiveAttempts > 0) {
        const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
        summaryLines.push(`Adaptive Rock made ${adaptiveAttempts} read attempts, with ${adaptiveCorrectReads} correct, accuracy ${acc} percent.`);
      }

      if (adaptiveEverOnThisRun && historyLog.length === 20) {
        const adaptiveSequence = historyLog.map(entry => entry.rockMove);
        const replaySeed = sequenceToReplaySeed(adaptiveSequence);
        if (replaySeed !== null) {
          seedInputEl.value = String(replaySeed);
          seedFeedbackEl.className = "seed-feedback info";
          seedFeedbackEl.textContent = `Adaptive replay seed generated: ${replaySeed}. Start a new showdown to replay this sequence in scripted mode.`;
          summaryLines.push(`Replay seed generated for this adaptive sequence, ${replaySeed}.`);
        } else {
          summaryLines.push("Could not generate a scripted replay seed for this adaptive sequence.");
        }
      }

      const runAchievements = getUnlockedAchievementDefs();
      if (runAchievements.length > 0) summaryLines.push(`Achievements unlocked this run, ${runAchievements.map(a => a.name).join(", ")}.`);
      else summaryLines.push("No achievements this time, try different seeds or adaptive settings.");
      const historyEventDetails = historyLog.filter(entry => entry.eventDecision).map(entry => `Node ${entry.nodeIndex}: ${entry.eventDecision.detail}`);
      if (historyEventDetails.length > 0) {
        summaryLines.push(`Event decisions this run, ${historyEventDetails.join(" | ")}.`);
      } else summaryLines.push("No event decisions were logged this run.");
      if (runState.unlockedBossVariant) summaryLines.push(`Rare chain complete: unlocked boss variant ${runState.unlockedBossVariant}.`);

      if (runState.activeRelics.length > 0) {
        const relicNames = runState.activeRelics.map(relicState => {
          const relic = relicCatalog.find(entry => entry.id === relicState.id);
          return relic ? relic.name : relicState.id;
        });
        summaryLines.push(`Relics drafted this run, ${relicNames.join(", ")}.`);
      } else {
        summaryLines.push("No relics were drafted this run.");
      }

      latestProfileUnlocks = applyProfileProgressFromRun();
      challengeRunHash = computeChallengeRunHash();
      summaryLines.push(`Challenge validation hash: ${challengeRunHash}.`);
      saveRunToModeStats();
      const modeStats = loadModeStats(challengeMode);
      summaryLines.push(`Mode stats (${challengeMode}): runs ${modeStats.runs}, wins ${modeStats.wins}, losses ${modeStats.losses}, draws ${modeStats.draws}.`);
      summaryLines.push("Use the unified round board or round log to review every move and state.");
      commentaryEl.textContent = summaryLines.join(" ");

      renderAchievements();
      openDrawerPanel(statsPanelEl);
      openDrawerPanel(achievementsPanelEl, { highlight: true });
      if (historyLog.length > 0) handleRoundBoardHover(historyLog.length - 1);
      resetBtn.style.display = "none";
      renderPostMatchSummary();
      setScene("matchSummary");
      latestProfileUnlocks.forEach((text, idx) => {
        setTimeout(() => {
          const toast = document.createElement("div");
          toast.className = "achievement-toast";
          toast.innerHTML = `<strong>New unlock:</strong> ${text}`;
          achievementToastsEl.appendChild(toast);
          setTimeout(() => { toast.style.opacity = "0"; toast.style.transform = "translateX(10px)"; setTimeout(() => toast.remove(), 260); }, 3200);
        }, idx * 250);
      });
    }

    function initFromSeed(seed, manualFlag, scriptOverride, initialRelics = [], initialCurses = []) {
      runSeed = seed >>> 0;
      seedWasManual = !!manualFlag;
      scriptedSequenceOverride = scriptOverride || null;
      seededScriptSequence = generateSeededScriptSequence(runSeed);
      runState.unlockedBossVariant = null;
      runState.mapNodes = generateRunMap(runSeed);
      runState.nodeEnemyAssignments = assignEnemiesToNodes(runState.mapNodes, runSeed);
      runState.activeEnemyId = ENEMY_DEFINITIONS.graniteRookie.id;
      runState.currentEnemyPhase = null;
      runState.currentEnemyProfile = AI_PROFILES.random;
      runState.phaseAnnouncement = "";
      runState.selectedPath = [];
      runState.availableNodeIds = [0];
      runState.activeNodeId = null;
      runState.completedNodeIds = [];
      runState.eventLog = [];
      runState.pendingEvent = null;
      runState.skipNextLossPenalty = false;
      runState.revealNextNodeReward = false;
      runState.revealedNodeRewards = {};
      runState.activeCurses = initialCurses.slice();
      runState.curseState = {
        firstDrawLossUsedNodes: {},
        lockoutMove: null,
        lockoutRoundsRemaining: 0,
        normalRewardPenaltyUsedNodes: {}
      };
      runState.rareChainStage = 0;
      runState.resolve = RUN_BALANCE.startingResolve;
      runState.maxResolve = RUN_BALANCE.startingResolve;
      runState.cash = RUN_BALANCE.startingCash;
      runState.consumableShieldCharges = 0;
      runState.relicUpgradeLevel = 0;
      runState.runFailed = false;
      if (challengeMode === "weekly") applyWeeklyMutators();
      runState.activeRelics = initialRelics
        .filter(id => relicCatalog.some(relic => relic.id === id))
        .map(id => ({ id, used: false }));

      rngGame = mulberry32(runSeed);
      rngFlavor = mulberry32(runSeed ^ 0x9E3779B9);

      if (scriptedSequenceOverride) {
        adaptiveToggle.checked = false;
      }

      currentRound = 0;
      youScore = 0;
      rockScore = 0;
      draws = 0;
      beatRockHits = 0;
      beatRockAbbrevs = [];
      lastYourMove = null;

      adaptiveAttempts = 0;
      adaptiveCorrectReads = 0;
      adaptiveEverOnThisRun = false;
      lastDecisionAdaptive = false;

      rockMood = "Calm";
      rockLossStreak = 0;

      historyLog = [];
      announcedNodeCards.clear();
      debugLogEl.innerHTML = "";
      announcedAchievements = new Set();
      latestProfileUnlocks = [];
      achievementToastsEl.innerHTML = "";
      renderAchievements();

      rockHandEl.textContent = "‚ùî";
      yourHandEl.textContent = "‚ùî";
      rockMoveLabelEl.textContent = "Awaiting the opening bell.";
      yourMoveLabelEl.textContent = "Pick your opening throw.";
      resultLineEl.textContent = "";
      resultLineEl.className = "result-line";
      commentaryEl.textContent = "";
      renderEnemyArenaIntel();

      createRoundBoardCells();
      renderRoundBoard();
      renderRelicStrip();
      renderCurseHud();
      renderEventPanel();
      relicChoicePanelEl.classList.add("is-hidden");
      roundBoardPreviewEl.textContent = "Hover, focus, or tap a played node to preview exact hands, outcome, and mood.";

      updateScoreLabel();
      updateResourceLabels();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateMoodDisplay();
      updatePreRoundHint();
      updateRunSummary();
      updateChallengeRulesUI();

      if (scriptedSequenceOverride) {
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = "Scripted challenge loaded from a shared adaptive showdown. Adaptive mode is locked for exact replay.";
      }

      statsPanelEl.open = true;
      achievementsPanelEl.open = false;
      replaySeedPanelEl.open = false;
      debugPanelEl.open = false;
      setButtonsEnabled(false);
      resetBtn.style.display = "none";
      roundResultOverlayEl.classList.add("is-hidden");
      if (roundResultTimer) {
        clearTimeout(roundResultTimer);
        roundResultTimer = null;
      }
      roundAnimationToken += 1;
      setRoundPhase("idle");
      resetArenaPhaseClasses();
      renderMapPanel();
      setScene("lobby");
    }

    function resetGame() {
      if (challengeMode === "daily") {
        challengeContext = { utcDateKey: getUtcDateKey() };
        initFromSeed(deriveDailySeed(), false, null, [], []);
        return;
      }
      if (challengeMode === "weekly") {
        const weekly = deriveWeeklyMutatorSet();
        activeWeeklyMutatorSet = weekly.mutators.slice();
        challengeContext = { weekLabel: `${weekly.info.isoYear}-W${String(weekly.info.isoWeek).padStart(2, "0")}` };
        initFromSeed((hashStringFNV1a(`weekly-seed:${challengeContext.weekLabel}`) ^ 0xA5A5A5A5) >>> 0, false, null, [], []);
        return;
      }
      const value = seedInputEl.value.trim();
      let newSeed;
      let manual = false;

      if (value === "") {
        newSeed = generateRandomSeed();
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = `Randomized seed for this showdown: ${newSeed}.`;
      } else {
        const normalizedSeed = normalizeSeed(value);
        if (!normalizedSeed.valid) {
          seedFeedbackEl.className = "seed-feedback error";
          seedFeedbackEl.textContent = "Invalid seed. Use digits only (0‚Äì4294967295).";
          return;
        }

        newSeed = normalizedSeed.seed;
        manual = true;

        seedFeedbackEl.className = "seed-feedback info";
        if (normalizedSeed.clamped) seedFeedbackEl.textContent = `Seed clamped to unsigned 32-bit range. Starting showdown with normalized seed ${newSeed}.`;
        else seedFeedbackEl.textContent = `Starting showdown with normalized seed ${newSeed}.`;
      }

      initFromSeed(newSeed, manual, null, [], []);
    }


    function startChallengeMode(mode) {
      challengeMode = mode;
      if (mode === "daily") {
        challengeContext = { utcDateKey: getUtcDateKey() };
        activeWeeklyMutatorSet = [];
        adaptiveToggle.checked = false;
        initFromSeed(deriveDailySeed(), false, null, [], []);
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = `Daily challenge loaded for ${challengeContext.utcDateKey}. Seed locked to ${runSeed}.`;
      } else if (mode === "weekly") {
        const weekly = deriveWeeklyMutatorSet();
        activeWeeklyMutatorSet = weekly.mutators.slice();
        challengeContext = { weekLabel: `${weekly.info.isoYear}-W${String(weekly.info.isoWeek).padStart(2, "0")}` };
        initFromSeed((hashStringFNV1a(`weekly-seed:${challengeContext.weekLabel}`) ^ 0xA5A5A5A5) >>> 0, false, null, [], []);
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = `Weekly challenge loaded for ${challengeContext.weekLabel}. Mutators: ${activeWeeklyMutatorSet.map(m => m.name).join(", ")}.`;
      } else {
        challengeMode = "casual";
        activeWeeklyMutatorSet = [];
        challengeContext = {};
        updateChallengeRulesUI();
      }
    }

    startMatchBtn.addEventListener("click", async () => {
      ensureAudioContext();
      syncAudioMix();

      if (runState.activeNodeId === null) {
        runState.availableNodeIds = [0];
        renderMapPanel();
      }

      setScene("map");
      setButtonsEnabled(false);
      updateRunSummary();

      if (runState.activeNodeId === null) {
        await maybeAutoEnterSoloNode();
      }
    });

    moveButtons.forEach(btn => btn.addEventListener("click", () => {
      if (!isGameActive()) return;
      advanceTutorialOnAction("moveButtons");
      playUiPip("confirm");
      playRound(btn.getAttribute("data-move"));
    }));

    resetBtn.addEventListener("click", resetGame);
    summaryPlayAgainBtn.addEventListener("click", resetGame);
    summaryCopyLinkBtn.addEventListener("click", copyChallengeLink);
    copyResultBtn.addEventListener("click", copyChallengeResult);
    summaryCopyResultBtn.addEventListener("click", copyChallengeResult);
    summaryViewBoardBtn.addEventListener("click", jumpToRoundBoardFromSummary);
    casualModeBtn.addEventListener("click", () => startChallengeMode("casual"));
    dailyModeBtn.addEventListener("click", () => startChallengeMode("daily"));
    weeklyModeBtn.addEventListener("click", () => startChallengeMode("weekly"));
    randomSeedBtn.addEventListener("click", () => {
      const generatedSeed = generateRandomSeed();
      seedInputEl.value = String(generatedSeed);
      seedFeedbackEl.className = "seed-feedback info";
      seedFeedbackEl.textContent = `Generated seed ${generatedSeed}. Start a new showdown to use it.`;
    });
    resetAchievementsBtn.addEventListener("click", () => {
      resetPersistentAchievements();
      seedFeedbackEl.className = "seed-feedback info";
      seedFeedbackEl.textContent = "Achievements reset for this browser profile.";
    });
    resetProfileBtn.addEventListener("click", () => {
      profileState = getDefaultProfileState();
      saveProfileState();
      renderProfileUI();
      seedFeedbackEl.className = "seed-feedback info";
      seedFeedbackEl.textContent = "Profile progression reset for this browser profile.";
    });
    adaptiveToggle.addEventListener("change", () => { advanceTutorialOnAction("adaptiveToggle"); updateAdaptiveStats(); updateMoodDisplay(); updatePreRoundHint(); updateRunSummary(); });
    moodDisplayEl.addEventListener("click", () => advanceTutorialOnAction("moodDisplay"));
    sfxToggle.addEventListener("change", () => { sfxEnabled = sfxToggle.checked; ensureAudioContext(); syncAudioMix(); playUiPip("hover"); });
    ambientVolEl.addEventListener("input", () => { ambientVolume = Number(ambientVolEl.value) / 100; ensureAudioContext(); syncAudioMix(); });
    confirmVolEl.addEventListener("input", () => { confirmVolume = Number(confirmVolEl.value) / 100; ensureAudioContext(); syncAudioMix(); });
    uiVolEl.addEventListener("input", () => { uiVolume = Number(uiVolEl.value) / 100; ensureAudioContext(); syncAudioMix(); playUiPip("hover"); });
    copyLinkBtn.addEventListener("click", () => {
      advanceTutorialOnAction("seedShare");
      copyChallengeLink();
    });
    seedInputEl.addEventListener("focus", () => advanceTutorialOnAction("seedShare"));
    randomSeedBtn.addEventListener("click", () => advanceTutorialOnAction("seedShare"));
    replayTutorialBtn.addEventListener("click", () => {
      closeGameMenu();
      startTutorial({ replay: true });
    });
    tutorialSkipBtn.addEventListener("click", completeTutorial);
    window.addEventListener("resize", () => { if (tutorialActive) renderTutorialStep(); });
    window.addEventListener("scroll", () => { if (tutorialActive) renderTutorialStep(); }, { passive: true });
    gameMenuBtn.addEventListener("click", openGameMenu);
    closeMenuBtn.addEventListener("click", closeGameMenu);
    gameMenuModal.addEventListener("click", (event) => {
      if (event.target === gameMenuModal) closeGameMenu();
    });

    document.addEventListener("keydown", async e => {
      if (e.key === "Escape" && gameMenuModal.classList.contains("is-active")) {
        closeGameMenu();
        return;
      }
      if (!isGameActive()) await maybeAutoEnterSoloNode();
      if (!isGameActive()) return;
      if (isModalInputFocused(e.target)) return;
      const targetTag = e.target && e.target.tagName ? e.target.tagName : "";
      if (["INPUT", "TEXTAREA", "SELECT"].includes(targetTag)) return;
      const key = e.key.toLowerCase();
      if (key === "r") playRound("R");
      else if (key === "p") playRound("P");
      else if (key === "s") playRound("S");
    });

    profileState = loadProfileState();
    renderProfileUI();

    achievementUnlockCounts = loadPersistentAchievements();
    achievementCatalog.forEach(a => { if (!Number.isInteger(achievementUnlockCounts[a.id]) || achievementUnlockCounts[a.id] < 0) achievementUnlockCounts[a.id] = 0; });

    const initialSettings = readInitialSettingsFromUrl();
    seedInputEl.value = String(DEFAULT_SEED);
    if (initialSettings.initialMode && initialSettings.initialMode !== "casual") challengeMode = initialSettings.initialMode;
    if (challengeMode === "daily") {
      challengeContext = { utcDateKey: getUtcDateKey() };
      initFromSeed(deriveDailySeed(), false, initialSettings.scriptOverride, initialSettings.initialRelics || [], initialSettings.initialCurses || []);
    } else if (challengeMode === "weekly") {
      const weekly = deriveWeeklyMutatorSet();
      activeWeeklyMutatorSet = weekly.mutators.slice();
      challengeContext = { weekLabel: `${weekly.info.isoYear}-W${String(weekly.info.isoWeek).padStart(2, "0")}` };
      initFromSeed((hashStringFNV1a(`weekly-seed:${challengeContext.weekLabel}`) ^ 0xA5A5A5A5) >>> 0, false, initialSettings.scriptOverride, initialSettings.initialRelics || [], initialSettings.initialCurses || []);
    } else if (initialSettings.seed === null) initFromSeed(DEFAULT_SEED, false, initialSettings.scriptOverride, initialSettings.initialRelics || [], initialSettings.initialCurses || []);
    else initFromSeed(initialSettings.seed, initialSettings.manual, initialSettings.scriptOverride, initialSettings.initialRelics || [], initialSettings.initialCurses || []);
    updateChallengeRulesUI();
    maybeStartTutorial();
  </script>
</body>
</html>
