<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beat The Rock: Challenge Dwayne Johnson at Rock Paper Scissors</title>
  <style>
    :root {
      --panel-bg: rgba(8, 14, 30, 0.72);
      --panel-border: rgba(148, 163, 184, 0.32);
      --text-soft: #c3c7d1;
      --neon-cyan: #22d3ee;
      --neon-violet: #a78bfa;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      background:
        radial-gradient(circle at 12% 18%, rgba(34, 211, 238, 0.22), transparent 35%),
        radial-gradient(circle at 84% 7%, rgba(167, 139, 250, 0.24), transparent 34%),
        radial-gradient(circle at 70% 72%, rgba(244, 114, 182, 0.16), transparent 38%),
        linear-gradient(140deg, #04050c 0%, #0a1224 48%, #070910 100%);
      background-attachment: fixed;
    }
    body::before {
      content: "";
      position: fixed;
      inset: -25vmax;
      background: conic-gradient(from 120deg at 50% 50%, rgba(34,211,238,0.12), rgba(167,139,250,0.13), rgba(244,114,182,0.12), rgba(34,211,238,0.12));
      filter: blur(70px);
      animation: auroraSpin 26s linear infinite;
      pointer-events: none;
      z-index: -2;
    }
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background-image: radial-gradient(rgba(148,163,184,0.2) 0.65px, transparent 0.65px);
      background-size: 3px 3px;
      opacity: 0.16;
      pointer-events: none;
      z-index: -1;
    }
    @keyframes auroraSpin { from { transform: rotate(0deg) scale(1.03); } to { transform: rotate(360deg) scale(1.03); } }
    .app {
      max-width: 920px;
      width: 100%;
      padding: 26px 22px 44px;
      margin: 18px auto 30px;
      box-sizing: border-box;
      border-radius: 24px;
      border: 1px solid rgba(148,163,184,0.22);
      background: linear-gradient(160deg, rgba(15,23,42,0.62), rgba(2,6,23,0.8));
      box-shadow: 0 26px 60px rgba(2, 6, 23, 0.68), inset 0 0 0 1px rgba(255,255,255,0.04);
      backdrop-filter: blur(14px);
    }
    h1 {
      font-size: clamp(2rem, 3.5vw, 2.7rem);
      margin: 0 0 5px;
      text-align: center;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      text-shadow: 0 0 24px rgba(34,211,238,0.45), 0 0 38px rgba(167,139,250,0.4);
    }
    .subtitle { text-align: center; font-size: 0.95rem; color: #dbe4ff; margin-bottom: 6px; }
    .run-summary { text-align: center; font-size: 0.8rem; color: #9ca3af; margin-bottom: 10px; }
    .run-summary-pill { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); }
    .run-summary-pill strong { color: #e5e7eb; }

    .title-shell { margin-bottom: 14px; border-radius: 14px; border: 1px solid rgba(148,163,184,0.45); background: rgba(15,23,42,0.92); padding: 16px 14px; text-align: center; }
    .title-shell h2 { margin: 0 0 6px; font-size: 1.2rem; color: #f8fafc; }
    .title-shell p { margin: 0 0 12px; font-size: 0.85rem; color: #cbd5e1; }
    .title-shell .btn-primary { min-width: 180px; }
    .match-setup { margin-top: 12px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.4); background: rgba(2,6,23,0.64); padding: 12px 10px; }
    .match-setup h3 { margin: 0 0 10px; font-size: 0.82rem; letter-spacing: 0.06em; color: #bfdbfe; text-transform: uppercase; }
    .run-mode-badge { border: 1px solid rgba(125,211,252,0.65); border-radius: 999px; padding: 2px 8px; font-size: 0.72rem; color: #dbeafe; }

    .seed-row { display: flex; flex-wrap: wrap; gap: 8px 10px; align-items: center; justify-content: center; font-size: 0.8rem; color: #9ca3af; margin-bottom: 8px; }
    .seed-row label { display: inline-flex; align-items: center; gap: 6px; }
    .seed-row input { background: #020617; border-radius: 999px; border: 1px solid rgba(148,163,184,0.7); padding: 5px 10px; color: #e5e7eb; font-size: 0.8rem; width: 165px; }
    .seed-row button { font-size: 0.76rem; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(56,189,248,0.75); background: rgba(15,23,42,0.92); color: #bae6fd; cursor: pointer; }
    .seed-row button:hover { filter: brightness(1.1); }
    .seed-feedback { width: 100%; text-align: center; font-size: 0.78rem; min-height: 1.1rem; }
    .seed-feedback.error { color: #fca5a5; }
    .seed-feedback.info { color: #93c5fd; }

    .settings-row { display: flex; flex-wrap: wrap; gap: 8px 14px; align-items: center; justify-content: center; font-size: 0.78rem; color: #9ca3af; margin-bottom: 6px; }
    .settings-row label { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; padding: 5px 9px; border-radius: 999px; background: rgba(15,23,42,0.85); border: 1px solid rgba(148,163,184,0.6); }
    .settings-row input[type="checkbox"] { accent-color: #8b5cf6; cursor: pointer; }
    .settings-hint { font-size: 0.75rem; color: #6b7280; }

    .mode-toggle { text-align: center; font-size: 0.85rem; color: #9ca3af; margin-bottom: 10px; }
    .mode-toggle label { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: rgba(15,23,42,0.85); border: 1px solid rgba(148,163,184,0.6); }
    .mode-toggle input { accent-color: #8b5cf6; cursor: pointer; }

    .scene {
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      border-radius: 16px;
      padding: 12px 12px 10px;
      margin-bottom: 12px;
      box-shadow: 0 10px 24px rgba(2,6,23,0.4);
      backdrop-filter: blur(8px);
    }
    .adaptive-stats { text-align: center; font-size: 0.78rem; color: #6b7280; margin-bottom: 4px; margin-top: 2px; }
    .adaptive-stats strong { color: #e5e7eb; }
    .hud-row {
      position: sticky;
      top: 8px;
      z-index: 30;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin: 8px 0 14px;
    }
    .hud-row .run-summary { grid-column: 1 / -1; margin: 0; }
    .hud-chip {
      border-radius: 999px;
      border: 1px solid rgba(125,211,252,0.38);
      background: linear-gradient(140deg, rgba(15,23,42,0.92), rgba(30,41,59,0.7));
      font-size: 0.78rem;
      color: #e5e7eb;
      padding: 8px 12px;
      text-align: center;
      line-height: 1.25;
      box-shadow: 0 8px 18px rgba(2,6,23,0.45), inset 0 0 16px rgba(34,211,238,0.08);
      backdrop-filter: blur(6px);
    }
    .mood-display {
      margin: 0;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.45);
      background: linear-gradient(135deg, rgba(30,41,59,0.9), rgba(15,23,42,0.95));
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-size: 0.74rem;
      font-weight: 600;
      transition: background 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
    }
    .mood-emoji { font-size: 1.3rem; line-height: 1; }
    .mood-text { display: inline-flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: center; }
    .mood-label { text-transform: uppercase; letter-spacing: 0.06em; color: rgba(226,232,240,0.9); font-size: 0.7rem; }
    .mood-state { font-size: 0.84rem; color: #f8fafc; }
    .mood-risk { font-size: 0.72rem; color: rgba(226,232,240,0.95); }
    .mood-display.severity-low {
      background: linear-gradient(135deg, rgba(20,83,45,0.75), rgba(15,23,42,0.95));
      border-color: rgba(74,222,128,0.55);
      box-shadow: 0 0 0 1px rgba(74,222,128,0.18) inset;
    }
    .mood-display.severity-mid {
      background: linear-gradient(135deg, rgba(146,64,14,0.75), rgba(15,23,42,0.95));
      border-color: rgba(251,191,36,0.58);
      box-shadow: 0 0 0 1px rgba(251,191,36,0.22) inset;
    }
    .mood-display.severity-high {
      background: linear-gradient(135deg, rgba(127,29,29,0.78), rgba(15,23,42,0.95));
      border-color: rgba(248,113,113,0.62);
      box-shadow: 0 0 0 1px rgba(248,113,113,0.2) inset;
    }
    .pre-round-hint { text-align: center; font-size: 0.8rem; color: #c3c7d1; margin-bottom: 14px; min-height: 1.2rem; }

    .arena { display: grid; grid-template-columns: 1fr auto 1fr; gap: 12px; align-items: center; background: linear-gradient(155deg, rgba(17,20,31,0.78), rgba(15,23,42,0.95)); border: 1px solid rgba(148,163,184,0.34); border-radius: 18px; padding: 20px 18px; box-shadow: 0 18px 42px rgba(0,0,0,0.52), inset 0 0 30px rgba(139,92,246,0.13); transform-origin: center; position: relative; overflow: hidden; }
    .arena::before { content: ""; position: absolute; inset: -30% 15% auto; height: 60%; background: radial-gradient(circle at center, rgba(34,211,238,0.23), transparent 70%); filter: blur(22px); pointer-events: none; }
    @keyframes shake { 0%{transform:translate(0,0)} 20%{transform:translate(-4px,2px)} 40%{transform:translate(4px,-2px)} 60%{transform:translate(-3px,1px)} 80%{transform:translate(3px,0)} 100%{transform:translate(0,0)} }
    .arena.shake { animation: shake 0.35s ease; }
    @keyframes lockPulse { 0%{transform:scale(1)} 50%{transform:scale(1.01)} 100%{transform:scale(1)} }
    @keyframes revealDrop { 0%{transform:translateY(-10px); opacity:0.2} 100%{transform:translateY(0); opacity:1} }
    .arena.phase-lock-in { animation: lockPulse 0.28s ease; }
    .arena.phase-reveal { box-shadow: 0 14px 34px rgba(0,0,0,0.5), 0 0 0 1px rgba(139,92,246,0.28) inset; }
    .hand.reveal-pop { animation: revealDrop 0.24s ease; }
    .side { text-align: center; }
    .side h2 { font-size: 1rem; margin: 0 0 6px; text-transform: uppercase; letter-spacing: 0.06em; color: #c3c7d1; }
    .side .name-rock { color: #ffcc4d; font-weight: 700; }
    .side .name-you { color: #6ee7b7; font-weight: 700; }
    .hand { font-size: 3.35rem; min-height: 3.2rem; line-height: 1; margin-bottom: 8px; text-shadow: 0 0 18px rgba(255,255,255,0.2), 0 0 26px rgba(34,211,238,0.24); }
    .label-move { font-size: 0.9rem; color: #aeb2c0; min-height: 1.2rem; }
    .vs { font-size: 1.2rem; font-weight: 700; color: #ddd6fe; padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(139,92,246,0.72); background: radial-gradient(circle at 30% 0, rgba(139,92,246,0.45), transparent), rgba(17,24,39,0.94); box-shadow: 0 0 18px rgba(139,92,246,0.45); letter-spacing: 0.18em; }

    .round-info { margin-top: 12px; display: flex; flex-wrap: wrap; gap: 6px; justify-content: space-between; align-items: baseline; font-size: 0.95rem; color: #c3c7d1; }
    .progress-wrap { margin-top: 10px; }
    .progress-labels { display: flex; justify-content: space-between; font-size: 0.8rem; color: #9ca3af; margin-bottom: 4px; }
    .progress-bar { position: relative; width: 100%; height: 6px; border-radius: 999px; background: #020617; overflow: hidden; border: 1px solid rgba(30,64,175,0.8); }
    .progress-fill { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; border-radius: 999px; background: linear-gradient(90deg, #4ade80, #22c55e, #16a34a); transition: width 0.25s ease; }

    .round-board { margin-top: 14px; padding: 12px 10px 10px; border-radius: 14px; background: radial-gradient(circle at top, rgba(56,189,248,0.18), rgba(2,6,23,0.94)); border: 1px solid rgba(56,189,248,0.4); box-shadow: inset 0 0 26px rgba(34,211,238,0.1); }
    .round-board-header { display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; color: #bae6fd; font-size: 0.8rem; margin-bottom: 8px; }
    .round-board-grid { display: grid; grid-template-columns: repeat(20, minmax(16px, 1fr)); gap: 4px; }
    .round-box { min-height: 44px; border-radius: 8px; border: 1px solid rgba(100,116,139,0.5); background: #111827; color: #64748b; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1px; line-height: 1; cursor: default; padding: 3px 1px; }
    .round-box .round-num { font-size: 0.55rem; color: #94a3b8; }
    .round-box .round-hands { font-size: 0.68rem; color: #cbd5e1; min-height: 0.72rem; }
    .round-box .round-outcome { font-size: 0.66rem; min-height: 0.66rem; }
    .round-box.played { cursor: pointer; }
    .round-box.played.win { border-color: rgba(52,211,153,0.9); background: #064e3b; }
    .round-box.played.lose { border-color: rgba(248,113,113,0.9); background: #7f1d1d; }
    .round-box.played.draw { border-color: rgba(250,204,21,0.9); background: #713f12; }
    .round-box.current { border-color: rgba(216,180,254,1); box-shadow: inset 0 0 0 1px rgba(216,180,254,0.8); }
    .round-box.played:hover,
    .round-box.played:focus-visible { transform: translateY(-1px); border-color: #38bdf8; }
    .round-box:focus-visible { outline: 3px solid #93c5fd; outline-offset: 1px; }
    .round-board-preview { margin-top: 8px; min-height: 1.2rem; font-size: 0.78rem; color: #cbd5e1; }
    .round-board-preview strong { color: #e5e7eb; }

    .challenge-row { margin-top: 12px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; }
    .btn-share { background: #2563eb; color: #eff6ff; box-shadow: 0 4px 10px rgba(0,0,0,0.55); }
    .copy-status { font-size: 0.78rem; color: #93c5fd; min-height: 1.1rem; }
    .copy-status.error { color: #fca5a5; }

    .controls { margin-top: 16px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
    button { border: 1px solid rgba(148,163,184,0.32); border-radius: 999px; padding: 10px 18px; font-size: 1rem; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-weight: 700; transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease; backdrop-filter: blur(5px); }
    button span.hand-icon { font-size: 1.3rem; }
    .btn-rock { background: linear-gradient(135deg, #0f172a, #1d4ed8); color: #f9fafb; box-shadow: 0 10px 18px rgba(30,64,175,0.42); min-width: 120px; }
    .btn-paper { background: linear-gradient(135deg, #1e1b4b, #7c3aed); color: #f9fafb; box-shadow: 0 10px 18px rgba(109,40,217,0.4); min-width: 120px; }
    .btn-scissors { background: linear-gradient(135deg, #0f172a, #0891b2); color: #f9fafb; box-shadow: 0 10px 18px rgba(8,145,178,0.4); min-width: 120px; }
    .btn-reset { background: linear-gradient(135deg, #b91c1c, #ef4444); color: #fef2f2; box-shadow: 0 10px 20px rgba(220,38,38,0.4); }
    button:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 12px 24px rgba(0,0,0,0.56); border-color: rgba(125,211,252,0.58); }
    button:active { transform: translateY(0); box-shadow: 0 3px 6px rgba(0,0,0,0.5); }
    button:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
    button:focus-visible { outline: 3px solid #93c5fd; outline-offset: 2px; }

    .result-line { margin-top: 14px; font-size: 1.02rem; text-align: center; min-height: 1.4rem; }
    .result-win { color: #6ee7b7; }
    .result-lose { color: #f97373; }
    .result-draw { color: #facc15; }
    .commentary-wrap { margin-top: 12px; padding: 12px 12px 10px; border-radius: 12px; background: radial-gradient(circle at top, rgba(250,204,21,0.16), rgba(30,41,59,0.95)); border: 1px solid rgba(250,204,21,0.45); }
    .commentary-title { font-size: 0.76rem; letter-spacing: 0.08em; text-transform: uppercase; color: #fde68a; margin-bottom: 6px; font-weight: 700; }
    .commentary { margin-top: 0; font-size: 1.14rem; color: #f8fafc; min-height: 4.1rem; line-height: 1.45; font-weight: 700; }

    .achievements { margin-top: 14px; padding: 12px 12px 10px; border-radius: 12px; background: radial-gradient(circle at top, rgba(168,85,247,0.14), rgba(2,6,23,0.95)); border: 1px solid rgba(192,132,252,0.5); font-size: 0.84rem; color: #d1d5db; }
    .achievements-header { margin-bottom: 8px; color: #f5f3ff; font-weight: 700; letter-spacing: 0.03em; display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
    .btn-achievements-reset { font-size: 0.74rem; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(248,113,113,0.8); background: rgba(69,10,10,0.9); color: #fee2e2; cursor: pointer; }
    .btn-achievements-reset:hover { filter: brightness(1.08); }
    .achievements-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 8px; }
    .achievement-badge { position: relative; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(167,139,250,0.55); background: linear-gradient(140deg, rgba(91,33,182,0.65), rgba(30,41,59,0.9)); color: #ede9fe; line-height: 1.35; box-shadow: 0 6px 16px rgba(0,0,0,0.3); }
    .achievement-badge.locked { opacity: 0.5; filter: grayscale(0.25); }
    .achievement-multiplier { position: absolute; top: 6px; right: 8px; font-size: 0.68rem; font-weight: 700; padding: 2px 6px; border-radius: 999px; background: rgba(2,6,23,0.8); border: 1px solid rgba(148,163,184,0.7); color: #e2e8f0; }
    .achievement-badge::before { content: "üèÜ "; }
    .achievement-badge.rank-bronze { border-color: rgba(180,83,9,0.85); background: linear-gradient(140deg, rgba(120,53,15,0.88), rgba(41,37,36,0.95)); color: #ffedd5; }
    .achievement-badge.rank-silver { border-color: rgba(148,163,184,0.9); background: linear-gradient(140deg, rgba(71,85,105,0.9), rgba(15,23,42,0.96)); color: #f1f5f9; }
    .achievement-badge.rank-gold { border-color: rgba(250,204,21,0.95); background: linear-gradient(140deg, rgba(133,77,14,0.93), rgba(69,26,3,0.98)); color: #fef9c3; }
    .achievement-badge.rank-platinum { border-color: rgba(125,211,252,0.95); background: linear-gradient(140deg, rgba(186,230,253,0.32), rgba(14,116,144,0.72)); color: #ecfeff; }

    .achievement-toast-stack { position: fixed; top: 14px; right: 14px; width: min(360px, calc(100vw - 28px)); display: flex; flex-direction: column; gap: 8px; z-index: 1000; pointer-events: none; }
    .achievement-toast { background: linear-gradient(140deg, rgba(30,58,138,0.95), rgba(15,23,42,0.98)); border: 1px solid rgba(125,211,252,0.8); border-radius: 10px; padding: 10px 12px; color: #e0f2fe; font-size: 0.82rem; line-height: 1.35; box-shadow: 0 12px 26px rgba(0,0,0,0.45); animation: toastIn 0.28s ease; }
    .achievement-toast.rank-gold { border-color: rgba(250,204,21,0.9); background: linear-gradient(140deg, rgba(120,53,15,0.95), rgba(69,26,3,0.98)); color: #fef9c3; }
    .achievement-toast.rank-platinum { border-color: rgba(125,211,252,0.95); background: linear-gradient(140deg, rgba(186,230,253,0.35), rgba(14,116,144,0.82)); color: #ecfeff; }
    .achievement-toast strong { color: #f8fafc; }
    @keyframes toastIn { from { opacity: 0; transform: translateX(14px) scale(0.98); } to { opacity: 1; transform: translateX(0) scale(1); } }

    .help-box { margin-top: 10px; margin-bottom: 10px; font-size: 0.82rem; color: #cbd5e1; border-radius: 12px; border: 1px solid rgba(125,211,252,0.4); background: radial-gradient(circle at top, rgba(14,116,144,0.17), rgba(2,6,23,0.96)); padding: 10px 12px; }
    .help-box summary { cursor: pointer; list-style: none; color: #e5e7eb; font-weight: 600; }
    .help-box summary:focus-visible,
    .debug-panel summary:focus-visible { outline: 3px solid #93c5fd; outline-offset: 3px; border-radius: 4px; }
    .help-box summary::marker { display: none; }
    .help-box summary::-webkit-details-marker { display: none; }
    .help-box-content { margin-top: 6px; line-height: 1.4; }
    .help-box-content ul { padding-left: 18px; margin: 4px 0 0; }

    body.gameplay-active .help-box { opacity: 0.58; border-color: rgba(148,163,184,0.35); background: rgba(2,6,23,0.8); }
    body.gameplay-active .help-box summary { color: #cbd5e1; }

    .tutorial-tooltip { position: fixed; z-index: 85; max-width: 290px; background: rgba(2,6,23,0.97); border: 1px solid rgba(125,211,252,0.78); border-radius: 12px; box-shadow: 0 16px 34px rgba(0,0,0,0.48); padding: 10px 12px; color: #dbeafe; font-size: 0.78rem; line-height: 1.35; }
    .tutorial-tooltip.is-hidden { display: none; }
    .tutorial-tooltip-title { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.06em; color: #93c5fd; margin-bottom: 4px; }
    .tutorial-tooltip-text { margin: 0; }
    .tutorial-tooltip-actions { margin-top: 8px; display: flex; justify-content: flex-end; }
    .tutorial-skip-btn { border: 1px solid rgba(148,163,184,0.62); background: rgba(15,23,42,0.9); color: #e2e8f0; border-radius: 999px; padding: 4px 10px; font-size: 0.72rem; cursor: pointer; }
    .tutorial-skip-btn:hover { filter: brightness(1.08); }
    .tutorial-target { box-shadow: 0 0 0 2px rgba(56,189,248,0.85); border-radius: 10px; }
    .help-legend { margin-top: 10px; font-size: 0.78rem; color: #c3c7d1; display: flex; flex-wrap: wrap; gap: 8px 10px; }
    .help-legend span { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.75); }

    .debug-panel { margin-top: 16px; font-size: 0.8rem; color: #9ca3af; }
    .debug-panel summary { cursor: pointer; list-style: none; }
    .debug-panel summary::marker { display: none; }
    .debug-panel summary::-webkit-details-marker { display: none; }
    .debug-panel summary span { text-decoration: underline; }
    .debug-log { margin-top: 8px; max-height: 260px; overflow-y: auto; border-top: 1px solid rgba(148,163,184,0.3); padding-top: 6px; }
    .debug-log-entry { margin-bottom: 4px; line-height: 1.3; }

    .analysis-drawer { margin-top: 12px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.45); background: rgba(15,23,42,0.92); padding: 10px; }
    .analysis-drawer-title { margin: 0 0 8px; font-size: 0.85rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.06em; }
    .drawer-panel { border: 1px solid rgba(148,163,184,0.35); border-radius: 10px; background: rgba(2,6,23,0.7); margin-bottom: 8px; overflow: hidden; transition: border-color 0.25s ease, box-shadow 0.25s ease; }
    .drawer-panel[open] { border-color: rgba(125,211,252,0.6); }
    .drawer-panel:last-child { margin-bottom: 0; }
    .drawer-panel summary { cursor: pointer; list-style: none; padding: 9px 11px; font-size: 0.82rem; font-weight: 600; color: #e2e8f0; }
    .drawer-panel summary::marker,
    .drawer-panel summary::-webkit-details-marker { display: none; }
    .drawer-panel-body { padding: 0 11px 11px; }
    .drawer-panel.highlighted { box-shadow: 0 0 0 2px rgba(250,204,21,0.7); border-color: rgba(250,204,21,0.88); }

    .footer { margin-top: 18px; font-size: 0.8rem; color: #6b7280; text-align: center; line-height: 1.3; }

    .is-hidden { display: none !important; }
    .scene { display: block; }

    .app-toolbar { display: flex; justify-content: center; margin: 10px 0 14px; }
    .menu-btn { font-size: 0.78rem; padding: 7px 14px; border-radius: 999px; border: 1px solid rgba(125,211,252,0.7); background: rgba(15,23,42,0.95); color: #bae6fd; cursor: pointer; }
    .menu-btn:hover { filter: brightness(1.08); }

    .menu-modal { position: fixed; inset: 0; display: flex; align-items: flex-start; justify-content: center; padding: 20px; background: rgba(2,6,23,0.72); z-index: 60; overflow-y: auto; }
    .menu-modal:not(.is-active) { display: none; }
    .menu-panel { width: min(820px, 100%); background: #0f172a; border: 1px solid rgba(148,163,184,0.45); border-radius: 14px; padding: 16px 14px 18px; box-shadow: 0 20px 42px rgba(0,0,0,0.45); }
    .menu-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
    .menu-header h2 { margin: 0; font-size: 1rem; color: #e2e8f0; }
    .menu-close-btn { border: 1px solid rgba(148,163,184,0.65); background: rgba(2,6,23,0.92); color: #e2e8f0; border-radius: 999px; padding: 6px 12px; font-size: 0.75rem; cursor: pointer; }

    .round-result-overlay { position: fixed; inset: auto 0 26px; display: flex; justify-content: center; z-index: 50; pointer-events: none; }
    .round-result-overlay-card { background: rgba(15,23,42,0.95); border: 1px solid rgba(148,163,184,0.55); border-radius: 999px; padding: 8px 14px; font-size: 0.8rem; color: #e2e8f0; box-shadow: 0 12px 28px rgba(0,0,0,0.4); }

    .summary-card { margin-top: 12px; border-radius: 14px; border: 1px solid rgba(125,211,252,0.38); background: linear-gradient(145deg, rgba(15,23,42,0.94), rgba(30,41,59,0.75)); padding: 12px; box-shadow: inset 0 0 18px rgba(34,211,238,0.08); }
    .summary-card h2 { margin: 0 0 6px; font-size: 1rem; color: #f8fafc; }
    .summary-card p { margin: 0; font-size: 0.82rem; color: #cbd5e1; line-height: 1.35; }

    .post-match-overlay { position: fixed; inset: 0; z-index: 70; padding: 20px; background: rgba(2,6,23,0.78); display: flex; align-items: center; justify-content: center; overflow-y: auto; }
    .post-match-overlay.is-hidden { display: none; }
    .post-match-card { width: min(760px, 100%); border-radius: 18px; border: 1px solid rgba(125,211,252,0.5); background: linear-gradient(180deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98)); box-shadow: 0 22px 48px rgba(0,0,0,0.55), inset 0 0 40px rgba(139,92,246,0.14); padding: 18px 16px; }
    .post-match-banner { display: inline-flex; border-radius: 999px; border: 1px solid rgba(148,163,184,0.65); background: rgba(30,41,59,0.8); padding: 6px 12px; font-size: 0.78rem; text-transform: uppercase; letter-spacing: 0.06em; color: #e2e8f0; margin-bottom: 8px; }
    .post-match-banner.you-win { border-color: rgba(52,211,153,0.9); color: #bbf7d0; }
    .post-match-banner.rock-win { border-color: rgba(248,113,113,0.9); color: #fecaca; }
    .post-match-banner.draw-match { border-color: rgba(250,204,21,0.9); color: #fde68a; }
    .post-match-title { margin: 0 0 8px; font-size: 1.2rem; color: #f8fafc; }
    .post-match-flavor { margin: 0 0 12px; font-size: 0.86rem; line-height: 1.4; color: #cbd5e1; }
    .post-match-stats { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 8px; margin-bottom: 12px; }
    .post-match-stat { border-radius: 10px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); padding: 8px 9px; }
    .post-match-stat-label { font-size: 0.7rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 4px; }
    .post-match-stat-value { font-size: 0.92rem; color: #f1f5f9; font-weight: 600; }
    .post-match-achievements { border-radius: 10px; border: 1px solid rgba(168,85,247,0.5); background: rgba(46,16,101,0.2); padding: 10px; margin-bottom: 14px; }
    .post-match-achievements h3 { margin: 0 0 6px; font-size: 0.88rem; color: #f5d0fe; }
    .post-match-achievements ul { margin: 0; padding-left: 18px; font-size: 0.8rem; color: #e9d5ff; }
    .post-match-achievements li { margin-bottom: 4px; }
    .post-match-achievements p { margin: 0; font-size: 0.8rem; color: #d8b4fe; }
    .post-match-actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .btn-primary { background: #22c55e; color: #f0fdf4; }
    .btn-secondary { background: #2563eb; color: #eff6ff; }
    .btn-tertiary { background: #1e293b; color: #e2e8f0; border: 1px solid rgba(148,163,184,0.6); }

    @media (max-width: 640px) {
      .arena { grid-template-columns: 1fr; text-align: center; }
      .vs { justify-self: center; }
      button { padding: 12px 20px; }
      .hud-row { grid-template-columns: 1fr; position: static; }
      .hud-row .run-summary-pill { width: 100%; justify-content: center; flex-wrap: wrap; }
      .post-match-stats { grid-template-columns: 1fr; }
      .post-match-actions { flex-direction: column; }
      .post-match-actions button { width: 100%; justify-content: center; }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after { animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; scroll-behavior: auto !important; }
    }
  </style>
</head>
<body>
  <div id="achievementToasts" class="achievement-toast-stack" aria-live="polite" aria-atomic="false"></div>
  <div class="app">
    <h1>Beat The Rock</h1>
    <div class="subtitle">20 rounds against a modeled Dwayne "The Rock" Johnson. Read his tendencies, outplay the script, and win the showdown.</div>

    <section id="sceneMetaPanels" class="scene">
      <div class="app-toolbar">
        <button id="gameMenuBtn" class="menu-btn" type="button" aria-controls="gameMenuModal" aria-expanded="false">Fight Menu</button>
      </div>
    </section>

    <div class="hud-row" aria-label="Match HUD">
      <div class="run-summary">
        <div id="runSummaryPill" class="run-summary-pill is-hidden">
          <span><strong>Run</strong> live</span>
          <span id="runSummarySeed" class="run-mode-badge">Seed pending</span>
          <span id="runSummaryMode" class="run-mode-badge">Mode pending</span>
        </div>
      </div>
      <div id="roundLabel" class="hud-chip">Round 1 of 20</div>
      <div id="scoreLabel" class="hud-chip">The Rock 0  |  You 0  |  Draws 0</div>
      <div id="moodDisplay" class="mood-display severity-low">üßä The Rock is calm ¬∑ Read risk 30%</div>
    </div>

    <section id="sceneLobby" class="scene">
      <div class="title-shell">
        <h2>Welcome to Beat The Rock</h2>
        <p>He has the script. You have 20 rounds to break it before the bell.</p>
        <button id="startMatchBtn" class="btn-primary" type="button">Start Match</button>

        <div class="match-setup">
          <h3>Match Setup</h3>
          <div class="seed-row">
            <label>Next run seed <input id="seedInput" type="text" placeholder="blank = random" /></label>
            <button id="randomSeedBtn" type="button">Generate random seed</button>
            <div id="seedFeedback" class="seed-feedback" aria-live="polite"></div>
          </div>

          <div class="mode-toggle">
            <label><input type="checkbox" id="adaptiveToggle" /> Adaptive Rock mode, he reads your status, trends, and last move after round 1.</label>
          </div>

          <div class="settings-row">
            <label><input type="checkbox" id="sfxToggle" checked /> Sound effects on</label>
          </div>
        </div>
      </div>
      <div id="adaptiveStats" class="adaptive-stats"><strong>Adaptive Rock</strong> is off. Flip the switch to let him try and read you.</div>
      <div id="preRoundHint" class="pre-round-hint">Pre-round scout, he's waiting for your opener.</div>
      <div class="summary-card">
        <h2>Lobby</h2>
        <p>Use Match panels for Stats, Achievements, Replay/Seed, and Debug. Set seed, adaptive mode, and SFX in Match Setup, then hit Start Match to enter the arena.</p>
      </div>
    </section>

    <section id="sceneGame" class="scene">
      <div class="arena-wrap">
        <div id="arena" class="arena">
          <div class="side">
            <h2><span class="name-rock">Dwayne</span> (The Rock)</h2>
            <div id="rockHand" class="hand">‚ùî</div>
            <div id="rockMoveLabel" class="label-move">Awaiting the opening bell.</div>
          </div>
          <div class="vs">R P S</div>
          <div class="side">
            <h2><span class="name-you">You</span></h2>
            <div id="yourHand" class="hand">‚ùî</div>
            <div id="yourMoveLabel" class="label-move">Pick your opening throw.</div>
          </div>
        </div>
      </div>


      <div class="progress-wrap">
        <div class="progress-labels">
          <span>Round progress</span>
          <span id="progressText">0 of 20 completed</span>
        </div>
        <div class="progress-bar"><div id="progressFill" class="progress-fill"></div></div>
      </div>

      <div id="moveButtonsAnchor" class="controls">
        <button class="btn-rock" data-move="R" aria-label="Play Rock hand"><span class="hand-icon">‚úä</span> Rock</button>
        <button class="btn-paper" data-move="P" aria-label="Play Paper hand"><span class="hand-icon">‚úã</span> Paper</button>
        <button class="btn-scissors" data-move="S" aria-label="Play Scissors hand"><span class="hand-icon">‚úåÔ∏è</span> Scissors</button>
        <button id="resetBtn" class="btn-reset" style="display:none;">Start new showdown</button>
      </div>
      <div id="resultLine" class="result-line" role="status" aria-live="polite" aria-atomic="true"></div>
      <div class="commentary-wrap">
        <div class="commentary-title">Commentary desk</div>
        <div id="commentary" class="commentary" role="status" aria-live="polite" aria-atomic="true"></div>
      </div>

      <div id="seedShareAnchor" class="challenge-row">
        <button id="copyLinkBtn" class="btn-share" type="button">Copy challenge link</button>
        <div id="copyStatus" class="copy-status" aria-live="polite"></div>
      </div>

      <section class="analysis-drawer" aria-label="Match intelligence panels">
        <h2 class="analysis-drawer-title">Match panels</h2>
        <details id="statsPanel" class="drawer-panel" open>
          <summary>Stats</summary>
          <div class="drawer-panel-body">
            <div class="round-board">
              <div class="round-board-header">
                <span>20-round fight card (result + hands + order)</span>
                <span>Outcomes use W/L/D</span>
                <span id="roundBoardStatus">Round 1 is underway</span>
              </div>
              <div id="roundBoard" class="round-board-grid"></div>
              <div id="roundBoardPreview" class="round-board-preview">Hover, focus, or tap a played round to preview exact hands, outcome, and mood.</div>
            </div>
          </div>
        </details>

        <details id="achievementsPanel" class="drawer-panel">
          <summary>Achievements</summary>
          <div class="drawer-panel-body">
            <div class="achievements">
              <div class="achievements-header">
                <span>Run achievements</span>
                <button id="resetAchievementsBtn" class="btn-achievements-reset" type="button">Reset achievements</button>
              </div>
              <div id="achievementsList" class="achievements-list"></div>
            </div>
          </div>
        </details>

        <details id="replaySeedPanel" class="drawer-panel">
          <summary>Replay & Seed</summary>
          <div class="drawer-panel-body">
            <p class="settings-hint">Seed and mode controls now live in Match Setup before you start a run.</p>
          </div>
        </details>

        <details id="debugPanel" class="drawer-panel debug-panel">
          <summary><span>Debug</span></summary>
          <div class="drawer-panel-body">
            <div id="debugLog" class="debug-log"></div>
          </div>
        </details>
      </section>
    </section>

    <section id="sceneSummary" class="post-match-overlay is-hidden" aria-live="polite" aria-atomic="true">
      <div class="post-match-card">
        <div id="summaryWinnerBanner" class="post-match-banner">Match complete</div>
        <h2 id="summaryTitle" class="post-match-title">Run complete</h2>
        <p id="summaryFlavor" class="post-match-flavor">Review your post-match stats and jump right back into another run.</p>

        <div class="post-match-stats">
          <div class="post-match-stat">
            <div class="post-match-stat-label">Best streak</div>
            <div id="summaryBestStreak" class="post-match-stat-value">0 rounds</div>
          </div>
          <div class="post-match-stat">
            <div class="post-match-stat-label">Beat-Rock hit rate</div>
            <div id="summaryBeatRockRate" class="post-match-stat-value">0%</div>
          </div>
          <div class="post-match-stat">
            <div class="post-match-stat-label">Mood pressure moments</div>
            <div id="summaryMoodPressure" class="post-match-stat-value">0 rounds</div>
          </div>
        </div>

        <div class="post-match-achievements">
          <h3>Achievements unlocked this run</h3>
          <ul id="summaryAchievementsList"></ul>
          <p id="summaryAchievementsEmpty">No achievements this run. Try a new seed or strategy and run it back.</p>
        </div>

        <div class="post-match-actions">
          <button id="summaryPlayAgainBtn" class="btn-primary" type="button">Play Again</button>
          <button id="summaryCopyLinkBtn" class="btn-secondary" type="button">Copy Challenge Link</button>
          <button id="summaryViewBoardBtn" class="btn-tertiary" type="button">View Full Round Board</button>
        </div>
      </div>
    </section>

    <div id="roundResultOverlay" class="round-result-overlay is-hidden" aria-live="polite" aria-atomic="true">
      <div id="roundResultOverlayText" class="round-result-overlay-card"></div>
    </div>

    <div id="gameMenuModal" class="menu-modal" role="dialog" aria-modal="true" aria-labelledby="gameMenuTitle">
      <div class="menu-panel">
        <div class="menu-header">
          <h2 id="gameMenuTitle">Fight Menu</h2>
          <button id="closeMenuBtn" class="menu-close-btn" type="button">Close</button>
        </div>

        <div class="settings-row">
          <button id="replayTutorialBtn" class="menu-btn" type="button">Replay Tutorial</button>
          <span class="settings-hint">Keyboard, R P S to play moves.</span>
        </div>

        <details class="help-box">
          <summary>How the showdown works</summary>
          <div class="help-box-content">
            <ul>
              <li>Every showdown is 20 rounds, and each round is logged on the fight card with hands and W/L/D.</li>
              <li>Dwayne "The Rock" Johnson starts on a seeded script. In Adaptive mode, after round 1 he uses score state, mood, and your recent trends to choose his next hand.</li>
              <li>His mood shifts from Calm to Suspicious to Paranoid based on recent losses, and each mood changes his read chance.</li>
              <li>Use the round board hover/focus preview to inspect exact hands, state, and whether the adaptive path was used.</li>
              <li>Set a seed in Replay & Seed to replay exact showdowns, or leave it blank to randomize the next reset.</li>
              <li>Achievements cover clutch, chaos, mood, sequence, and consolation badges. Unlocks are instant and increase their multiplier for this browser profile.</li>
            </ul>
            <div class="help-legend">
              <span><strong>Calm</strong> 30% adapt chance</span>
              <span><strong>Suspicious</strong> 60% adapt chance</span>
              <span><strong>Paranoid</strong> 90% adapt chance</span>
            </div>
          </div>
        </details>

      </div>
    </div>



    <div id="tutorialTooltip" class="tutorial-tooltip is-hidden" role="status" aria-live="polite">
      <div id="tutorialTooltipTitle" class="tutorial-tooltip-title"></div>
      <p id="tutorialTooltipText" class="tutorial-tooltip-text"></p>
      <div class="tutorial-tooltip-actions">
        <button id="tutorialSkipBtn" class="tutorial-skip-btn" type="button">Skip walkthrough</button>
      </div>
    </div>

    <div class="footer">
      With Adaptive Rock off, Dwayne follows a seeded script. With it on, he weighs score state and trends to make adaptive reads.<br />
      Each seed builds a different script, so players can share a seed and replay the same baseline showdown.
    </div>
  </div>

  <script>
    const ROCK_MOVES = ["R", "P", "S"];
    const SCRIPT_SEQUENCE_REGEX = /^[RPS]{20}$/i;
    const beats = { R: "P", P: "S", S: "R" };
    const names = { R: "Rock", P: "Paper", S: "Scissors" };
    const glyph = { R: "‚úä", P: "‚úã", S: "‚úåÔ∏è" };

    const rockLosingQuips = [
      "The Rock arches an eyebrow. This is not how it went in the script.",
      "He pauses, looks at his hand, then at you. That is not very family friendly language.",
      "The Great One is now The Mildly Confused One.",
      "He mutters something about the writer's room and probability.",
      "The Rock is starting to realise this franchise might be yours."
    ];
    const rockWinningQuips = [
      "The Rock grins. Finally, the universe remembers who the headline act is.",
      "He does the tiny air guitar thing. You walked right into that.",
      "He whispers, 'Know your role,' which is frankly unnecessary.",
      "The arena pops. You promise yourself you will focus next round.",
      "He smells what he is cooking. It is your defeat."
    ];
    const drawQuips = [
      "You both stare at identical hands. Awkward.",
      "The Rock nods in approval. 'Respect,' he says.",
      "Stalemate. Somewhere, a statistician sighs.",
      "Nobody wins, nobody loses, but you both sell it like a main event.",
      "Evenly matched. The crowd loves a slow burn."
    ];
    const beatRockQuips = [
      "That was the exact hand to beat The Rock this round. Somewhere, a game theorist applauds.",
      "You hit the exact hand to beat The Rock. He absolutely hates that.",
      "Perfect read. If this were pay per view, they would replay that one.",
      "Peak efficiency. Your hand might need its own entrance music soon.",
      "That was so clinical the ref checks on The Rock."
    ];
    const missedBeatRockQuips = [
      "There was a better move there, but hey, style points still count.",
      "Not the ideal beat-The-Rock choice, but the crowd appreciates the chaos.",
      "You zigged where the model zagged. Daring.",
      "You ignore optimal play and follow your heart. Bold strategy.",
      "Somewhere, the beat-The-Rock timeline branches off without you."
    ];

    const rockHandEl = document.getElementById("rockHand");
    const yourHandEl = document.getElementById("yourHand");
    const rockMoveLabelEl = document.getElementById("rockMoveLabel");
    const yourMoveLabelEl = document.getElementById("yourMoveLabel");
    const roundLabelEl = document.getElementById("roundLabel");
    const scoreLabelEl = document.getElementById("scoreLabel");
    const resultLineEl = document.getElementById("resultLine");
    const commentaryEl = document.getElementById("commentary");
    const resetBtn = document.getElementById("resetBtn");
    const moveButtons = Array.from(document.querySelectorAll("button[data-move]"));
    const moveButtonsAnchorEl = document.getElementById("moveButtonsAnchor");
    const adaptiveToggle = document.getElementById("adaptiveToggle");
    const arenaEl = document.getElementById("arena");
    const progressFillEl = document.getElementById("progressFill");
    const progressTextEl = document.getElementById("progressText");
    const adaptiveStatsEl = document.getElementById("adaptiveStats");
    const moodDisplayEl = document.getElementById("moodDisplay");
    const seedInputEl = document.getElementById("seedInput");
    const randomSeedBtn = document.getElementById("randomSeedBtn");
    const debugLogEl = document.getElementById("debugLog");
    const achievementsListEl = document.getElementById("achievementsList");
    const statsPanelEl = document.getElementById("statsPanel");
    const achievementsPanelEl = document.getElementById("achievementsPanel");
    const replaySeedPanelEl = document.getElementById("replaySeedPanel");
    const debugPanelEl = document.getElementById("debugPanel");
    const runSummaryPillEl = document.getElementById("runSummaryPill");
    const runSummarySeedEl = document.getElementById("runSummarySeed");
    const runSummaryModeEl = document.getElementById("runSummaryMode");
    const startMatchBtn = document.getElementById("startMatchBtn");
    const sfxToggle = document.getElementById("sfxToggle");
    const seedFeedbackEl = document.getElementById("seedFeedback");
    const preRoundHintEl = document.getElementById("preRoundHint");
    const roundBoardEl = document.getElementById("roundBoard");
    const roundBoardStatusEl = document.getElementById("roundBoardStatus");
    const roundBoardPreviewEl = document.getElementById("roundBoardPreview");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const seedShareAnchorEl = document.getElementById("seedShareAnchor");
    const copyStatusEl = document.getElementById("copyStatus");
    const achievementToastsEl = document.getElementById("achievementToasts");
    const resetAchievementsBtn = document.getElementById("resetAchievementsBtn");
    const sceneLobbyEl = document.getElementById("sceneLobby");
    const sceneGameEl = document.getElementById("sceneGame");
    const sceneSummaryEl = document.getElementById("sceneSummary");
    const summaryWinnerBannerEl = document.getElementById("summaryWinnerBanner");
    const summaryTitleEl = document.getElementById("summaryTitle");
    const summaryFlavorEl = document.getElementById("summaryFlavor");
    const summaryBestStreakEl = document.getElementById("summaryBestStreak");
    const summaryBeatRockRateEl = document.getElementById("summaryBeatRockRate");
    const summaryMoodPressureEl = document.getElementById("summaryMoodPressure");
    const summaryAchievementsListEl = document.getElementById("summaryAchievementsList");
    const summaryAchievementsEmptyEl = document.getElementById("summaryAchievementsEmpty");
    const summaryPlayAgainBtn = document.getElementById("summaryPlayAgainBtn");
    const summaryCopyLinkBtn = document.getElementById("summaryCopyLinkBtn");
    const summaryViewBoardBtn = document.getElementById("summaryViewBoardBtn");
    const gameMenuBtn = document.getElementById("gameMenuBtn");
    const gameMenuModal = document.getElementById("gameMenuModal");
    const closeMenuBtn = document.getElementById("closeMenuBtn");
    const replayTutorialBtn = document.getElementById("replayTutorialBtn");
    const tutorialTooltipEl = document.getElementById("tutorialTooltip");
    const tutorialTooltipTitleEl = document.getElementById("tutorialTooltipTitle");
    const tutorialTooltipTextEl = document.getElementById("tutorialTooltipText");
    const tutorialSkipBtn = document.getElementById("tutorialSkipBtn");
    const roundResultOverlayEl = document.getElementById("roundResultOverlay");
    const roundResultOverlayTextEl = document.getElementById("roundResultOverlayText");

    const U32_MIN = 0;
    const U32_MAX = 0xFFFFFFFF;
    const U32_MAX_BIGINT = BigInt(U32_MAX);
    const DEFAULT_SEED = 1;
    const TERNARY_SPACE = 3486784401;
    const DIGITS_ONLY_REGEX = /^\d+$/;
    const ACHIEVEMENTS_STORAGE_KEY = "beatTheRockAchievementCounts.v2";
    const TUTORIAL_STORAGE_KEY = "beatTheRockTutorialState.v1";
    const ORIGINAL_SEED_ONE_SEQUENCE = "RPSSRPPSPRRSPSPRPPRP";

    const achievementCatalog = [
      { id: "opening-pop", name: "Opening Pop", text: "You won round 1.", rank: "bronze", unlocked: s => s.historyLog[0]?.outcome === "win" },
      { id: "paperless-opener", name: "Paperless Opener", text: "Round 1, you opened with anything except Paper.", rank: "bronze", unlocked: s => s.openedNonPaper },
      { id: "triple-mixup", name: "Triple Mixup", text: "Your first 3 moves were all different.", rank: "silver", unlocked: s => s.firstThreeUnique },
      { id: "unshaken-opener", name: "Unshaken Opener", text: "No losses in the first 5 rounds.", rank: "bronze", unlocked: s => s.historyLog.length >= 5 && s.noLossesFirstFive },
      { id: "hot-streak", name: "Hot Streak", text: "You reached a win streak of 4+.", rank: "silver", unlocked: s => s.maxWinStreak >= 4 },
      { id: "cold-shower", name: "Cold Shower", text: "The Rock reached a win streak of 3+.", rank: "bronze", unlocked: s => s.maxRockStreak >= 3 },
      { id: "slippery-slope", name: "Slippery Slope", text: "Consolation badge, you hit a 5+ loss streak.", rank: "bronze", unlocked: s => s.maxLoseStreak >= 5 },
      { id: "draw-artist", name: "Draw Artist", text: "You reached 8+ draws in one run.", rank: "silver", unlocked: s => s.draws >= 8 },
      { id: "draw-buffet", name: "Draw Buffet", text: "You stacked 12+ draws. Nobody ate, everyone watched.", rank: "gold", unlocked: s => s.draws >= 12 },
      { id: "truce-train", name: "Truce Train", text: "You chained 4+ draws in a row.", rank: "silver", unlocked: s => s.maxDrawStreak >= 4 },
      { id: "paranoid-era", name: "Paranoid Era", text: "You kept The Rock in Paranoid state for a long stretch.", rank: "silver", unlocked: s => s.paranoidCount >= 5 },
      { id: "status-slayer", name: "Status Slayer", text: "You won 4+ rounds while he was Paranoid.", rank: "gold", unlocked: s => s.paranoidWins >= 4 },
      { id: "beat-the-rock-enjoyer", name: "Beat The Rock Enjoyer", text: "You beat The Rock in 10+ rounds.", rank: "silver", unlocked: s => s.beatRockHits >= 10 },
      { id: "boulder-puncher", name: "Boulder Puncher", text: "You beat The Rock in 14+ rounds.", rank: "gold", unlocked: s => s.beatRockHits >= 14 },
      { id: "mood-breaker", name: "Mood Breaker", text: "You forced Calm, Suspicious, and Paranoid in one run.", rank: "gold", unlocked: s => s.seenMoods.size === 3 },
      { id: "edge-of-your-seat", name: "Edge Of Your Seat", text: "You won a very close run.", rank: "bronze", unlocked: s => s.matchFinished && Math.abs(s.youScore - s.rockScore) === 1 && s.youScore > s.rockScore },
      { id: "seeded-legend", name: "Seeded Legend", text: "You chose the seed and still beat The Rock.", rank: "gold", unlocked: s => s.matchFinished && s.seedWasManual && s.youScore > s.rockScore },
      { id: "adaptive-bully", name: "Adaptive Bully", text: "You beat him even though his adaptive reads were strong.", rank: "gold", unlocked: s => s.matchFinished && s.adaptiveEverOnThisRun && s.adaptiveAttempts >= 5 && (s.adaptiveCorrectReads / s.adaptiveAttempts) >= 0.6 && s.youScore > s.rockScore },
      { id: "comeback-kid", name: "Comeback Kid", text: "You won after trailing by 3+ at some point.", rank: "gold", unlocked: s => s.matchFinished && s.maxRockLead >= 3 && s.youScore > s.rockScore },
      { id: "clean-finish", name: "Clean Finish", text: "You won the final 3 rounds and took the run.", rank: "gold", unlocked: s => s.matchFinished && s.youScore > s.rockScore && s.lastThreeAreWins },
      { id: "mirror-maestro", name: "Mirror Maestro", text: "Complex palindrome run, your 20 moves mirror perfectly.", rank: "platinum", unlocked: s => s.matchFinished && s.complexPalindromeMoves },
      { id: "rock-marathon", name: "Rock Marathon", text: "You threw Rock all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyRock },
      { id: "paper-marathon", name: "Paper Marathon", text: "You threw Paper all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyPaper },
      { id: "scissors-marathon", name: "Scissors Marathon", text: "You threw Scissors all 20 rounds.", rank: "gold", unlocked: s => s.matchFinished && s.onlyScissors },
      { id: "balanced-arsenal", name: "Balanced Arsenal", text: "At least 5 of each hand across the run.", rank: "gold", unlocked: s => s.matchFinished && s.minMoveCount >= 5 },
      { id: "no-repeat-discipline", name: "No Repeat Discipline", text: "20 rounds without repeating your last hand.", rank: "gold", unlocked: s => s.matchFinished && s.noConsecutiveSameMove },
      { id: "theoretical-maximum", name: "Theoretical Maximum", text: "You beat The Rock in every single round.", rank: "platinum", unlocked: s => s.matchFinished && s.beatRockHits === s.historyLog.length },
      { id: "reverse-sweep", name: "Reverse Sweep", text: "You lost the first 3 rounds but still won the run.", rank: "platinum", unlocked: s => s.matchFinished && s.youScore > s.rockScore && s.lostFirstThree },
      { id: "tough-crowd", name: "Tough Crowd", text: "Consolation badge, you lost by 8+ but still finished the run.", rank: "bronze", unlocked: s => s.matchFinished && s.lossMargin >= 8 },
      { id: "main-event-survivor", name: "Main Event Survivor", text: "Consolation badge, you lost but stayed for all 20 rounds.", rank: "bronze", unlocked: s => s.matchFinished && s.rockScore > s.youScore },
      { id: "pacifist-match", name: "Pacifist Match", text: "You somehow avoided winning or losing any round.", rank: "platinum", unlocked: s => s.matchFinished && s.youScore === 0 && s.rockScore === 0 && s.draws === 20 }
    ];
    function normalizeSeed(value) {
      const trimmed = String(value ?? "").trim();
      if (!DIGITS_ONLY_REGEX.test(trimmed)) return { valid: false, seed: null, clamped: false };

      const parsed = BigInt(trimmed);
      if (parsed < BigInt(U32_MIN)) return { valid: false, seed: null, clamped: false };

      const normalized = parsed > U32_MAX_BIGINT ? U32_MAX_BIGINT : parsed;
      return { valid: true, seed: Number(normalized), clamped: parsed !== normalized };
    }

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function generateSeededScriptSequence(seed) {
      if ((seed >>> 0) === DEFAULT_SEED) {
        const defaultSequence = ORIGINAL_SEED_ONE_SEQUENCE.split("");
        defaultSequence[0] = "R";
        return defaultSequence;
      }

      const normalizedSeed = seed >>> 0;
      const sequence = [];
      let value = normalizedSeed % TERNARY_SPACE;
      const overflow = Math.floor(normalizedSeed / TERNARY_SPACE);

      for (let i = 0; i < 20; i += 1) {
        let digit = value % 3;
        value = Math.floor(value / 3);
        if (overflow > 0) {
          const mix = (Math.imul(overflow, 0x9E3779B1) + Math.imul(i + 1, 0x85EBCA6B)) >>> 0;
          digit = (digit + (mix % 3)) % 3;
        }
        const move = ROCK_MOVES[digit];
        sequence.push(move);
      }

      sequence[0] = "R";
      return sequence;
    }

    function sequenceToReplaySeed(sequence) {
      if (!Array.isArray(sequence) || sequence.length !== 20) return null;
      const digitMap = { R: 0, P: 1, S: 2 };
      let value = 0;
      let factor = 1;

      for (let i = 0; i < sequence.length; i += 1) {
        const digit = digitMap[sequence[i]];
        if (digit === undefined) return null;
        value += digit * factor;
        factor *= 3;
      }

      const candidate = value >>> 0;
      const candidateSequence = generateSeededScriptSequence(candidate).join("");
      const target = sequence.join("");
      if (candidate !== DEFAULT_SEED && candidateSequence === target) return candidate;

      if (target === ORIGINAL_SEED_ONE_SEQUENCE) return DEFAULT_SEED;
      return null;
    }

    let rngGame = null;
    let rngFlavor = null;
    let runSeed = 0;
    let seedWasManual = false;
    let scriptedSequenceOverride = null;
    let seededScriptSequence = [];

    let currentRound = 0;
    let youScore = 0;
    let rockScore = 0;
    let draws = 0;
    let beatRockHits = 0;
    let beatRockAbbrevs = [];
    let lastYourMove = null;

    let rockMood = "Calm";
    let rockLossStreak = 0;

    let adaptiveAttempts = 0;
    let adaptiveCorrectReads = 0;
    let adaptiveEverOnThisRun = false;
    let lastDecisionAdaptive = false;

    let audioCtx = null;
    let sfxEnabled = true;

    let historyLog = [];
    let roundBoardCells = [];
    let activeRoundBoardIndex = null;
    let announcedAchievements = new Set();
    let achievementUnlockCounts = {};
    let sceneState = "lobby";
    let tutorialActive = false;
    let tutorialStepIndex = 0;
    let tutorialCompleted = false;
    let tutorialCurrentTarget = null;
    let roundResultTimer = null;
    let roundPhase = "idle";
    let roundAnimationToken = 0;

    const ROUND_PHASE_DELAYS = {
      lockIn: 280,
      revealRock: 260,
      revealYou: 240,
      resolved: 380
    };
    const reducedMotionQuery = window.matchMedia ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
    const tutorialSteps = [
      {
        id: "moveButtons",
        title: "Step 1 ¬∑ Throw your first hand",
        text: "Start here. Throw Rock, Paper, or Scissors to open your challenge against The Rock.",
        anchor: () => moveButtonsAnchorEl
      },
      {
        id: "moodDisplay",
        title: "Step 2 ¬∑ Read The Rock's mood",
        text: "Watch his state here. Calm, Suspicious, and Paranoid each change his chance to read your next throw.",
        anchor: () => moodDisplayEl
      },
      {
        id: "adaptiveToggle",
        title: "Step 3 ¬∑ Toggle Adaptive Rock",
        text: "Flip Adaptive Rock mode once so you know where to enable his trend reads.",
        anchor: () => adaptiveToggle
      },
      {
        id: "roundBoard",
        title: "Step 4 ¬∑ Inspect the board",
        text: "Hover or focus a round tile to preview exact hands, outcomes, and pathing.",
        anchor: () => roundBoardPreviewEl
      },
      {
        id: "seedShare",
        title: "Step 5 ¬∑ Share and rematch",
        text: "Use Copy Challenge Link or set a seed to share exact showdowns. Walkthrough ends after this step.",
        anchor: () => seedShareAnchorEl
      }
    ];

    function loadPersistentAchievements() {
      try {
        const raw = localStorage.getItem(ACHIEVEMENTS_STORAGE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) return {};
        const counts = {};
        achievementCatalog.forEach(a => {
          const val = parsed[a.id];
          counts[a.id] = Number.isInteger(val) && val > 0 ? val : 0;
        });
        return counts;
      } catch (err) {
        return {};
      }
    }

    function savePersistentAchievements() {
      try {
        localStorage.setItem(ACHIEVEMENTS_STORAGE_KEY, JSON.stringify(achievementUnlockCounts));
      } catch (err) {}
    }

    function resetPersistentAchievements() {
      achievementUnlockCounts = {};
      achievementCatalog.forEach(a => { achievementUnlockCounts[a.id] = 0; });
      savePersistentAchievements();
      renderAchievements();
    }

    function generateRandomSeed() {
      return Math.floor(Math.random() * (U32_MAX + 1));
    }

    function loadTutorialState() {
      try {
        return localStorage.getItem(TUTORIAL_STORAGE_KEY) === "done";
      } catch (err) {
        return false;
      }
    }

    function persistTutorialComplete() {
      tutorialCompleted = true;
      try {
        localStorage.setItem(TUTORIAL_STORAGE_KEY, "done");
      } catch (err) {}
    }

    function clearTutorialTarget() {
      if (!tutorialCurrentTarget) return;
      tutorialCurrentTarget.classList.remove("tutorial-target");
      tutorialCurrentTarget = null;
    }

    function hideTutorialTooltip() {
      tutorialTooltipEl.classList.add("is-hidden");
      clearTutorialTarget();
    }

    function positionTutorialTooltip(targetEl) {
      if (!targetEl) return;
      const rect = targetEl.getBoundingClientRect();
      const maxLeft = window.innerWidth - tutorialTooltipEl.offsetWidth - 10;
      let left = Math.max(10, Math.min(rect.left, maxLeft));
      let top = rect.bottom + 12;
      const maxTop = window.innerHeight - tutorialTooltipEl.offsetHeight - 10;
      if (top > maxTop) top = Math.max(10, rect.top - tutorialTooltipEl.offsetHeight - 12);
      tutorialTooltipEl.style.left = `${left}px`;
      tutorialTooltipEl.style.top = `${top}px`;
    }

    function renderTutorialStep() {
      if (!tutorialActive || tutorialStepIndex >= tutorialSteps.length) {
        hideTutorialTooltip();
        return;
      }

      const step = tutorialSteps[tutorialStepIndex];
      const targetEl = step.anchor && step.anchor();
      if (!targetEl) {
        completeTutorial();
        return;
      }

      tutorialTooltipTitleEl.textContent = step.title;
      tutorialTooltipTextEl.textContent = step.text;
      tutorialTooltipEl.classList.remove("is-hidden");
      clearTutorialTarget();
      tutorialCurrentTarget = targetEl;
      tutorialCurrentTarget.classList.add("tutorial-target");
      positionTutorialTooltip(targetEl);
    }

    function completeTutorial() {
      tutorialActive = false;
      hideTutorialTooltip();
      persistTutorialComplete();
    }

    function advanceTutorialOnAction(actionId) {
      if (!tutorialActive) return;
      const step = tutorialSteps[tutorialStepIndex];
      if (!step || step.id !== actionId) return;
      tutorialStepIndex += 1;
      if (tutorialStepIndex >= tutorialSteps.length) completeTutorial();
      else renderTutorialStep();
    }

    function startTutorial({ replay = false } = {}) {
      tutorialActive = true;
      tutorialStepIndex = 0;
      if (replay) tutorialCompleted = false;
      renderTutorialStep();
    }

    function maybeStartTutorial() {
      tutorialCompleted = loadTutorialState();
      if (!tutorialCompleted) startTutorial();
      else hideTutorialTooltip();
    }

    function buildAchievementState() {
      let maxWinStreak = 0, curW = 0;
      let maxRockStreak = 0, curL = 0;
      let maxDrawStreak = 0, curD = 0;
      let paranoidCount = 0;
      let paranoidWins = 0;
      let rollingYou = 0;
      let rollingRock = 0;
      let maxRockLead = 0;
      const seenMoods = new Set();
      const yourMoves = historyLog.map(entry => entry.yourMove);
      const moveCounts = { R: 0, P: 0, S: 0 };

      historyLog.forEach(entry => {
        if (entry.outcome === "win") { curW += 1; curL = 0; curD = 0; rollingYou += 1; }
        else if (entry.outcome === "lose") { curL += 1; curW = 0; curD = 0; rollingRock += 1; }
        else { curD += 1; curW = 0; curL = 0; }

        maxWinStreak = Math.max(maxWinStreak, curW);
        maxRockStreak = Math.max(maxRockStreak, curL);
        maxDrawStreak = Math.max(maxDrawStreak, curD);
        if (entry.mood === "Paranoid") {
          paranoidCount += 1;
          if (entry.outcome === "win") paranoidWins += 1;
        }
        seenMoods.add(entry.mood);
        if (moveCounts[entry.yourMove] !== undefined) moveCounts[entry.yourMove] += 1;

        maxRockLead = Math.max(maxRockLead, rollingRock - rollingYou);
      });

      const noLossesFirstFive = historyLog.slice(0, 5).every(entry => entry.outcome !== "lose");
      const lastThreeAreWins = historyLog.length >= 3 && historyLog.slice(-3).every(entry => entry.outcome === "win");
      const lostFirstThree = historyLog.length >= 3 && historyLog.slice(0, 3).every(entry => entry.outcome === "lose");
      const firstThreeUnique = historyLog.length >= 3 && new Set(historyLog.slice(0, 3).map(entry => entry.yourMove)).size === 3;
      const openedNonPaper = historyLog.length >= 1 && historyLog[0].yourMove !== "P";
      const lossMargin = Math.max(0, rockScore - youScore);
      const onlyRock = historyLog.length === 20 && yourMoves.every(move => move === "R");
      const onlyPaper = historyLog.length === 20 && yourMoves.every(move => move === "P");
      const onlyScissors = historyLog.length === 20 && yourMoves.every(move => move === "S");
      const noConsecutiveSameMove = historyLog.length === 20 && yourMoves.every((move, idx) => idx === 0 || move !== yourMoves[idx - 1]);
      const minMoveCount = Math.min(moveCounts.R, moveCounts.P, moveCounts.S);
      const palindromeShape = historyLog.length === 20 && yourMoves.every((move, idx) => move === yourMoves[yourMoves.length - 1 - idx]);
      const firstHalfTransitions = historyLog.length >= 10 ? yourMoves.slice(0, 10).reduce((count, move, idx, arr) => idx === 0 ? 0 : count + (move !== arr[idx - 1] ? 1 : 0), 0) : 0;
      const complexPalindromeMoves = palindromeShape && firstHalfTransitions >= 4;

      return {
        historyLog,
        maxWinStreak,
        maxRockStreak,
        maxLoseStreak: maxRockStreak,
        maxDrawStreak,
        paranoidCount,
        paranoidWins,
        noLossesFirstFive,
        lastThreeAreWins,
        lostFirstThree,
        firstThreeUnique,
        openedNonPaper,
        lossMargin,
        onlyRock,
        onlyPaper,
        onlyScissors,
        noConsecutiveSameMove,
        minMoveCount,
        complexPalindromeMoves,
        maxRockLead,
        seenMoods,
        youScore,
        rockScore,
        draws,
        beatRockHits,
        seedWasManual,
        adaptiveEverOnThisRun,
        adaptiveAttempts,
        adaptiveCorrectReads,
        matchFinished: historyLog.length === 20
      };
    }

    function getUnlockedAchievementDefs() {
      const state = buildAchievementState();
      return achievementCatalog.filter(achievement => achievement.unlocked(state));
    }

    function ensureAudioContext() {
      if (audioCtx) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (AudioContext) audioCtx = new AudioContext();
    }

    function playBeep(type) {
      if (!sfxEnabled) return;
      try {
        ensureAudioContext();
        if (!audioCtx || audioCtx.state === "suspended") {
          audioCtx.resume && audioCtx.resume();
        }
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 440;
        if (type === "win") freq = 880;
        if (type === "lose") freq = 260;
        if (type === "draw") freq = 380;

        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.15, audioCtx.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
      } catch (e) {}
    }

    function randomFromFlavor(arr) {
      const r = rngFlavor ? rngFlavor() : Math.random();
      return arr[Math.floor(r * arr.length)];
    }

    function describeRound(outcome, beatRockThisRound) {
      let base;
      if (outcome === "win") base = randomFromFlavor(rockLosingQuips);
      else if (outcome === "lose") base = randomFromFlavor(rockWinningQuips);
      else base = randomFromFlavor(drawQuips);

      let extra = "";
      if (beatRockThisRound && outcome === "win") extra = " " + randomFromFlavor(beatRockQuips);
      else if (!beatRockThisRound && outcome === "win") extra = " " + randomFromFlavor(missedBeatRockQuips);

      return base + extra;
    }

    function moveRoundBoardFocus(index) {
      if (index < 0 || index >= roundBoardCells.length) return;
      roundBoardCells[index].focus();
    }

    function createRoundBoardCells() {
      roundBoardEl.innerHTML = "";
      roundBoardCells = [];
      for (let i = 0; i < 20; i++) {
        const cell = document.createElement("div");
        cell.className = "round-box";
        cell.tabIndex = 0;
        cell.setAttribute("role", "button");
        cell.setAttribute("aria-label", `Round ${i + 1}, not played yet.`);
        cell.addEventListener("mouseenter", () => handleRoundBoardHover(i));
        cell.addEventListener("mouseleave", () => clearRoundBoardHover(i));
        cell.addEventListener("focus", () => handleRoundBoardHover(i));
        cell.addEventListener("blur", () => clearRoundBoardHover(i));
        cell.addEventListener("click", () => handleRoundBoardHover(i));
        cell.addEventListener("keydown", (event) => {
          if (event.key === "ArrowRight" || event.key === "ArrowDown") {
            event.preventDefault();
            moveRoundBoardFocus(i + 1);
          } else if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
            event.preventDefault();
            moveRoundBoardFocus(i - 1);
          } else if (event.key === "Home") {
            event.preventDefault();
            moveRoundBoardFocus(0);
          } else if (event.key === "End") {
            event.preventDefault();
            moveRoundBoardFocus(roundBoardCells.length - 1);
          } else if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            handleRoundBoardHover(i);
          }
        });
        roundBoardEl.appendChild(cell);
        roundBoardCells.push(cell);
      }
    }

    function renderRoundBoard() {
      roundBoardCells.forEach((cell, i) => {
        const entry = historyLog[i];
        cell.className = "round-box";
        if (i === currentRound && currentRound < 20) cell.classList.add("current");

        if (!entry) {
          cell.innerHTML = `<span class="round-num">R${i + 1}</span><span class="round-hands">¬∑</span><span class="round-outcome">¬∑</span>`;
          cell.setAttribute("aria-label", `Round ${i + 1}, not played yet.`);
          return;
        }

        const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
        const resultMark = entry.outcome === "win" ? "W" : entry.outcome === "lose" ? "L" : "D";

        cell.classList.add("played", entry.outcome);
        cell.innerHTML =
          `<span class="round-num">R${entry.round}</span>` +
          `<span class="round-hands">${glyph[entry.rockMove]}${glyph[entry.yourMove]}</span>` +
          `<span class="round-outcome">${resultMark}</span>`;
        cell.setAttribute("aria-label", `Round ${entry.round}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${outcomeText}.`);
      });

      if (currentRound >= 20) roundBoardStatusEl.textContent = "All 20 rounds complete";
      else roundBoardStatusEl.textContent = `Round ${currentRound + 1} is live`;

      if (activeRoundBoardIndex !== null && roundBoardCells[activeRoundBoardIndex]) {
        roundBoardCells[activeRoundBoardIndex].classList.add("current");
      }
    }

    function handleRoundBoardHover(index) {
      advanceTutorialOnAction("roundBoard");
      if (index >= historyLog.length) {
        roundBoardPreviewEl.innerHTML = `<strong>Round ${index + 1}</strong> not played yet in this run.`;
        return;
      }
      const entry = historyLog[index];
      activeRoundBoardIndex = index;
      const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
      const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
      roundBoardPreviewEl.innerHTML =
        `<strong>Round ${entry.round}</strong>, Dwayne ${names[entry.rockMove]} (${glyph[entry.rockMove]}) vs you ` +
        `${names[entry.yourMove]} (${glyph[entry.yourMove]}), outcome ${outcomeText}, state ${entry.mood}, ${pathText}.`;
    }

    function clearRoundBoardHover(index) {
      if (activeRoundBoardIndex === index) activeRoundBoardIndex = null;
      if (historyLog.length === 0) {
        roundBoardPreviewEl.textContent = "Hover, focus, or tap a played round to preview exact hands, outcome, and mood.";
      } else {
        const last = historyLog[historyLog.length - 1];
        const outcomeText = last.outcome === "win" ? "you win" : last.outcome === "lose" ? "The Rock wins" : "draw";
        roundBoardPreviewEl.innerHTML = `<strong>Last round</strong> was ${last.round}, outcome ${outcomeText}. Hover any played round for detail.`;
      }
    }

    function openDrawerPanel(panelEl, { highlight = false } = {}) {
      if (!panelEl) return;
      panelEl.open = true;
      if (!highlight) return;
      panelEl.classList.add("highlighted");
      setTimeout(() => panelEl.classList.remove("highlighted"), 1500);
    }

    function setScene(nextScene) {
      sceneState = nextScene;
      sceneLobbyEl.classList.toggle("is-hidden", nextScene !== "lobby");
      sceneGameEl.classList.toggle("is-hidden", nextScene === "lobby");
      sceneSummaryEl.classList.toggle("is-hidden", nextScene !== "matchSummary");
      document.body.classList.toggle("gameplay-active", nextScene === "inRound" || nextScene === "roundResult");
      if (tutorialActive) renderTutorialStep();
    }

    function showRoundResultOverlay(text) {
      if (roundResultTimer) {
        clearTimeout(roundResultTimer);
        roundResultTimer = null;
      }
      roundResultOverlayTextEl.textContent = text;
      roundResultOverlayEl.classList.remove("is-hidden");
      setScene("roundResult");
      roundResultTimer = setTimeout(() => {
        roundResultOverlayEl.classList.add("is-hidden");
        if (currentRound >= 20) setScene("matchSummary");
        else setScene("inRound");
      }, 700);
    }

    function openGameMenu() {
      gameMenuModal.classList.add("is-active");
      gameMenuBtn.setAttribute("aria-expanded", "true");
    }

    function closeGameMenu() {
      gameMenuModal.classList.remove("is-active");
      gameMenuBtn.setAttribute("aria-expanded", "false");
    }

    function isModalInputFocused(target) {
      if (!target || !(target instanceof Element)) return false;
      if (!gameMenuModal.contains(target)) return false;
      const tag = target.tagName;
      return tag === "INPUT" || tag === "TEXTAREA" || target.isContentEditable;
    }

    function setButtonsEnabled(enabled) { moveButtons.forEach(btn => btn.disabled = !enabled); }
    function setRoundPhase(phase) { roundPhase = phase; }
    function prefersReducedMotion() { return !!(reducedMotionQuery && reducedMotionQuery.matches); }
    function getPhaseDelay(ms) { return prefersReducedMotion() ? 0 : ms; }
    function waitForPhase(ms) {
      const duration = getPhaseDelay(ms);
      if (!duration) return Promise.resolve();
      return new Promise(resolve => setTimeout(resolve, duration));
    }

    function resetArenaPhaseClasses() {
      arenaEl.classList.remove("phase-lock-in", "phase-reveal");
      rockHandEl.classList.remove("reveal-pop");
      yourHandEl.classList.remove("reveal-pop");
    }

    function updateRoundLabel() { roundLabelEl.textContent = `Round ${Math.min(currentRound + 1, 20)} of 20`; }
    function updateScoreLabel() { scoreLabelEl.textContent = `The Rock ${rockScore}  |  You ${youScore}  |  Draws ${draws}`; }
    function updateProgressBar() {
      const pct = (currentRound / 20) * 100;
      progressFillEl.style.width = `${pct}%`;
      progressTextEl.textContent = `${currentRound} of 20 completed`;
    }
    function updateRunSummary() {
      runSummarySeedEl.textContent = `Seed ${runSeed}`;
      runSummaryModeEl.textContent = adaptiveToggle.checked ? "Adaptive on" : "Scripted";
      const runStarted = currentRound > 0 || sceneState === "inRound" || sceneState === "roundResult" || sceneState === "matchSummary";
      runSummaryPillEl.classList.toggle("is-hidden", !runStarted);
    }

    function showCopyStatus(message, isError) {
      copyStatusEl.textContent = message;
      copyStatusEl.classList.toggle("error", !!isError);
      if (showCopyStatus.timer) clearTimeout(showCopyStatus.timer);
      showCopyStatus.timer = setTimeout(() => {
        copyStatusEl.textContent = "";
        copyStatusEl.classList.remove("error");
      }, 2400);
    }

    function buildChallengeLink() {
      const url = new URL(window.location.href);
      const adaptiveRunSequence = historyLog.length === 20 && historyLog.some(entry => entry.adaptiveUsed)
        ? historyLog.map(entry => entry.rockMove).join("")
        : null;

      url.searchParams.set("seed", String(runSeed));
      if (adaptiveRunSequence) {
        url.searchParams.set("script", adaptiveRunSequence);
        url.searchParams.set("adaptive", "0");
      } else {
        url.searchParams.delete("script");
        url.searchParams.set("adaptive", adaptiveToggle.checked ? "1" : "0");
      }
      url.searchParams.set("sfx", sfxToggle.checked ? "1" : "0");
      return url.toString();
    }

    function fallbackCopyText(text) {
      const tempInput = document.createElement("input");
      tempInput.type = "text";
      tempInput.value = text;
      tempInput.setAttribute("readonly", "readonly");
      tempInput.style.position = "fixed";
      tempInput.style.opacity = "0";
      document.body.appendChild(tempInput);
      tempInput.focus();
      tempInput.select();
      tempInput.setSelectionRange(0, tempInput.value.length);
      const copied = document.execCommand("copy");
      document.body.removeChild(tempInput);
      return copied;
    }

    async function copyChallengeLink() {
      const challengeLink = buildChallengeLink();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(challengeLink);
          showCopyStatus("Challenge link copied to clipboard.", false);
          return;
        }
      } catch (err) {}

      const copied = fallbackCopyText(challengeLink);
      if (copied) showCopyStatus("Challenge link copied to clipboard.", false);
      else showCopyStatus("Could not copy. Please copy manually.", true);
    }

    function readInitialSettingsFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const seedParam = params.get("seed");
      const scriptParam = params.get("script");
      const adaptiveParam = params.get("adaptive");
      const sfxParam = params.get("sfx");

      let scriptOverride = null;
      if (scriptParam && SCRIPT_SEQUENCE_REGEX.test(scriptParam)) {
        scriptOverride = scriptParam.toUpperCase().split("");
        scriptOverride[0] = "R";
      }

      if (scriptOverride) {
        adaptiveToggle.checked = false;
      } else if (adaptiveParam === "1" || adaptiveParam === "0") {
        adaptiveToggle.checked = adaptiveParam === "1";
      }
      if (sfxParam === "1" || sfxParam === "0") {
        sfxToggle.checked = sfxParam === "1";
      }
      sfxEnabled = sfxToggle.checked;

      if (seedParam === null) return { seed: null, manual: false, scriptOverride };
      const normalizedSeed = normalizeSeed(seedParam);
      if (!normalizedSeed.valid) return { seed: null, manual: false, scriptOverride };
      return { seed: normalizedSeed.seed, manual: true, scriptOverride };
    }

    function shakeArena() {
      if (prefersReducedMotion()) return;
      arenaEl.classList.remove("shake");
      void arenaEl.offsetWidth;
      arenaEl.classList.add("shake");
      setTimeout(() => arenaEl.classList.remove("shake"), 350);
    }

    function updateAdaptiveStats() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (!adaptiveToggle.checked) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> is off. If enabled, The Rock in ${rockMood} mood would have a ${adaptPct}% read chance.`;
        return;
      }
      if (adaptiveAttempts === 0) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> mood projects a ${adaptPct}% read chance this round. Attempts will appear once he starts adapting.`;
        return;
      }
      const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
      adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> this round: ${adaptPct}% read chance ¬∑ attempts ${adaptiveAttempts} ¬∑ correct reads ${adaptiveCorrectReads} ¬∑ accuracy ${acc}%.`;
    }

    function updateMoodDisplay() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      const moodMeta = {
        Calm: { emoji: "üòå", severity: "severity-low", label: "CALM" },
        Suspicious: { emoji: "ü§®", severity: "severity-mid", label: "SUSPICIOUS" },
        Paranoid: { emoji: "üò§", severity: "severity-high", label: "PARANOID" }
      };
      const activeMeta = moodMeta[rockMood] || moodMeta.Calm;
      moodDisplayEl.classList.remove("severity-low", "severity-mid", "severity-high");
      moodDisplayEl.classList.add(activeMeta.severity);
      const riskText = adaptiveToggle.checked ? `Read risk ${adaptPct}%` : "Adaptive off";
      moodDisplayEl.innerHTML = `
        <span class="mood-emoji" aria-hidden="true">${activeMeta.emoji}</span>
        <span class="mood-text">
          <span class="mood-label">The Rock's state</span>
          <span class="mood-state">${activeMeta.label}</span>
          <span class="mood-risk">${riskText}</span>
        </span>
      `;
    }

    function updatePreRoundHint() {
      if (currentRound >= 20) {
        preRoundHintEl.textContent = "Showdown complete. Check the round board for every throw and read.";
        return;
      }
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (!adaptiveToggle.checked || currentRound === 0 || !lastYourMove) {
        preRoundHintEl.textContent = `Scout report: ${rockMood.toLowerCase()} energy. Scripted lane is most likely this round.`;
        return;
      }
      if (rockMood === "Calm") preRoundHintEl.textContent = `Scout report: calm but alert, ${adaptPct}% chance he reads you this round.`;
      else if (rockMood === "Suspicious") preRoundHintEl.textContent = `Scout report: suspicious and aggressive, ${adaptPct}% chance he targets your last hand.`;
      else preRoundHintEl.textContent = `Scout report: full paranoid mode, ${adaptPct}% chance he hard-counters your last hand.`;
    }

    function renderDebugLog() {
      debugLogEl.innerHTML = "";
      historyLog.forEach(entry => {
        const div = document.createElement("div");
        div.className = "debug-log-entry";
        const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
        div.textContent =
          `Round ${entry.round}, state ${entry.mood}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${entry.outcome}, beat The Rock move ${names[entry.beatRockMove]}, ${pathText}.`;
        debugLogEl.appendChild(div);
      });
    }

    function moodAdaptChance() { return rockMood === "Calm" ? 0.3 : rockMood === "Suspicious" ? 0.6 : 0.9; }

    function weightedRandomMove(weightMap) {
      const entries = ROCK_MOVES.map(move => [move, Math.max(0, Number(weightMap[move] || 0))]);
      const total = entries.reduce((sum, [, weight]) => sum + weight, 0);
      if (total <= 0) return ROCK_MOVES[Math.floor((rngGame ? rngGame() : Math.random()) * ROCK_MOVES.length)] || "R";

      const roll = (rngGame ? rngGame() : Math.random()) * total;
      let running = 0;
      for (const [move, weight] of entries) {
        running += weight;
        if (roll <= running) return move;
      }
      return entries[entries.length - 1][0];
    }

    function getRecentPlayerMoveBias() {
      const counts = { R: 0, P: 0, S: 0 };
      const recent = historyLog.slice(-5);
      recent.forEach(entry => { counts[entry.yourMove] += 1; });

      if (lastYourMove) counts[lastYourMove] += 1;

      const topMove = ROCK_MOVES.reduce((best, move) => counts[move] > counts[best] ? move : best, "R");
      return { counts, topMove, topCount: counts[topMove] };
    }

    function getAdaptiveMoveFromStatus(scriptMove) {
      const scoreDiff = youScore - rockScore;
      const { topMove, topCount } = getRecentPlayerMoveBias();
      const counterLast = lastYourMove ? beats[lastYourMove] : scriptMove;
      const counterTrend = beats[topMove];
      const bluffMove = beats[counterTrend];
      const antiScriptMove = beats[scriptMove];

      const weights = {
        [scriptMove]: rockMood === "Calm" ? 1.8 : 1.0,
        [counterLast]: 2.1,
        [counterTrend]: 1.7,
        [bluffMove]: 0.95,
        [antiScriptMove]: 0.75
      };

      if (rockMood === "Paranoid") weights[counterLast] += 1.4;
      if (rockMood === "Suspicious") weights[counterTrend] += 0.8;
      if (scoreDiff >= 2) {
        weights[counterLast] += 1.1;
        weights[counterTrend] += 0.7;
      }
      if (scoreDiff <= -2) {
        weights[scriptMove] += 0.7;
        weights[bluffMove] += 0.8;
      }
      if (topCount >= 3) weights[counterTrend] += 1.3;

      const lastOutcomes = historyLog.slice(-3).map(entry => entry.outcome);
      const recentLosses = lastOutcomes.filter(outcome => outcome === "win").length;
      const recentRockWins = lastOutcomes.filter(outcome => outcome === "lose").length;
      if (recentLosses >= 2) {
        weights[counterLast] += 0.9;
        weights[counterTrend] += 0.8;
      }
      if (recentRockWins >= 2) {
        weights[scriptMove] += 0.9;
        weights[bluffMove] += 0.5;
      }

      return weightedRandomMove(weights);
    }

    function updateRockMood(outcome) {
      if (outcome === "win") rockLossStreak += 1;
      else if (outcome === "lose") rockLossStreak = 0;
      else rockLossStreak = Math.max(0, rockLossStreak - 1);

      if (rockLossStreak >= 3) rockMood = "Paranoid";
      else if (rockLossStreak >= 1) rockMood = "Suspicious";
      else rockMood = "Calm";
    }

    function getRockMoveForRound() {
      const scriptMove = scriptedSequenceOverride ? scriptedSequenceOverride[currentRound] : seededScriptSequence[currentRound];

      if (currentRound === 0) {
        lastDecisionAdaptive = false;
        return "R";
      }

      const adaptive = adaptiveToggle.checked;
      if (!adaptive || !lastYourMove) {
        lastDecisionAdaptive = false;
        return scriptMove;
      }

      const r = rngGame ? rngGame() : Math.random();
      if (r < moodAdaptChance()) {
        lastDecisionAdaptive = true;
        adaptiveAttempts += 1;
        return getAdaptiveMoveFromStatus(scriptMove);
      }

      lastDecisionAdaptive = false;
      return scriptMove;
    }

    function isGameActive() { return currentRound < 20 && !moveButtons[0].disabled; }

    async function playRound(yourMove) {
      if (currentRound >= 20) return;
      if (roundPhase !== "idle") return;
      setScene("inRound");
      if (adaptiveToggle.checked) adaptiveEverOnThisRun = true;
      roundAnimationToken += 1;
      const phaseToken = roundAnimationToken;

      setRoundPhase("lockIn");
      setButtonsEnabled(false);
      resultLineEl.textContent = "The Rock is choosing...";
      resultLineEl.className = "result-line";
      commentaryEl.textContent = "The Rock is choosing...";

      resetArenaPhaseClasses();
      arenaEl.classList.add("phase-lock-in");
      await waitForPhase(ROUND_PHASE_DELAYS.lockIn);
      if (phaseToken !== roundAnimationToken) return;
      arenaEl.classList.remove("phase-lock-in");

      const moodBefore = rockMood;
      const rockMove = getRockMoveForRound();
      lastYourMove = yourMove;

      setRoundPhase("reveal");
      arenaEl.classList.add("phase-reveal");

      rockHandEl.textContent = glyph[rockMove];
      rockMoveLabelEl.textContent = names[rockMove];
      rockHandEl.classList.remove("reveal-pop");
      void rockHandEl.offsetWidth;
      rockHandEl.classList.add("reveal-pop");
      await waitForPhase(ROUND_PHASE_DELAYS.revealRock);
      if (phaseToken !== roundAnimationToken) return;

      yourHandEl.textContent = glyph[yourMove];
      yourMoveLabelEl.textContent = names[yourMove];
      yourHandEl.classList.remove("reveal-pop");
      void yourHandEl.offsetWidth;
      yourHandEl.classList.add("reveal-pop");
      await waitForPhase(ROUND_PHASE_DELAYS.revealYou);
      if (phaseToken !== roundAnimationToken) return;

      setRoundPhase("resolved");

      const beatRockMove = beats[rockMove];
      beatRockAbbrevs.push(names[beatRockMove][0]);

      let outcome;
      if (yourMove === rockMove) {
        outcome = "draw"; draws += 1;
        resultLineEl.textContent = "Round result: draw."; resultLineEl.className = "result-line result-draw";
        playBeep("draw");
      } else if (beats[rockMove] === yourMove) {
        outcome = "win"; youScore += 1;
        resultLineEl.textContent = "Round result: you win."; resultLineEl.className = "result-line result-win";
        playBeep("win"); shakeArena();
      } else {
        outcome = "lose"; rockScore += 1;
        resultLineEl.textContent = "Round result: The Rock wins."; resultLineEl.className = "result-line result-lose";
        playBeep("lose");
      }

      if (lastDecisionAdaptive && beats[yourMove] === rockMove) adaptiveCorrectReads += 1;

      const beatRockThisRound = yourMove === beatRockMove;
      if (beatRockThisRound) beatRockHits += 1;

      updateRockMood(outcome);
      updateMoodDisplay();
      advanceTutorialOnAction("moodDisplay");

      commentaryEl.textContent = describeRound(outcome, beatRockThisRound);

      historyLog.push({
        round: currentRound + 1,
        rockMove, yourMove, beatRockMove,
        outcome,
        adaptiveUsed: lastDecisionAdaptive,
        adaptiveCorrect: lastDecisionAdaptive && (beats[yourMove] === rockMove),
        mood: moodBefore,
        beatRockThisRound
      });

      renderDebugLog();

      currentRound += 1;
      renderRoundBoard();
      updateScoreLabel();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateRunSummary();
      updatePreRoundHint();
      evaluateAchievements();

      const overlayText = outcome === "win" ? "Round result: you win." : outcome === "lose" ? "Round result: The Rock wins." : "Round result: draw.";
      showRoundResultOverlay(overlayText);

      if (currentRound >= 20) {
        setButtonsEnabled(false);
        showFinalSummary();
        resetArenaPhaseClasses();
        setRoundPhase("idle");
        return;
      }

      await waitForPhase(ROUND_PHASE_DELAYS.resolved);
      if (phaseToken !== roundAnimationToken) return;
      resetArenaPhaseClasses();
      setRoundPhase("idle");
      setButtonsEnabled(true);
    }

    function evaluateAchievements() {
      const newlyUnlocked = getUnlockedAchievementDefs();
      newlyUnlocked.forEach(achievement => {
        if (announcedAchievements.has(achievement.id)) return;
        announcedAchievements.add(achievement.id);

        const currentCount = achievementUnlockCounts[achievement.id] || 0;
        const nextCount = currentCount + 1;
        achievementUnlockCounts[achievement.id] = nextCount;
        savePersistentAchievements();
        showAchievementToast(achievement, nextCount);
      });
      if (newlyUnlocked.length > 0) openDrawerPanel(achievementsPanelEl, { highlight: true });
      renderAchievements();
    }

    function showAchievementToast(achievement, count) {
      const toast = document.createElement("div");
      toast.className = "achievement-toast rank-" + achievement.rank;
      toast.innerHTML = `<strong>Achievement unlocked x${count}:</strong> ${achievement.name}<br />${achievement.text}`;
      achievementToastsEl.appendChild(toast);
      setTimeout(() => {
        toast.style.opacity = "0";
        toast.style.transform = "translateX(10px)";
        setTimeout(() => toast.remove(), 260);
      }, 2600);
    }

    function renderAchievements() {
      achievementsListEl.innerHTML = "";
      const earned = achievementCatalog.filter(a => (achievementUnlockCounts[a.id] || 0) > 0);

      if (earned.length === 0) {
        achievementsListEl.textContent = "No achievements earned yet. Start a run and unlock one to reveal it here.";
        return;
      }

      earned.forEach(a => {
        const count = achievementUnlockCounts[a.id] || 0;
        const div = document.createElement("div");
        div.className = "achievement-badge rank-" + a.rank;
        div.innerHTML = `<span class="achievement-multiplier">x${count}</span><strong>${a.name}</strong><br />${a.text}`;
        achievementsListEl.appendChild(div);
      });
    }

    function calculateRunHighlights() {
      const achievementState = buildAchievementState();
      const moodPressureMoments = historyLog.filter(entry => entry.mood === "Suspicious" || entry.mood === "Paranoid").length;
      const beatRockRate = historyLog.length > 0 ? Math.round((beatRockHits / historyLog.length) * 100) : 0;
      return { achievementState, moodPressureMoments, beatRockRate };
    }

    function renderPostMatchSummary() {
      const { achievementState, moodPressureMoments, beatRockRate } = calculateRunHighlights();
      const runAchievements = getUnlockedAchievementDefs();
      const youWon = youScore > rockScore;
      const rockWon = rockScore > youScore;

      summaryWinnerBannerEl.className = "post-match-banner";
      if (youWon) {
        summaryWinnerBannerEl.classList.add("you-win");
        summaryWinnerBannerEl.textContent = "Winner: You";
        summaryTitleEl.textContent = "You beat The Rock";
        summaryFlavorEl.textContent = "You out-read The Rock over 20 rounds. Queue the rematch before he rewrites the script.";
      } else if (rockWon) {
        summaryWinnerBannerEl.classList.add("rock-win");
        summaryWinnerBannerEl.textContent = "Winner: The Rock";
        summaryTitleEl.textContent = "The Rock holds the spotlight";
        summaryFlavorEl.textContent = "He held the line this run. New seed, new plan, same arena when you hit Play Again.";
      } else {
        summaryWinnerBannerEl.classList.add("draw-match");
        summaryWinnerBannerEl.textContent = "Result: Draw";
        summaryTitleEl.textContent = "Even score at the final bell";
        summaryFlavorEl.textContent = "Nobody blinked. One more run decides who owns this timeline.";
      }

      summaryBestStreakEl.textContent = `${achievementState.maxWinStreak} win${achievementState.maxWinStreak === 1 ? "" : "s"}`;
      summaryBeatRockRateEl.textContent = `${beatRockRate}% (${beatRockHits}/${historyLog.length || 20})`;
      summaryMoodPressureEl.textContent = `${moodPressureMoments} rounds`;

      summaryAchievementsListEl.innerHTML = "";
      if (runAchievements.length === 0) {
        summaryAchievementsListEl.classList.add("is-hidden");
        summaryAchievementsEmptyEl.classList.remove("is-hidden");
      } else {
        summaryAchievementsListEl.classList.remove("is-hidden");
        summaryAchievementsEmptyEl.classList.add("is-hidden");
        runAchievements.forEach(achievement => {
          const li = document.createElement("li");
          li.textContent = achievement.name;
          summaryAchievementsListEl.appendChild(li);
        });
      }
    }

    function jumpToRoundBoardFromSummary() {
      setScene("inRound");
      openDrawerPanel(statsPanelEl, { highlight: true });
      if (historyLog.length > 0) handleRoundBoardHover(historyLog.length - 1);
      roundBoardEl.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block: "center" });
    }

    function showFinalSummary() {
      const summaryLines = [];
      summaryLines.push(`Final score after 20 rounds: The Rock ${rockScore}, You ${youScore}, Draws ${draws}.`);
      summaryLines.push(`You beat The Rock ${beatRockHits} out of 20 rounds.`);
      summaryLines.push(`Beat-The-Rock sequence for this showdown: ${beatRockAbbrevs.join(" ")}.`);
      summaryLines.push(`Legend: R Rock, P Paper, S Scissors.`);

      if (adaptiveEverOnThisRun && adaptiveAttempts > 0) {
        const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
        summaryLines.push(`Adaptive Rock made ${adaptiveAttempts} read attempts, with ${adaptiveCorrectReads} correct, accuracy ${acc} percent.`);
      }

      if (adaptiveEverOnThisRun && historyLog.length === 20) {
        const adaptiveSequence = historyLog.map(entry => entry.rockMove);
        const replaySeed = sequenceToReplaySeed(adaptiveSequence);
        if (replaySeed !== null) {
          seedInputEl.value = String(replaySeed);
          seedFeedbackEl.className = "seed-feedback info";
          seedFeedbackEl.textContent = `Adaptive replay seed generated: ${replaySeed}. Start a new showdown to replay this sequence in scripted mode.`;
          summaryLines.push(`Replay seed generated for this adaptive sequence, ${replaySeed}.`);
        } else {
          summaryLines.push("Could not generate a scripted replay seed for this adaptive sequence.");
        }
      }

      const runAchievements = getUnlockedAchievementDefs();
      if (runAchievements.length > 0) summaryLines.push(`Achievements unlocked this run, ${runAchievements.map(a => a.name).join(", ")}.`);
      else summaryLines.push("No achievements this time, try different seeds or adaptive settings.");

      summaryLines.push("Use the unified round board or round log to review every move and state.");
      commentaryEl.textContent = summaryLines.join(" ");

      renderAchievements();
      openDrawerPanel(statsPanelEl);
      openDrawerPanel(achievementsPanelEl, { highlight: true });
      if (historyLog.length > 0) handleRoundBoardHover(historyLog.length - 1);
      resetBtn.style.display = "none";
      renderPostMatchSummary();
      setScene("matchSummary");
    }

    function initFromSeed(seed, manualFlag, scriptOverride) {
      runSeed = seed >>> 0;
      seedWasManual = !!manualFlag;
      scriptedSequenceOverride = scriptOverride || null;
      seededScriptSequence = generateSeededScriptSequence(runSeed);

      rngGame = mulberry32(runSeed);
      rngFlavor = mulberry32(runSeed ^ 0x9E3779B9);

      if (scriptedSequenceOverride) {
        adaptiveToggle.checked = false;
        adaptiveToggle.disabled = true;
      } else {
        adaptiveToggle.disabled = false;
      }

      currentRound = 0;
      youScore = 0;
      rockScore = 0;
      draws = 0;
      beatRockHits = 0;
      beatRockAbbrevs = [];
      lastYourMove = null;

      adaptiveAttempts = 0;
      adaptiveCorrectReads = 0;
      adaptiveEverOnThisRun = false;
      lastDecisionAdaptive = false;

      rockMood = "Calm";
      rockLossStreak = 0;

      historyLog = [];
      debugLogEl.innerHTML = "";
      announcedAchievements = new Set();
      achievementToastsEl.innerHTML = "";
      renderAchievements();

      rockHandEl.textContent = "‚ùî";
      yourHandEl.textContent = "‚ùî";
      rockMoveLabelEl.textContent = "Awaiting the opening bell.";
      yourMoveLabelEl.textContent = "Pick your opening throw.";
      resultLineEl.textContent = "";
      resultLineEl.className = "result-line";
      commentaryEl.textContent = "";

      createRoundBoardCells();
      renderRoundBoard();
      roundBoardPreviewEl.textContent = "Hover, focus, or tap a played round to preview exact hands, outcome, and mood.";

      updateScoreLabel();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateMoodDisplay();
      updatePreRoundHint();
      updateRunSummary();

      if (scriptedSequenceOverride) {
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = "Scripted challenge loaded from a shared adaptive showdown. Adaptive mode is locked for exact replay.";
      }

      statsPanelEl.open = true;
      achievementsPanelEl.open = false;
      replaySeedPanelEl.open = false;
      debugPanelEl.open = false;
      setButtonsEnabled(false);
      resetBtn.style.display = "none";
      roundResultOverlayEl.classList.add("is-hidden");
      if (roundResultTimer) {
        clearTimeout(roundResultTimer);
        roundResultTimer = null;
      }
      roundAnimationToken += 1;
      setRoundPhase("idle");
      resetArenaPhaseClasses();
      setScene("lobby");
    }

    function resetGame() {
      const value = seedInputEl.value.trim();
      let newSeed;
      let manual = false;

      if (value === "") {
        newSeed = generateRandomSeed();
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = `Randomized seed for this showdown: ${newSeed}.`;
      } else {
        const normalizedSeed = normalizeSeed(value);
        if (!normalizedSeed.valid) {
          seedFeedbackEl.className = "seed-feedback error";
          seedFeedbackEl.textContent = "Invalid seed. Use digits only (0‚Äì4294967295).";
          return;
        }

        newSeed = normalizedSeed.seed;
        manual = true;

        seedFeedbackEl.className = "seed-feedback info";
        if (normalizedSeed.clamped) seedFeedbackEl.textContent = `Seed clamped to unsigned 32-bit range. Starting showdown with normalized seed ${newSeed}.`;
        else seedFeedbackEl.textContent = `Starting showdown with normalized seed ${newSeed}.`;
      }

      initFromSeed(newSeed, manual, null);
    }

    startMatchBtn.addEventListener("click", () => {
      setScene("inRound");
      setButtonsEnabled(true);
      updateRunSummary();
      moveButtons[0].focus();
    });

    moveButtons.forEach(btn => btn.addEventListener("click", () => {
      if (!isGameActive()) return;
      advanceTutorialOnAction("moveButtons");
      playRound(btn.getAttribute("data-move"));
    }));

    resetBtn.addEventListener("click", resetGame);
    summaryPlayAgainBtn.addEventListener("click", resetGame);
    summaryCopyLinkBtn.addEventListener("click", copyChallengeLink);
    summaryViewBoardBtn.addEventListener("click", jumpToRoundBoardFromSummary);
    randomSeedBtn.addEventListener("click", () => {
      const generatedSeed = generateRandomSeed();
      seedInputEl.value = String(generatedSeed);
      seedFeedbackEl.className = "seed-feedback info";
      seedFeedbackEl.textContent = `Generated seed ${generatedSeed}. Start a new showdown to use it.`;
    });
    resetAchievementsBtn.addEventListener("click", () => {
      resetPersistentAchievements();
      seedFeedbackEl.className = "seed-feedback info";
      seedFeedbackEl.textContent = "Achievements reset for this browser profile.";
    });
    adaptiveToggle.addEventListener("change", () => { advanceTutorialOnAction("adaptiveToggle"); updateAdaptiveStats(); updateMoodDisplay(); updatePreRoundHint(); updateRunSummary(); });
    moodDisplayEl.addEventListener("click", () => advanceTutorialOnAction("moodDisplay"));
    sfxToggle.addEventListener("change", () => { sfxEnabled = sfxToggle.checked; });
    copyLinkBtn.addEventListener("click", () => {
      advanceTutorialOnAction("seedShare");
      copyChallengeLink();
    });
    seedInputEl.addEventListener("focus", () => advanceTutorialOnAction("seedShare"));
    randomSeedBtn.addEventListener("click", () => advanceTutorialOnAction("seedShare"));
    replayTutorialBtn.addEventListener("click", () => {
      closeGameMenu();
      startTutorial({ replay: true });
    });
    tutorialSkipBtn.addEventListener("click", completeTutorial);
    window.addEventListener("resize", () => { if (tutorialActive) renderTutorialStep(); });
    window.addEventListener("scroll", () => { if (tutorialActive) renderTutorialStep(); }, { passive: true });
    gameMenuBtn.addEventListener("click", openGameMenu);
    closeMenuBtn.addEventListener("click", closeGameMenu);
    gameMenuModal.addEventListener("click", (event) => {
      if (event.target === gameMenuModal) closeGameMenu();
    });

    document.addEventListener("keydown", e => {
      if (e.key === "Escape" && gameMenuModal.classList.contains("is-active")) {
        closeGameMenu();
        return;
      }
      if (!isGameActive()) return;
      if (isModalInputFocused(e.target)) return;
      const targetTag = e.target && e.target.tagName ? e.target.tagName : "";
      if (["INPUT", "TEXTAREA", "SELECT"].includes(targetTag)) return;
      const key = e.key.toLowerCase();
      if (key === "r") playRound("R");
      else if (key === "p") playRound("P");
      else if (key === "s") playRound("S");
    });

    achievementUnlockCounts = loadPersistentAchievements();
    achievementCatalog.forEach(a => { if (!Number.isInteger(achievementUnlockCounts[a.id]) || achievementUnlockCounts[a.id] < 0) achievementUnlockCounts[a.id] = 0; });

    const initialSettings = readInitialSettingsFromUrl();
    seedInputEl.value = String(DEFAULT_SEED);
    if (initialSettings.seed === null) initFromSeed(DEFAULT_SEED, false, initialSettings.scriptOverride);
    else initFromSeed(initialSettings.seed, initialSettings.manual, initialSettings.scriptOverride);
    maybeStartTutorial();
  </script>
</body>
</html>
