<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beat The Rock - Progressive Rock Paper Scissors</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b0c10;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    .app { max-width: 880px; width: 100%; padding: 24px 20px 40px; box-sizing: border-box; }
    h1 { font-size: 1.6rem; margin: 0 0 4px; text-align: center; }
    .subtitle { text-align: center; font-size: 0.9rem; color: #c3c7d1; margin-bottom: 4px; }
    .run-summary { text-align: center; font-size: 0.8rem; color: #9ca3af; margin-bottom: 10px; }
    .run-summary-pill { display: inline-flex; align-items: center; gap: 8px; padding: 4px 10px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); }
    .run-summary-pill strong { color: #e5e7eb; }

    .seed-row { display: flex; flex-wrap: wrap; gap: 8px 10px; align-items: center; justify-content: center; font-size: 0.8rem; color: #9ca3af; margin-bottom: 8px; }
    .seed-row label { display: inline-flex; align-items: center; gap: 6px; }
    .seed-row input { background: #020617; border-radius: 999px; border: 1px solid rgba(148,163,184,0.7); padding: 5px 10px; color: #e5e7eb; font-size: 0.8rem; width: 165px; }
    .seed-feedback { width: 100%; text-align: center; font-size: 0.78rem; min-height: 1.1rem; }
    .seed-feedback.error { color: #fca5a5; }
    .seed-feedback.info { color: #93c5fd; }

    .settings-row { display: flex; flex-wrap: wrap; gap: 8px 14px; align-items: center; justify-content: center; font-size: 0.78rem; color: #9ca3af; margin-bottom: 6px; }
    .settings-row label { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; padding: 5px 9px; border-radius: 999px; background: rgba(15,23,42,0.85); border: 1px solid rgba(148,163,184,0.6); }
    .settings-row input[type="checkbox"] { accent-color: #8b5cf6; cursor: pointer; }
    .settings-hint { font-size: 0.75rem; color: #6b7280; }

    .mode-toggle { text-align: center; font-size: 0.85rem; color: #9ca3af; margin-bottom: 4px; }
    .mode-toggle label { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; background: rgba(15,23,42,0.85); border: 1px solid rgba(148,163,184,0.6); }
    .mode-toggle input { accent-color: #8b5cf6; cursor: pointer; }

    .adaptive-stats { text-align: center; font-size: 0.78rem; color: #6b7280; margin-bottom: 4px; margin-top: 2px; }
    .adaptive-stats strong { color: #e5e7eb; }
    .mood-display { text-align: center; font-size: 0.78rem; color: #9ca3af; margin-bottom: 18px; }
    .mood-display strong { color: #fbbf24; }
    .pre-round-hint { text-align: center; font-size: 0.8rem; color: #c3c7d1; margin-bottom: 14px; min-height: 1.2rem; }

    .arena { display: grid; grid-template-columns: 1fr auto 1fr; gap: 12px; align-items: center; background: #11141f; border-radius: 16px; padding: 18px 16px; box-shadow: 0 12px 30px rgba(0,0,0,0.45); transform-origin: center; }
    @keyframes shake { 0%{transform:translate(0,0)} 20%{transform:translate(-4px,2px)} 40%{transform:translate(4px,-2px)} 60%{transform:translate(-3px,1px)} 80%{transform:translate(3px,0)} 100%{transform:translate(0,0)} }
    .arena.shake { animation: shake 0.35s ease; }
    .side { text-align: center; }
    .side h2 { font-size: 1rem; margin: 0 0 6px; text-transform: uppercase; letter-spacing: 0.06em; color: #c3c7d1; }
    .side .name-rock { color: #ffcc4d; font-weight: 700; }
    .side .name-you { color: #6ee7b7; font-weight: 700; }
    .hand { font-size: 3.2rem; min-height: 3.2rem; line-height: 1; margin-bottom: 8px; }
    .label-move { font-size: 0.9rem; color: #aeb2c0; min-height: 1.2rem; }
    .vs { font-size: 1.2rem; font-weight: 700; color: #8b5cf6; padding: 8px 10px; border-radius: 999px; border: 1px solid rgba(139,92,246,0.6); background: radial-gradient(circle at 30% 0, rgba(139,92,246,0.3), transparent), rgba(17,24,39,0.9); }

    .round-info { margin-top: 12px; display: flex; flex-wrap: wrap; gap: 6px; justify-content: space-between; align-items: baseline; font-size: 0.95rem; color: #c3c7d1; }
    .progress-wrap { margin-top: 10px; }
    .progress-labels { display: flex; justify-content: space-between; font-size: 0.8rem; color: #9ca3af; margin-bottom: 4px; }
    .progress-bar { position: relative; width: 100%; height: 6px; border-radius: 999px; background: #020617; overflow: hidden; border: 1px solid rgba(30,64,175,0.8); }
    .progress-fill { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; border-radius: 999px; background: linear-gradient(90deg, #4ade80, #22c55e, #16a34a); transition: width 0.25s ease; }

    .round-board { margin-top: 14px; padding: 12px 10px 10px; border-radius: 12px; background: radial-gradient(circle at top, rgba(56,189,248,0.12), rgba(2,6,23,0.94)); border: 1px solid rgba(56,189,248,0.35); }
    .round-board-header { display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap; color: #bae6fd; font-size: 0.8rem; margin-bottom: 8px; }
    .round-board-grid { display: grid; grid-template-columns: repeat(20, minmax(16px, 1fr)); gap: 4px; }
    .round-box { min-height: 44px; border-radius: 8px; border: 1px solid rgba(100,116,139,0.5); background: #111827; color: #64748b; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1px; line-height: 1; cursor: default; padding: 3px 1px; }
    .round-box .round-num { font-size: 0.55rem; color: #94a3b8; }
    .round-box .round-hands { font-size: 0.68rem; color: #cbd5e1; min-height: 0.72rem; }
    .round-box .round-outcome { font-size: 0.66rem; min-height: 0.66rem; }
    .round-box.played { cursor: pointer; }
    .round-box.played.win { border-color: rgba(52,211,153,0.9); background: #064e3b; }
    .round-box.played.lose { border-color: rgba(248,113,113,0.9); background: #7f1d1d; }
    .round-box.played.draw { border-color: rgba(250,204,21,0.9); background: #713f12; }
    .round-box.current { border-color: rgba(216,180,254,1); box-shadow: inset 0 0 0 1px rgba(216,180,254,0.8); }
    .round-box.played:hover,
    .round-box.played:focus-visible { transform: translateY(-1px); border-color: #38bdf8; }
    .round-box:focus-visible { outline: 3px solid #93c5fd; outline-offset: 1px; }
    .round-board-preview { margin-top: 8px; min-height: 1.2rem; font-size: 0.78rem; color: #cbd5e1; }
    .round-board-preview strong { color: #e5e7eb; }

    .challenge-row { margin-top: 12px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; }
    .btn-share { background: #2563eb; color: #eff6ff; box-shadow: 0 4px 10px rgba(0,0,0,0.55); }
    .copy-status { font-size: 0.78rem; color: #93c5fd; min-height: 1.1rem; }
    .copy-status.error { color: #fca5a5; }

    .controls { margin-top: 16px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
    button { border: none; border-radius: 999px; padding: 10px 18px; font-size: 1rem; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-weight: 600; transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease; }
    button span.hand-icon { font-size: 1.3rem; }
    .btn-rock { background: #1f2937; color: #f9fafb; box-shadow: 0 4px 10px rgba(0,0,0,0.55); min-width: 110px; }
    .btn-paper { background: #111827; color: #f9fafb; box-shadow: 0 4px 10px rgba(0,0,0,0.55); min-width: 110px; }
    .btn-scissors { background: #0f172a; color: #f9fafb; box-shadow: 0 4px 10px rgba(0,0,0,0.55); min-width: 110px; }
    .btn-reset { background: #ef4444; color: #fef2f2; box-shadow: 0 4px 10px rgba(0,0,0,0.55); }
    button:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.6); }
    button:active { transform: translateY(0); box-shadow: 0 3px 6px rgba(0,0,0,0.5); }
    button:disabled { opacity: 0.4; cursor: default; transform: none; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
    button:focus-visible { outline: 3px solid #93c5fd; outline-offset: 2px; }

    .result-line { margin-top: 14px; font-size: 1.02rem; text-align: center; min-height: 1.4rem; }
    .result-win { color: #6ee7b7; }
    .result-lose { color: #f97373; }
    .result-draw { color: #facc15; }
    .commentary { margin-top: 12px; padding: 16px 14px 14px; border-radius: 14px; border: 1px solid rgba(250,204,21,0.45); background: linear-gradient(90deg, rgba(38,38,31,0.9), rgba(60,46,4,0.45), rgba(31,41,55,0.9)); font-size: 1rem; font-weight: 650; color: #f8fafc; min-height: 3.4rem; line-height: 1.45; }
    .commentary::before { content: "THE ROCK SAYS"; display: block; margin-bottom: 8px; font-size: 0.78rem; letter-spacing: 0.08em; color: #fde68a; font-weight: 800; }

    .scoreboard { margin-top: 18px; padding: 12px 10px; border-radius: 12px; background: #020617; border: 1px solid rgba(148,163,184,0.35); }
    .score-header { display: flex; justify-content: space-between; font-size: 0.9rem; color: #9ca3af; margin-bottom: 8px; flex-wrap: wrap; gap: 4px; }
    .score-header strong { color: #f9fafb; }
    .score-track { display: grid; grid-template-columns: repeat(20, minmax(10px, 1fr)); gap: 4px; font-size: 0.7rem; }
    .score-cell { height: 18px; border-radius: 4px; display: flex; align-items: center; justify-content: center; background: #111827; color: #6b7280; border: 1px solid transparent; }
    .score-cell.win { background: #065f46; color: #bbf7d0; }
    .score-cell.lose { background: #7f1d1d; color: #fecaca; }
    .score-cell.draw { background: #78350f; color: #fef3c7; }
    .score-cell.current { border-color: rgba(248,250,252,0.7); }

    .rock-reaction { margin-top: 8px; text-align: center; color: #cbd5e1; font-size: 0.95rem; min-height: 1.3rem; }
    .rock-reaction strong { color: #facc15; }

    .timeline { margin-top: 12px; padding: 14px 14px 10px; border-radius: 16px; background: linear-gradient(90deg, rgba(2,6,23,0.95), rgba(2,6,23,0.85) 60%, rgba(0,24,66,0.85)); border: 1px solid rgba(56,189,248,0.45); font-size: 0.82rem; color: #9ca3af; }
    .timeline-header { margin-bottom: 10px; color: #e5e7eb; font-weight: 600; display: flex; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .timeline-track { display: grid; grid-template-columns: repeat(20, minmax(26px, 1fr)); gap: 5px; margin-bottom: 8px; }
    .timeline-cell { min-height: 54px; border-radius: 10px; background: #071229; border: 1px solid #1e3a5f; display: flex; align-items: center; justify-content: center; cursor: default; position: relative; transition: border-color 0.15s ease, background 0.15s ease, transform 0.05s ease; overflow: hidden; }
    .timeline-cell-inner { display: flex; flex-direction: column; align-items: center; line-height: 1.05; font-size: 0.68rem; gap: 2px; }
    .timeline-cell-round { color: #bfdbfe; font-size: 0.68rem; }
    .timeline-cell-hands { font-size: 0.82rem; }
    .timeline-cell-outcome { font-size: 0.88rem; font-weight: 700; }
    .timeline-cell.empty .timeline-cell-hands,
    .timeline-cell.empty .timeline-cell-outcome { color: #64748b; }
    .timeline-cell.played { cursor: pointer; }
    .timeline-cell.played.win { background: #064e3b; border-color: #10b981; }
    .timeline-cell.played.lose { background: #4c0519; border-color: #e11d48; }
    .timeline-cell.played.draw { background: #713f12; border-color: #f59e0b; }
    .timeline-cell.played:hover { border-color: #93c5fd; transform: translateY(-1px); }
    .timeline-cell.played.active, .timeline-cell.current { border-color: #e9d5ff; box-shadow: 0 0 0 1px rgba(233,213,255,0.45) inset; }
    .timeline-preview { min-height: 1.2rem; font-size: 1.05rem; color: #dbeafe; }
    .timeline-preview strong { color: #e5e7eb; }

    .achievements { margin-top: 14px; padding: 14px 12px 12px; border-radius: 14px; background: linear-gradient(90deg, rgba(17,24,39,0.95), rgba(31,10,64,0.62), rgba(15,23,42,0.95)); border: 1px solid rgba(167,139,250,0.42); font-size: 0.86rem; color: #cbd5e1; }
    .achievements-header { margin-bottom: 8px; color: #f8fafc; font-weight: 700; font-size: 1rem; }
    .achievements-list { display: flex; flex-wrap: wrap; gap: 6px; }
    .achievement-badge { padding: 6px 11px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.6); background: #0b1120; color: #d1d5db; line-height: 1.3; white-space: nowrap; box-shadow: inset 0 1px 0 rgba(255,255,255,0.08); }
    .achievement-badge.rank-bronze { border-color: #f59e0b; background: #3f1d07; color: #ffedd5; }
    .achievement-badge.rank-silver { border-color: #cbd5e1; background: #1f2937; color: #f8fafc; }
    .achievement-badge.rank-gold { border-color: #facc15; background: #422006; color: #fef9c3; }
    .achievement-badge.rank-mythic { border-color: #c084fc; background: #2e1065; color: #f3e8ff; }

    .help-box { margin-top: 14px; font-size: 0.8rem; color: #9ca3af; border-radius: 10px; border: 1px solid rgba(148,163,184,0.4); background: #020617; padding: 8px 10px; }
    .help-box summary { cursor: pointer; list-style: none; color: #e5e7eb; font-weight: 600; }
    .help-box summary:focus-visible,
    .debug-panel summary:focus-visible { outline: 3px solid #93c5fd; outline-offset: 3px; border-radius: 4px; }
    .help-box summary::marker { display: none; }
    .help-box summary::-webkit-details-marker { display: none; }
    .help-box-content { margin-top: 6px; line-height: 1.4; }
    .help-box-content ul { padding-left: 18px; margin: 4px 0 0; }
    .help-legend { margin-top: 10px; font-size: 0.78rem; color: #c3c7d1; display: flex; flex-wrap: wrap; gap: 8px 10px; }
    .help-legend span { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.75); }

    .debug-panel { margin-top: 16px; font-size: 0.8rem; color: #9ca3af; }
    .debug-panel summary { cursor: pointer; list-style: none; }
    .debug-panel summary::marker { display: none; }
    .debug-panel summary::-webkit-details-marker { display: none; }
    .debug-panel summary span { text-decoration: underline; }
    .debug-log { margin-top: 8px; max-height: 260px; overflow-y: auto; border-top: 1px solid rgba(148,163,184,0.3); padding-top: 6px; }
    .debug-log-entry { margin-bottom: 4px; line-height: 1.3; }
    .history-controls { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; justify-content: space-between; font-size: 0.76rem; color: #9ca3af; }
    .btn-clear-history { background: #1f2937; color: #e5e7eb; font-size: 0.76rem; padding: 6px 12px; }
    .recent-runs { margin-top: 10px; display: grid; gap: 6px; }
    .recent-runs-header { font-size: 0.78rem; color: #9ca3af; }
    .recent-runs-list { margin: 0; padding-left: 18px; display: grid; gap: 4px; font-size: 0.76rem; color: #cbd5e1; }
    .recent-runs-empty { font-size: 0.76rem; color: #6b7280; }

    .footer { margin-top: 18px; font-size: 0.8rem; color: #6b7280; text-align: center; line-height: 1.3; }

    @media (max-width: 640px) {
      .arena { grid-template-columns: 1fr; text-align: center; }
      .vs { justify-self: center; }
      .timeline-track { grid-template-columns: repeat(5, minmax(54px, 1fr)); }
      button { padding: 12px 20px; }
    }
  </style>
</head>
<body>
  <div id="achievementToasts" class="achievement-toast-stack" aria-live="polite" aria-atomic="false"></div>
  <div class="app">
    <h1>Beat The Rock</h1>
    <div class="subtitle">20 rounds of modelled Dwayne Johnson in progressive Rock Paper Scissors, you try to read the script.</div>

    <div class="run-summary">
      <div id="runSummaryPill" class="run-summary-pill">
        <span><strong>Run</strong> pending</span>
        <span id="runSummaryScores">You 0, Rock 0, draws 0</span>
        <span id="runSummarySeed">Seed pending</span>
      </div>
    </div>

    <div class="seed-row">
      <label>Next run seed <input id="seedInput" type="text" placeholder="blank = random" /></label>
      <div id="seedFeedback" class="seed-feedback" aria-live="polite"></div>
    </div>

    <div id="adaptiveStats" class="adaptive-stats"><strong>Adaptive Rock</strong> is off. Flip the switch to let him try and read you.</div>
    <div id="moodDisplay" class="mood-display"><strong>Rock state</strong> Calm, mostly following his base pattern.</div>
    <div id="preRoundHint" class="pre-round-hint">Pre-round scout, he's waiting for your opener.</div>

    <div class="arena-wrap">
      <div id="arena" class="arena">
        <div class="side">
          <h2><span class="name-rock">Dwayne</span> (The Rock)</h2>
          <div id="rockHand" class="hand">‚ùî</div>
          <div id="rockMoveLabel" class="label-move">Waiting for bell.</div>
        </div>
        <div class="vs">R P S</div>
        <div class="side">
          <h2><span class="name-you">You</span></h2>
          <div id="yourHand" class="hand">‚ùî</div>
          <div id="yourMoveLabel" class="label-move">Pick your opener.</div>
        </div>
      </div>
    </div>

    <div class="round-info">
      <span id="roundLabel">Round 1 of 20</span>
      <span id="scoreLabel">Dwayne 0  |  You 0  |  Draws 0</span>
    </div>

    <div class="progress-wrap">
      <div class="progress-labels">
        <span>Round progress</span>
        <span id="progressText">0 of 20 completed</span>
      </div>
      <div class="progress-bar"><div id="progressFill" class="progress-fill"></div></div>
    </div>

    <div class="controls">
      <button class="btn-rock" data-move="R" aria-label="Play Rock hand"><span class="hand-icon">‚úä</span> Rock</button>
      <button class="btn-paper" data-move="P" aria-label="Play Paper hand"><span class="hand-icon">‚úã</span> Paper</button>
      <button class="btn-scissors" data-move="S" aria-label="Play Scissors hand"><span class="hand-icon">‚úåÔ∏è</span> Scissors</button>
      <button id="resetBtn" class="btn-reset" style="display:none;">Reset match</button>
    </div>

    <div id="resultLine" class="result-line"></div>
    <div id="commentary" class="commentary"></div>
    <div id="rockReaction" class="rock-reaction"></div>


    <div class="timeline">
      <div class="timeline-header"><span>20-round unified board (result + hands + order)</span><span id="timelineStatus">Round 1 is live</span></div>
      <div id="timelineTrack" class="timeline-track"></div>
      <div id="timelinePreview" class="timeline-preview">Hover a played round to preview the exact hands and outcome.</div>
    </div>

    <div class="achievements">
      <div class="achievements-header">Run achievements</div>
      <div id="achievementsList" class="achievements-list"></div>
    </div>

    <details class="help-box">
      <summary>How this works</summary>
      <div class="help-box-content">
        <ul>
          <li>The Rock has a fixed script of 20 planned moves, his base pattern.</li>
          <li>In Adaptive mode he sometimes ignores the script and tries to counter your last move.</li>
          <li>His mood changes when he loses and draws, Calm, Suspicious, Paranoid, and this changes his adapt chance.</li>
          <li>Use different seeds and toggles to create repeatable runs and shared challenges.</li>
        </ul>
        <div class="help-legend">
          <span><strong>Calm</strong> 30% adapt chance</span>
          <span><strong>Suspicious</strong> 60% adapt chance</span>
          <span><strong>Paranoid</strong> 90% adapt chance</span>
        </div>
      </div>
    </details>

    <details class="debug-panel">
      <summary><span>Round log and debug info</span></summary>
      <div id="debugLog" class="debug-log"></div>
      <div class="history-controls">
        <span>Recent runs are stored locally for continuity.</span>
        <button id="clearHistoryBtn" type="button" class="btn-clear-history">Clear history</button>
      </div>
      <div id="recentRuns" class="recent-runs"></div>
    </details>

    <div class="footer">
      With Adaptive Rock off, Dwayne uses a fixed but non obvious sequence, with it on he starts trying to beat your last move.<br />
      Note the seed for a run you like, then enter it and reset to replay the same adaptive decisions.
    </div>
  </div>

  <script>
    const rockSequenceBase = ["R","R","S","R","S","P","R","S","P","R","S","R","P","S","R","P","S","R","P","S"];
    const SCRIPT_SEQUENCE_REGEX = /^[RPS]{20}$/i;
    const beats = { R: "P", P: "S", S: "R" };
    const names = { R: "Rock", P: "Paper", S: "Scissors" };
    const glyph = { R: "‚úä", P: "‚úã", S: "‚úåÔ∏è" };

    const rockLosingQuips = [
      "The Rock arches an eyebrow. This is not how it went in the script.",
      "He pauses, looks at his hand, then at you. That is not very family friendly language.",
      "The Great One is now The Mildly Confused One.",
      "He mutters something about the writer's room and probability.",
      "The Rock is starting to realise this franchise might be yours."
    ];
    const rockWinningQuips = [
      "The Rock grins. Finally, the universe remembers who the headline act is.",
      "He does the tiny air guitar thing. You walked right into that.",
      "He whispers, 'Know your role,' which is frankly unnecessary.",
      "The arena pops. You promise yourself you will focus next round.",
      "He smells what he is cooking. It is your defeat."
    ];
    const drawQuips = [
      "You both stare at identical hands. Awkward.",
      "The Rock nods in approval. 'Respect,' he says.",
      "Stalemate. Somewhere, a statistician sighs.",
      "Nobody wins, nobody loses, but you both sell it like a main event.",
      "Evenly matched. The crowd loves a slow burn."
    ];
    const perfectQuips = [
      "That was the perfect counter. Somewhere, a game theorist applauds.",
      "You hit the exact optimal answer. The Rock absolutely hates that.",
      "Perfect read. If this were pay per view, they would replay that one.",
      "Peak efficiency. Your hand might need its own entrance music soon.",
      "That was so clinical the ref checks on The Rock."
    ];
    const imperfectQuips = [
      "There was a better move there, but hey, style points still count.",
      "Not the mathematically perfect choice, but the crowd appreciates the chaos.",
      "You zigged where the model zagged. Daring.",
      "You ignore optimal play and follow your heart. Bold strategy.",
      "Somewhere, the perfect counter timeline branches off without you."
    ];

    const rockHandEl = document.getElementById("rockHand");
    const yourHandEl = document.getElementById("yourHand");
    const rockMoveLabelEl = document.getElementById("rockMoveLabel");
    const yourMoveLabelEl = document.getElementById("yourMoveLabel");
    const roundLabelEl = document.getElementById("roundLabel");
    const scoreLabelEl = document.getElementById("scoreLabel");
    const resultLineEl = document.getElementById("resultLine");
    const commentaryEl = document.getElementById("commentary");
    const rockReactionEl = document.getElementById("rockReaction");
    const scoreTrackEl = document.getElementById("scoreTrack");
    const resetBtn = document.getElementById("resetBtn");
    const moveButtons = Array.from(document.querySelectorAll("button[data-move]"));
    const adaptiveToggle = document.getElementById("adaptiveToggle");
    const arenaEl = document.getElementById("arena");
    const progressFillEl = document.getElementById("progressFill");
    const progressTextEl = document.getElementById("progressText");
    const adaptiveStatsEl = document.getElementById("adaptiveStats");
    const moodDisplayEl = document.getElementById("moodDisplay");
    const seedInputEl = document.getElementById("seedInput");
    const seedFeedbackEl = document.getElementById("seedFeedback");
    const preRoundHintEl = document.getElementById("preRoundHint");
    const debugLogEl = document.getElementById("debugLog");
    const achievementsListEl = document.getElementById("achievementsList");
    const achievementToastsEl = document.getElementById("achievementToasts");
    const runSummaryScoresEl = document.getElementById("runSummaryScores");
    const runSummarySeedEl = document.getElementById("runSummarySeed");
    const timelineTrackEl = document.getElementById("timelineTrack");
    const timelinePreviewEl = document.getElementById("timelinePreview");
    const timelineStatusEl = document.getElementById("timelineStatus");
    const sfxToggle = document.getElementById("sfxToggle");
    const recentRunsEl = document.getElementById("recentRuns");
    const clearHistoryBtn = document.getElementById("clearHistoryBtn");

    const storageKeys = {
      adaptive: "rps.adaptiveToggle",
      sfx: "rps.sfxToggle",
      lastSeed: "rps.lastSeed",
      recentRuns: "rps.recentRuns"
    };
    const recentRunsLimit = 8;

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    let rngGame = null;
    let rngFlavor = null;
    let runSeed = 0;
    let seedWasManual = false;
    let scriptedSequenceOverride = null;

    let currentRound = 0;
    let youScore = 0;
    let rockScore = 0;
    let draws = 0;
    let perfectHits = 0;
    let perfectAbbrevs = [];
    let lastYourMove = null;

    let rockMood = "Calm";
    let rockLossStreak = 0;

    let adaptiveAttempts = 0;
    let adaptiveCorrectReads = 0;
    let adaptiveEverOnThisRun = false;
    let runAdaptiveSetting = false;
    let lastDecisionAdaptive = false;

    let audioCtx = null;
    let sfxEnabled = true;

    let historyLog = [];
    let timelineCells = [];
    let activeTimelineIndex = null;
    let storageEnabled = false;
    let recentRuns = [];
    let initialSeedFromStorage = null;

    function detectStorage() {
      try {
        const probe = "rps.storageProbe";
        window.localStorage.setItem(probe, "1");
        window.localStorage.removeItem(probe);
        return true;
      } catch (e) {
        return false;
      }
    }

    function storageGet(key) {
      if (!storageEnabled) return null;
      try {
        return window.localStorage.getItem(key);
      } catch (e) {
        return null;
      }
    }

    function storageSet(key, value) {
      if (!storageEnabled) return;
      try {
        window.localStorage.setItem(key, value);
      } catch (e) {}
    }

    function storageRemove(key) {
      if (!storageEnabled) return;
      try {
        window.localStorage.removeItem(key);
      } catch (e) {}
    }

    function parseStoredBoolean(value, fallback) {
      if (value === "true") return true;
      if (value === "false") return false;
      return fallback;
    }

    function loadPersistedSettings() {
      storageEnabled = detectStorage();
      if (!storageEnabled) {
        renderRecentRuns();
        return;
      }

      adaptiveToggle.checked = parseStoredBoolean(storageGet(storageKeys.adaptive), adaptiveToggle.checked);
      sfxToggle.checked = parseStoredBoolean(storageGet(storageKeys.sfx), sfxToggle.checked);
      sfxEnabled = sfxToggle.checked;

      const lastSeed = storageGet(storageKeys.lastSeed);
      if (lastSeed && !seedInputEl.value.trim()) seedInputEl.value = lastSeed;
      if (lastSeed) {
        const parsedSeed = parseInt(lastSeed, 10);
        if (!Number.isNaN(parsedSeed)) initialSeedFromStorage = parsedSeed;
      }

      try {
        const parsed = JSON.parse(storageGet(storageKeys.recentRuns) || "[]");
        if (Array.isArray(parsed)) recentRuns = parsed.slice(0, recentRunsLimit);
      } catch (e) {
        recentRuns = [];
      }
      renderRecentRuns();
    }

    function renderRecentRuns() {
      if (!recentRunsEl) return;
      recentRunsEl.innerHTML = "";

      const header = document.createElement("div");
      header.className = "recent-runs-header";
      header.textContent = `Recent runs (last ${recentRunsLimit})`;
      recentRunsEl.appendChild(header);

      if (!storageEnabled) {
        const note = document.createElement("div");
        note.className = "recent-runs-empty";
        note.textContent = "Local storage unavailable in this environment.";
        recentRunsEl.appendChild(note);
        return;
      }

      if (!recentRuns.length) {
        const empty = document.createElement("div");
        empty.className = "recent-runs-empty";
        empty.textContent = "No completed runs saved yet.";
        recentRunsEl.appendChild(empty);
        return;
      }

      const list = document.createElement("ol");
      list.className = "recent-runs-list";
      recentRuns.forEach(run => {
        const item = document.createElement("li");
        const runRecord = `record ${run.youScore}-${run.rockScore}-${run.draws}`;
        const achieved = Array.isArray(run.achievements) && run.achievements.length
          ? ` achievements ${run.achievements.join(", ")}`
          : "";
        item.textContent = `Seed ${run.seed}, ${runRecord}, adaptive ${run.adaptive ? "on" : "off"}, perfect ${run.perfectHits ?? "-"}/20.${achieved}`;
        list.appendChild(item);
      });
      recentRunsEl.appendChild(list);
    }

    function persistRunSummary() {
      if (!storageEnabled) return;
      const achievementNames = getAchievements().map(a => a.name);
      const runSummary = {
        seed: runSeed,
        youScore,
        rockScore,
        draws,
        adaptive: runAdaptiveSetting,
        perfectHits,
        achievements: achievementNames,
        ts: Date.now()
      };
      recentRuns.unshift(runSummary);
      recentRuns = recentRuns.slice(0, recentRunsLimit);
      storageSet(storageKeys.recentRuns, JSON.stringify(recentRuns));
      renderRecentRuns();
    }

    function clearRecentRuns() {
      recentRuns = [];
      storageRemove(storageKeys.recentRuns);
      renderRecentRuns();
    }

    function ensureAudioContext() {
      if (audioCtx) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (AudioContext) audioCtx = new AudioContext();
    }

    function playBeep(type) {
      if (!sfxEnabled) return;
      try {
        ensureAudioContext();
        if (!audioCtx || audioCtx.state === "suspended") {
          audioCtx.resume && audioCtx.resume();
        }
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 440;
        if (type === "win") freq = 880;
        if (type === "lose") freq = 260;
        if (type === "draw") freq = 380;

        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.15, audioCtx.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
      } catch (e) {}
    }

    function randomFromFlavor(arr) {
      const r = rngFlavor ? rngFlavor() : Math.random();
      return arr[Math.floor(r * arr.length)];
    }

    function describeRound(outcome) {
      if (outcome === "win") return randomFromFlavor(rockLosingQuips);
      if (outcome === "lose") return randomFromFlavor(rockWinningQuips);
      return randomFromFlavor(drawQuips);
    }

    function createScoreCells() {
      if (!scoreTrackEl) return;
      scoreTrackEl.innerHTML = "";
      for (let i = 0; i < 20; i++) {
        const cell = document.createElement("div");
        cell.className = "score-cell";
        cell.textContent = "¬∑";
        scoreTrackEl.appendChild(cell);
      }
    }

    function updateScoreboard() {
      if (!scoreTrackEl) return;
      const cells = Array.from(scoreTrackEl.children);
      cells.forEach((cell, idx) => {
        cell.className = "score-cell";
        cell.textContent = "¬∑";
        cell.removeAttribute("aria-label");

        if (idx === currentRound && currentRound < 20) cell.classList.add("current");

        const mark = track[idx];
        if (!mark) return;

        if (mark === "W") {
          cell.classList.add("win");
          cell.textContent = "W";
          cell.setAttribute("aria-label", `Round ${idx + 1} result, win.`);
        } else if (mark === "L") {
          cell.classList.add("lose");
          cell.textContent = "L";
          cell.setAttribute("aria-label", `Round ${idx + 1} result, loss.`);
        } else {
          cell.classList.add("draw");
          cell.textContent = "D";
          cell.setAttribute("aria-label", `Round ${idx + 1} result, draw.`);
        }
      });
    }

    function createRoundBoardCells() {
      roundBoardEl.innerHTML = "";
      roundBoardCells = [];
      for (let i = 0; i < 20; i++) {
        const cell = document.createElement("div");
        cell.className = "timeline-cell empty";
        cell.innerHTML = `<div class="timeline-cell-inner"><span class="timeline-cell-round">R${i + 1}</span><span class="timeline-cell-hands">¬∑</span><span class="timeline-cell-outcome">¬∑</span></div>`;
        cell.addEventListener("mouseenter", () => handleTimelineHover(i));
        cell.addEventListener("mouseleave", () => clearTimelineHover(i));
        timelineTrackEl.appendChild(cell);
        timelineCells.push(cell);
      }
    }

    function renderTimeline() {
      timelineCells.forEach((cell, i) => {
        cell.className = "timeline-cell empty";
        cell.innerHTML = `<div class="timeline-cell-inner"><span class="timeline-cell-round">R${i + 1}</span><span class="timeline-cell-hands">¬∑</span><span class="timeline-cell-outcome">¬∑</span></div>`;
        if (i < historyLog.length) {
          const entry = historyLog[i];
          const outcomeChar = entry.outcome === "win" ? "W" : entry.outcome === "lose" ? "L" : "D";
          cell.className = `timeline-cell played ${entry.outcome}`;
          cell.innerHTML =
            `<div class="timeline-cell-inner"><span class="timeline-cell-round">R${entry.round}</span><span class="timeline-cell-hands">${glyph[entry.rockMove]} ${glyph[entry.yourMove]}</span><span class="timeline-cell-outcome">${outcomeChar}</span></div>`;
        } else if (i === currentRound && currentRound < 20) {
          cell.classList.add("current");
        }

        const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
        const resultMark = entry.outcome === "win" ? "W" : entry.outcome === "lose" ? "L" : "D";

        cell.classList.add("played", entry.outcome);
        cell.innerHTML =
          `<span class="round-num">R${entry.round}</span>` +
          `<span class="round-hands">${glyph[entry.rockMove]}${glyph[entry.yourMove]}</span>` +
          `<span class="round-outcome">${resultMark}</span>`;
        cell.setAttribute("aria-label", `Round ${entry.round}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${outcomeText}.`);
      });

      if (currentRound >= 20) roundBoardStatusEl.textContent = "All 20 rounds complete";
      else roundBoardStatusEl.textContent = `Round ${currentRound + 1} is live`;

      if (activeRoundBoardIndex !== null && roundBoardCells[activeRoundBoardIndex]) {
        roundBoardCells[activeRoundBoardIndex].classList.add("current");
      }
    }

    function handleRoundBoardHover(index) {
      if (index >= historyLog.length) {
        roundBoardPreviewEl.innerHTML = `<strong>Round ${index + 1}</strong> not played yet in this run.`;
        return;
      }
      const entry = historyLog[index];
      activeRoundBoardIndex = index;
      const outcomeText = entry.outcome === "win" ? "you win" : entry.outcome === "lose" ? "The Rock wins" : "draw";
      const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
      roundBoardPreviewEl.innerHTML =
        `<strong>Round ${entry.round}</strong>, Dwayne ${names[entry.rockMove]} (${glyph[entry.rockMove]}) vs you ` +
        `${names[entry.yourMove]} (${glyph[entry.yourMove]}), outcome ${outcomeText}, state ${entry.mood}, ${pathText}.`;
    }

    function clearRoundBoardHover(index) {
      if (activeRoundBoardIndex === index) activeRoundBoardIndex = null;
      if (historyLog.length === 0) {
        timelinePreviewEl.textContent = "Hover a played round to preview exact hands and outcome.";
      if (timelineStatusEl) timelineStatusEl.textContent = "Round 1 is live";
      } else {
        const last = historyLog[historyLog.length - 1];
        const outcomeText = last.outcome === "win" ? "you win" : last.outcome === "lose" ? "The Rock wins" : "draw";
        timelinePreviewEl.innerHTML = `<strong>Last round was ${last.round}</strong>, outcome ${outcomeText}. Hover any played round for detail.`;
      }
    }

    function setButtonsEnabled(enabled) { moveButtons.forEach(btn => btn.disabled = !enabled); }

    function updateRoundLabel() { roundLabelEl.textContent = `Round ${Math.min(currentRound + 1, 20)} of 20`; }
    function updateScoreLabel() { scoreLabelEl.textContent = `Dwayne ${rockScore}  |  You ${youScore}  |  Draws ${draws}`; }
    function updateProgressBar() {
      const pct = (currentRound / 20) * 100;
      progressFillEl.style.width = `${pct}%`;
      progressTextEl.textContent = `${currentRound} of 20 completed`;
    }
    function updateRunSummary() {
      runSummaryScoresEl.textContent = `You ${youScore}, Rock ${rockScore}, draws ${draws}`;
      runSummarySeedEl.textContent = `Seed ${runSeed}`;
    }

    function showCopyStatus(message, isError) {
      copyStatusEl.textContent = message;
      copyStatusEl.classList.toggle("error", !!isError);
      if (showCopyStatus.timer) clearTimeout(showCopyStatus.timer);
      showCopyStatus.timer = setTimeout(() => {
        copyStatusEl.textContent = "";
        copyStatusEl.classList.remove("error");
      }, 2400);
    }

    function buildChallengeLink() {
      const url = new URL(window.location.href);
      const adaptiveRunSequence = historyLog.length === 20 && historyLog.some(entry => entry.adaptiveUsed)
        ? historyLog.map(entry => entry.rockMove).join("")
        : null;

      url.searchParams.set("seed", String(runSeed));
      if (adaptiveRunSequence) {
        url.searchParams.set("script", adaptiveRunSequence);
        url.searchParams.set("adaptive", "0");
      } else {
        url.searchParams.delete("script");
        url.searchParams.set("adaptive", adaptiveToggle.checked ? "1" : "0");
      }
      url.searchParams.set("sfx", sfxToggle.checked ? "1" : "0");
      return url.toString();
    }

    function fallbackCopyText(text) {
      const tempInput = document.createElement("input");
      tempInput.type = "text";
      tempInput.value = text;
      tempInput.setAttribute("readonly", "readonly");
      tempInput.style.position = "fixed";
      tempInput.style.opacity = "0";
      document.body.appendChild(tempInput);
      tempInput.focus();
      tempInput.select();
      tempInput.setSelectionRange(0, tempInput.value.length);
      const copied = document.execCommand("copy");
      document.body.removeChild(tempInput);
      return copied;
    }

    async function copyChallengeLink() {
      const challengeLink = buildChallengeLink();
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(challengeLink);
          showCopyStatus("Challenge link copied.", false);
          return;
        }
      } catch (err) {}

      const copied = fallbackCopyText(challengeLink);
      if (copied) showCopyStatus("Challenge link copied.", false);
      else showCopyStatus("Could not copy. Please copy manually.", true);
    }

    function readInitialSettingsFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const seedParam = params.get("seed");
      const scriptParam = params.get("script");
      const adaptiveParam = params.get("adaptive");
      const sfxParam = params.get("sfx");

      let scriptOverride = null;
      if (scriptParam && SCRIPT_SEQUENCE_REGEX.test(scriptParam)) {
        scriptOverride = scriptParam.toUpperCase().split("");
      }

      if (scriptOverride) {
        adaptiveToggle.checked = false;
      } else if (adaptiveParam === "1" || adaptiveParam === "0") {
        adaptiveToggle.checked = adaptiveParam === "1";
      }
      if (sfxParam === "1" || sfxParam === "0") {
        sfxToggle.checked = sfxParam === "1";
      }
      sfxEnabled = sfxToggle.checked;

      if (seedParam === null) return { seed: null, manual: false, scriptOverride };
      const normalizedSeed = normalizeSeed(seedParam);
      if (!normalizedSeed.valid) return { seed: null, manual: false, scriptOverride };
      return { seed: normalizedSeed.seed, manual: true, scriptOverride };
    }

    function shakeArena() {
      arenaEl.classList.remove("shake");
      void arenaEl.offsetWidth;
      arenaEl.classList.add("shake");
      setTimeout(() => arenaEl.classList.remove("shake"), 350);
    }

    function updateAdaptiveStats() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (!adaptiveToggle.checked) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> is off. If he flipped it on in a promo, ${rockMood} would be a ${adaptPct} percent adapt chance.`;
        return;
      }
      if (adaptiveAttempts === 0) {
        adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> current mood says ${adaptPct} percent adapt chance this round. Attempts will show once he starts taking swings.`;
        return;
      }
      const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
      adaptiveStatsEl.innerHTML = `<strong>Adaptive Rock</strong> chance this round ${adaptPct} percent, attempts ${adaptiveAttempts}, correct reads ${adaptiveCorrectReads}, accuracy ${acc} percent.`;
    }

    function updateMoodDisplay() {
      const adaptPct = Math.round(moodAdaptChance() * 100);
      let text;
      if (!adaptiveToggle.checked) {
        text = `<strong>Rock state</strong> ${rockMood}, adaptive mode is off so the ${adaptPct} percent read chance is just locker-room chatter.`;
      } else {
        if (rockMood === "Calm") text = `<strong>Rock state</strong> Calm, cool entrance music, ${adaptPct} percent chance he throws out script and reads your last move.`;
        else if (rockMood === "Suspicious") text = `<strong>Rock state</strong> Suspicious, eyebrow up, ${adaptPct} percent chance he calls an audible to counter.`;
        else text = `<strong>Rock state</strong> Paranoid, full main-event intensity, ${adaptPct} percent chance he tries to hard read you.`;
      }
      moodDisplayEl.innerHTML = text;
    }

    function updatePreRoundHint() {
      if (currentRound >= 20) {
        preRoundHintEl.textContent = "Pre-round scout, full match complete. Check the unified round board for the receipts.";
        return;
      }
      const adaptPct = Math.round(moodAdaptChance() * 100);
      if (!adaptiveToggle.checked || currentRound === 0 || !lastYourMove) {
        preRoundHintEl.textContent = `Pre-round scout, ${rockMood.toLowerCase()} energy, script lane likely this beat.`;
        return;
      }
      if (rockMood === "Calm") preRoundHintEl.textContent = `Pre-round scout, he's calm but alert, ${adaptPct} percent read chance right now.`;
      else if (rockMood === "Suspicious") preRoundHintEl.textContent = `Pre-round scout, he's reading aggressively right now, ${adaptPct} percent chance he hunts your last hand.`;
      else preRoundHintEl.textContent = `Pre-round scout, paranoid mode is blazing, ${adaptPct} percent chance he hard-counters your last hand.`;
    }

    function renderDebugLog() {
      debugLogEl.innerHTML = "";
      historyLog.forEach(entry => {
        const div = document.createElement("div");
        div.className = "debug-log-entry";
        const pathText = entry.adaptiveUsed ? `adaptive read path, correct read ${entry.adaptiveCorrect ? "yes" : "no"}` : "base script path";
        div.textContent =
          `Round ${entry.round}, state ${entry.mood}, Dwayne ${names[entry.rockMove]}, you ${names[entry.yourMove]}, outcome ${entry.outcome}, ${adaptiveText}.`;
        debugLogEl.appendChild(div);
      });
    }

    function moodAdaptChance() { return rockMood === "Calm" ? 0.3 : rockMood === "Suspicious" ? 0.6 : 0.9; }

    function updateRockMood(outcome) {
      if (outcome === "win") rockLossStreak += 1;
      else if (outcome === "lose") rockLossStreak = 0;
      else rockLossStreak = Math.max(0, rockLossStreak - 1);

      if (rockLossStreak >= 3) rockMood = "Paranoid";
      else if (rockLossStreak >= 1) rockMood = "Suspicious";
      else rockMood = "Calm";
    }

    function getRockMoveForRound() {
      const adaptive = adaptiveToggle.checked;
      if (!adaptive || currentRound === 0 || !lastYourMove) {
        lastDecisionAdaptive = false;
        return scriptedSequenceOverride ? scriptedSequenceOverride[currentRound] : rockSequenceBase[currentRound];
      }
      const r = rngGame ? rngGame() : Math.random();
      if (r < moodAdaptChance()) {
        lastDecisionAdaptive = true;
        adaptiveAttempts += 1;
        return beats[lastYourMove];
      }
      lastDecisionAdaptive = false;
      return scriptedSequenceOverride ? scriptedSequenceOverride[currentRound] : rockSequenceBase[currentRound];
    }

    function isGameActive() { return currentRound < 20 && !moveButtons[0].disabled; }

    function playRound(yourMove) {
      if (currentRound >= 20) return;
      if (adaptiveToggle.checked) adaptiveEverOnThisRun = true;

      const moodBefore = rockMood;
      const rockMove = getRockMoveForRound();
      lastYourMove = yourMove;

      rockHandEl.textContent = glyph[rockMove];
      rockMoveLabelEl.textContent = names[rockMove];
      yourHandEl.textContent = glyph[yourMove];
      yourMoveLabelEl.textContent = names[yourMove];

      const perfect = beats[rockMove];
      perfectAbbrevs.push(names[perfect][0]);

      let outcome;
      if (yourMove === rockMove) {
        outcome = "draw"; draws += 1;
        resultLineEl.textContent = "Result, draw."; resultLineEl.className = "result-line result-draw";
        playBeep("draw");
      } else if (beats[rockMove] === yourMove) {
        outcome = "win"; youScore += 1;
        resultLineEl.textContent = "Result, you win this round."; resultLineEl.className = "result-line result-win";
        playBeep("win"); shakeArena();
      } else {
        outcome = "lose"; rockScore += 1;
        resultLineEl.textContent = "Result, The Rock wins this round."; resultLineEl.className = "result-line result-lose";
        playBeep("lose");
      }

      if (lastDecisionAdaptive && beats[yourMove] === rockMove) adaptiveCorrectReads += 1;

      const isPerfect = yourMove === perfect;
      if (isPerfect) perfectHits += 1;

      updateRockMood(outcome);
      updateMoodDisplay();

      commentaryEl.textContent = describeRound(outcome, isPerfect);
      if (rockReactionEl) rockReactionEl.innerHTML = `<strong>Rock state</strong> ${outcome === "win" ? "He looks rattled and starts second-guessing the script." : outcome === "lose" ? "He smirks and gestures to the crowd like he called it." : "He nods, neither side giving an inch."}`;

      historyLog.push({
        round: currentRound + 1,
        rockMove, yourMove, perfectMove: perfect,
        outcome,
        adaptiveUsed: lastDecisionAdaptive,
        adaptiveCorrect: lastDecisionAdaptive && (beats[yourMove] === rockMove),
        mood: moodBefore,
        isPerfect
      });

      renderDebugLog();

      currentRound += 1;
      renderRoundBoard();
      updateScoreLabel();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateRunSummary();
      if (timelineStatusEl) timelineStatusEl.textContent = currentRound >= 20 ? "Run complete" : `Round ${currentRound + 1} is live`;
      renderAchievements();

      if (currentRound >= 20) {
        setButtonsEnabled(false);
        showFinalSummary();
      }
    }

    function getAchievements() {
      const achievements = [];
      if (historyLog.length === 0) return achievements;

      if (historyLog[0].outcome === "win") achievements.push({ name: "Opening Pop", text: "You won round 1.", emoji: "üé¨", rank: "bronze" });

      let maxWinStreak = 0, curW = 0;
      let maxRockStreak = 0, curL = 0;
      let paranoidCount = 0;

      historyLog.forEach(entry => {
        if (entry.outcome === "win") { curW += 1; curL = 0; }
        else if (entry.outcome === "lose") { curL += 1; curW = 0; }
        else { curW = 0; curL = 0; }

        maxWinStreak = Math.max(maxWinStreak, curW);
        maxRockStreak = Math.max(maxRockStreak, curL);
        if (entry.mood === "Paranoid") paranoidCount += 1;
      });
      renderAchievements();
    }

      if (maxWinStreak >= 4) achievements.push({ name: "Hot Streak", text: `You reached a win streak of ${maxWinStreak}.`, emoji: "üî•", rank: "silver" });
      if (maxRockStreak >= 3) achievements.push({ name: "Cold Shower", text: `The Rock reached a win streak of ${maxRockStreak}.`, emoji: "üßä", rank: "bronze" });
      if (Math.abs(youScore - rockScore) <= 1 && youScore >= rockScore) achievements.push({ name: "Edge Of Your Seat", text: "You won a very close run.", emoji: "üé¢", rank: "silver" });
      if (paranoidCount >= 5) achievements.push({ name: "Paranoid Era", text: "You kept The Rock in Paranoid state for a long stretch.", emoji: "üëÄ", rank: "gold" });
      if (perfectHits >= 10) achievements.push({ name: "Perfect Counter Enjoyer", text: `You played ${perfectHits} perfect counters.`, emoji: "üß†", rank: "gold" });
      if (perfectHits === historyLog.length) achievements.push({ name: "Theoretical Maximum", text: "You played a perfect counter every single round.", emoji: "‚ôæÔ∏è", rank: "mythic" });
      if (seedWasManual && youScore > rockScore) achievements.push({ name: "Seeded Legend", text: "You chose the seed and still beat The Rock.", emoji: "üå±", rank: "silver" });

      if (adaptiveEverOnThisRun && adaptiveAttempts >= 5) {
        const rate = adaptiveCorrectReads / adaptiveAttempts;
        if (rate >= 0.6 && youScore > rockScore) achievements.push({ name: "Adaptive Bully", text: "You beat him even though his adaptive reads were strong.", emoji: "ü¶æ", rank: "gold" });
      }

      if (youScore === 0 && rockScore === 0 && draws > 0) achievements.push({ name: "Pacifist Match", text: "You somehow avoided winning or losing any round.", emoji: "üïäÔ∏è", rank: "mythic" });
      return achievements;
    }

    function renderAchievements() {
      achievementsListEl.innerHTML = "";
      if (achievements.length === 0) {
        achievementsListEl.textContent = historyLog.length === 0
          ? "Play a round to start unlocking achievements."
          : "No achievements unlocked yet this run. Keep going.";
        return;
      }

      unlocked.forEach(a => {
        const div = document.createElement("div");
        div.className = `achievement-badge rank-${a.rank || "bronze"}`;
        div.textContent = `${a.emoji || "üèÖ"} ${a.name}: ${a.text}`;
        achievementsListEl.appendChild(div);
      });
    }

    function showFinalSummary() {
      const summaryLines = [];
      summaryLines.push(`Final score after 20 rounds, Dwayne ${rockScore}, you ${youScore}, draws ${draws}.`);
      summaryLines.push(`You won ${youScore}, lost ${rockScore}, drew ${draws}; keep pressing for cleaner reads and streak control.`);
      summaryLines.push(`Legend R Rock, P Paper, S Scissors.`);

      if (adaptiveEverOnThisRun && adaptiveAttempts > 0) {
        const acc = Math.round((adaptiveCorrectReads / adaptiveAttempts) * 100);
        summaryLines.push(`Adaptive Rock made ${adaptiveAttempts} read attempts, with ${adaptiveCorrectReads} correct, accuracy ${acc} percent.`);
      }

      const runAchievements = getUnlockedAchievementDefs();
      if (runAchievements.length > 0) summaryLines.push(`Achievements unlocked this run, ${runAchievements.map(a => a.name).join(", ")}.`);
      else summaryLines.push("No achievements this time, try different seeds or adaptive settings.");

      summaryLines.push("Use the unified round board or round log to review every move and state.");
      commentaryEl.textContent = summaryLines.join(" ");

      renderAchievements();
      persistRunSummary();
      if (historyLog.length > 0) handleTimelineHover(historyLog.length - 1);
      resetBtn.style.display = "inline-flex";
    }

    function initFromSeed(seed, manualFlag, persistSeed = true) {
      runSeed = seed >>> 0;
      seedWasManual = !!manualFlag;
      seedDisplayEl.textContent = `Run seed, ${runSeed}`;
      if (persistSeed) storageSet(storageKeys.lastSeed, String(runSeed));
      rngGame = mulberry32(runSeed);
      rngFlavor = mulberry32(runSeed ^ 0x9E3779B9);

      if (scriptedSequenceOverride) {
        adaptiveToggle.checked = false;
        adaptiveToggle.disabled = true;
      } else {
        adaptiveToggle.disabled = false;
      }

      currentRound = 0;
      youScore = 0;
      rockScore = 0;
      draws = 0;
      perfectHits = 0;
      perfectAbbrevs = [];
      lastYourMove = null;

      adaptiveAttempts = 0;
      adaptiveCorrectReads = 0;
      adaptiveEverOnThisRun = false;
      runAdaptiveSetting = adaptiveToggle.checked;
      lastDecisionAdaptive = false;

      rockMood = "Calm";
      rockLossStreak = 0;

      historyLog = [];
      debugLogEl.innerHTML = "";
      achievementsListEl.innerHTML = "Play a round to start unlocking achievements.";

      rockHandEl.textContent = "‚ùî";
      yourHandEl.textContent = "‚ùî";
      rockMoveLabelEl.textContent = "Waiting for bell.";
      yourMoveLabelEl.textContent = "Pick your opener.";
      resultLineEl.textContent = "";
      resultLineEl.className = "result-line";
      commentaryEl.textContent = "";
      if (rockReactionEl) rockReactionEl.innerHTML = "<strong>Rock state</strong> Pre-round scout, suspicious energy, script lane likely this beat.";

      createScoreCells();
      createTimelineCells();
      renderTimeline();
      timelinePreviewEl.textContent = "Hover a played round to preview exact hands and outcome.";
      if (timelineStatusEl) timelineStatusEl.textContent = "Round 1 is live";

      updateScoreLabel();
      updateRoundLabel();
      updateProgressBar();
      updateAdaptiveStats();
      updateMoodDisplay();
      updatePreRoundHint();
      updateRunSummary();

      if (scriptedSequenceOverride) {
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = "Scripted challenge loaded from shared adaptive run. Adaptive mode is locked off for exact replay.";
      }

      setButtonsEnabled(true);
      resetBtn.style.display = "none";
    }

    function resetGame() {
      const value = seedInputEl.value.trim();
      let newSeed;
      let manual = false;

      if (value === "") {
        newSeed = Math.floor(Math.random() * (U32_MAX + 1));
        seedFeedbackEl.className = "seed-feedback info";
        seedFeedbackEl.textContent = `Randomized seed for this run: ${newSeed}.`;
      } else {
        const normalizedSeed = normalizeSeed(value);
        if (!normalizedSeed.valid) {
          seedFeedbackEl.className = "seed-feedback error";
          seedFeedbackEl.textContent = "Invalid seed. Use digits only (0‚Äì4294967295).";
          return;
        }

        newSeed = normalizedSeed.seed;
        manual = true;

        seedFeedbackEl.className = "seed-feedback info";
        if (normalizedSeed.clamped) seedFeedbackEl.textContent = `Seed clamped to unsigned 32-bit range. Starting run with normalized seed ${newSeed}.`;
        else seedFeedbackEl.textContent = `Starting run with normalized seed ${newSeed}.`;
      }
      initFromSeed(newSeed, manual, true);
    }

    moveButtons.forEach(btn => btn.addEventListener("click", () => {
      if (!isGameActive()) return;
      playRound(btn.getAttribute("data-move"));
    }));

    resetBtn.addEventListener("click", resetGame);
    adaptiveToggle.addEventListener("change", () => {
      storageSet(storageKeys.adaptive, String(adaptiveToggle.checked));
      updateAdaptiveStats();
      updateMoodDisplay();
    });
    sfxToggle.addEventListener("change", () => {
      sfxEnabled = sfxToggle.checked;
      storageSet(storageKeys.sfx, String(sfxToggle.checked));
    });
    if (clearHistoryBtn) clearHistoryBtn.addEventListener("click", clearRecentRuns);

    document.addEventListener("keydown", e => {
      if (!isGameActive()) return;
      if (e.target && e.target.tagName === "INPUT") return;
      const key = e.key.toLowerCase();
      if (key === "r") playRound("R");
      else if (key === "p") playRound("P");
      else if (key === "s") playRound("S");
    });

    loadPersistedSettings();
    const startupSeed = initialSeedFromStorage ?? Math.floor(Math.random() * 1e9);
    const shouldPersistStartupSeed = initialSeedFromStorage === null;
    initFromSeed(startupSeed, false, shouldPersistStartupSeed);
  </script>
</body>
</html>
